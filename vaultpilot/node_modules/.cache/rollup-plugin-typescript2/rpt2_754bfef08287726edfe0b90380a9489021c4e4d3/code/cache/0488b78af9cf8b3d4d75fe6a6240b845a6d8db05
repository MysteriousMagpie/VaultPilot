{"code":"import { __awaiter } from \"tslib\";\n/**\n * Fetches schedule data from the EvoAgentX API\n * @param noteText - The full text of the active note\n * @param apiClient - The EvoAgentX API client instance\n * @returns Promise with the schedule markdown and headline\n */\nexport function fetchSchedule(noteText, apiClient) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        console.log('üîÑ [Plan My Day] Starting schedule fetch...');\n        console.log('üìù [Plan My Day] Note text length:', noteText.length);\n        console.log('üîó [Plan My Day] API client type:', typeof apiClient);\n        if (!apiClient) {\n            const error = 'API client is null or undefined';\n            console.error('‚ùå [Plan My Day] Error:', error);\n            throw new Error(error);\n        }\n        if (!apiClient.planTasks) {\n            const error = 'API client does not have planTasks method';\n            console.error('‚ùå [Plan My Day] Error:', error);\n            console.log('üîç [Plan My Day] Available methods:', Object.getOwnPropertyNames(apiClient));\n            throw new Error(error);\n        }\n        try {\n            console.log('üì§ [Plan My Day] Sending request to EvoAgentX...');\n            // Use EvoAgentX task planning endpoint instead of local server\n            const response = yield apiClient.planTasks({\n                goal: `Create a daily schedule based on this note content`,\n                context: noteText,\n                timeframe: '1 day'\n            });\n            console.log('üì• [Plan My Day] Received response:', {\n                success: response.success,\n                hasData: !!response.data,\n                error: response.error\n            });\n            console.log('üîç [Plan My Day] Raw response data:', JSON.stringify(response.data, null, 2));\n            console.log('üîç [Plan My Day] Response data type:', typeof response.data);\n            console.log('üîç [Plan My Day] Response data keys:', response.data ? Object.keys(response.data) : 'no data');\n            if (!response.success) {\n                const error = response.error || 'Failed to generate schedule';\n                console.error('‚ùå [Plan My Day] API Error:', error);\n                throw new Error(error);\n            }\n            if (!response.data) {\n                const error = 'No data in API response';\n                console.error('‚ùå [Plan My Day] Error:', error);\n                console.log('üîç [Plan My Day] Full response:', response);\n                throw new Error(error);\n            }\n            // The EvoAgentX API returns a nested structure: response.data.data.plan\n            const actualData = response.data.data || response.data;\n            console.log('üìã [Plan My Day] Response data structure:', {\n                hasPlan: !!actualData.plan,\n                planKeys: actualData.plan ? Object.keys(actualData.plan) : null,\n                hasTasks: ((_a = actualData.plan) === null || _a === void 0 ? void 0 : _a.tasks) ? true : false,\n                taskCount: ((_c = (_b = actualData.plan) === null || _b === void 0 ? void 0 : _b.tasks) === null || _c === void 0 ? void 0 : _c.length) || 0\n            });\n            // Check if plan exists in response\n            if (!actualData.plan) {\n                const error = 'No plan data in API response';\n                console.error('‚ùå [Plan My Day] Error:', error);\n                console.log('üîç [Plan My Day] Full response data:', response.data);\n                console.log('üîç [Plan My Day] Actual data:', actualData);\n                throw new Error(error);\n            }\n            // Convert EvoAgentX task planning response to schedule format\n            const taskPlan = actualData.plan;\n            const tasks = taskPlan.tasks || [];\n            console.log('üìù [Plan My Day] Processing tasks:', tasks.length);\n            if (tasks.length === 0) {\n                console.warn('‚ö†Ô∏è [Plan My Day] No tasks in response, creating fallback schedule');\n                return {\n                    scheduleMarkdown: '| Time | Task |\\n|------|------|\\n| 9:00 AM | Plan your day |\\n| 10:00 AM | Start working |\\n| 12:00 PM | Lunch break |',\n                    headline: 'üìÖ Basic schedule created (no tasks found in note)'\n                };\n            }\n            // Generate schedule markdown from tasks\n            let scheduleMarkdown = '| Time | Task |\\n|------|------|\\n';\n            // Extract scheduled times from task descriptions or generate them\n            tasks.forEach((task, index) => {\n                var _a, _b;\n                console.log(`üìã [Plan My Day] Processing task ${index + 1}:`, {\n                    title: task.title,\n                    description: (_a = task.description) === null || _a === void 0 ? void 0 : _a.substring(0, 100),\n                    priority: task.priority,\n                    estimatedTime: task.estimated_time\n                });\n                const timeMatch = (_b = task.description) === null || _b === void 0 ? void 0 : _b.match(/(\\d{1,2}:\\d{2})/);\n                const time = timeMatch ? timeMatch[1] : `${9 + Math.floor(index * 1.5)}:${(index * 30) % 60 || '00'}`;\n                scheduleMarkdown += `| ${time} | ${task.title} |\\n`;\n            });\n            const result = {\n                scheduleMarkdown,\n                headline: `‚ú® Smart schedule created with ${tasks.length} tasks!`\n            };\n            console.log('‚úÖ [Plan My Day] Schedule generated successfully:', {\n                markdownLength: scheduleMarkdown.length,\n                taskCount: tasks.length,\n                headline: result.headline\n            });\n            return result;\n        }\n        catch (error) {\n            console.error('‚ùå [Plan My Day] Fetch error:', error);\n            console.error('üîç [Plan My Day] Error stack:', error instanceof Error ? error.stack : 'No stack trace');\n            // Re-throw with more context\n            if (error instanceof Error) {\n                throw new Error(`Schedule fetch failed: ${error.message}`);\n            }\n            else {\n                throw new Error(`Schedule fetch failed: ${String(error)}`);\n            }\n        }\n    });\n}\n/**\n * Finds and extracts the VaultPilot plan section from note text using comment wrapper\n * @param text - The full note text\n * @returns Match result with plan section details or null\n */\nexport function findPlanSection(text) {\n    // Look for the VaultPilot plan comment wrapper\n    const planRegex = /(<!-- vp:plan:start -->)([\\s\\S]*?)(<!-- vp:plan:end -->)/i;\n    return text.match(planRegex);\n}\n/**\n * Finds and extracts the Schedule section from note text\n * @param text - The full note text\n * @returns Match result with schedule section details or null\n */\nexport function findScheduleSection(text) {\n    // First try to match headings that are exactly \"## Schedule\" (with optional content after)\n    let scheduleRegex = /(^##\\s+Schedule\\b[^\\n]*\\n)([\\s\\S]*?)(?=\\n##\\s|$)/im;\n    let match = text.match(scheduleRegex);\n    if (match) {\n        return match;\n    }\n    // If no exact match, try to match headings that contain \"Schedule\" as a word\n    scheduleRegex = /(^##\\s*(?:.*\\s)?\\bSchedule\\b(?:\\s.*)?$\\n)([\\s\\S]*?)(?=\\n##\\s|$)/im;\n    return text.match(scheduleRegex);\n}\n/**\n * Injects or replaces the schedule section in the note text\n * @param originalText - The original note text\n * @param scheduleMarkdown - The new schedule content to inject\n * @returns Updated note text with the new schedule section\n */\nexport function injectSchedule(originalText, scheduleMarkdown) {\n    var _a, _b, _c;\n    console.log('üìù [Plan My Day] Injecting schedule:', {\n        originalLength: originalText.length,\n        scheduleLength: scheduleMarkdown.length,\n        hasOriginalContent: originalText.trim().length > 0\n    });\n    // First, check for VaultPilot comment wrapper\n    const planMatch = findPlanSection(originalText);\n    if (planMatch) {\n        console.log('üîÑ [Plan My Day] Replacing existing plan section with comment wrapper');\n        console.log('üìã [Plan My Day] Found wrapped plan section:', {\n            startComment: planMatch[1],\n            contentLength: ((_a = planMatch[2]) === null || _a === void 0 ? void 0 : _a.length) || 0,\n            endComment: planMatch[3]\n        });\n        // Replace everything inside the comment wrapper\n        const [fullMatch, startComment, , endComment] = planMatch;\n        const replacement = `${startComment}\\n${scheduleMarkdown}\\n${endComment}`;\n        const result = originalText.replace(fullMatch, replacement);\n        console.log('‚úÖ [Plan My Day] Plan section replaced within comment wrapper');\n        return result;\n    }\n    // Fall back to checking for Schedule section\n    const scheduleMatch = findScheduleSection(originalText);\n    if (scheduleMatch) {\n        console.log('üîÑ [Plan My Day] Replacing existing schedule section');\n        console.log('üìã [Plan My Day] Found section:', {\n            headingMatch: (_b = scheduleMatch[1]) === null || _b === void 0 ? void 0 : _b.substring(0, 50),\n            contentMatch: (_c = scheduleMatch[2]) === null || _c === void 0 ? void 0 : _c.substring(0, 100)\n        });\n        // Replace existing schedule section (keep heading, replace content)\n        const [fullMatch, heading] = scheduleMatch;\n        const replacement = heading + scheduleMarkdown;\n        const result = originalText.replace(fullMatch, replacement);\n        console.log('‚úÖ [Plan My Day] Schedule section replaced');\n        return result;\n    }\n    else {\n        console.log('‚ûï [Plan My Day] Adding new plan section with comment wrapper at top');\n        // Insert new plan section with comment wrapper at the top of the note\n        const wrappedPlan = `<!-- vp:plan:start -->\\n${scheduleMarkdown}\\n<!-- vp:plan:end -->\\n\\n`;\n        const result = wrappedPlan + originalText;\n        console.log('‚úÖ [Plan My Day] New plan section with wrapper added at top');\n        return result;\n    }\n}\n/**\n * Validates if the schedule markdown is properly formatted\n * @param scheduleMarkdown - The schedule content to validate\n * @returns True if valid, false otherwise\n */\nexport function validateScheduleMarkdown(scheduleMarkdown) {\n    console.log('üîç [Plan My Day] Validating schedule markdown:', {\n        length: scheduleMarkdown.length,\n        trimmedLength: scheduleMarkdown.trim().length,\n        isString: typeof scheduleMarkdown === 'string',\n        preview: scheduleMarkdown.substring(0, 100)\n    });\n    // Basic validation - check if it's not empty and contains some content\n    const isValid = scheduleMarkdown.trim().length > 0;\n    console.log('‚úÖ [Plan My Day] Validation result:', isValid);\n    return isValid;\n}\n//# sourceMappingURL=planner.js.map","references":[],"map":"{\"version\":3,\"file\":\"planner.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/planner.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"// Type definitions for the planner feature\\nexport interface PlannerResponse {\\n  scheduleMarkdown: string;\\n  headline: string;\\n}\\n\\nexport interface PlannerRequest {\\n  note: string;\\n}\\n\\n/**\\n * Fetches schedule data from the EvoAgentX API\\n * @param noteText - The full text of the active note\\n * @param apiClient - The EvoAgentX API client instance\\n * @returns Promise with the schedule markdown and headline\\n */\\nexport async function fetchSchedule(noteText: string, apiClient: any): Promise<PlannerResponse> {\\n  console.log('üîÑ [Plan My Day] Starting schedule fetch...');\\n  console.log('üìù [Plan My Day] Note text length:', noteText.length);\\n  console.log('üîó [Plan My Day] API client type:', typeof apiClient);\\n  \\n  if (!apiClient) {\\n    const error = 'API client is null or undefined';\\n    console.error('‚ùå [Plan My Day] Error:', error);\\n    throw new Error(error);\\n  }\\n\\n  if (!apiClient.planTasks) {\\n    const error = 'API client does not have planTasks method';\\n    console.error('‚ùå [Plan My Day] Error:', error);\\n    console.log('üîç [Plan My Day] Available methods:', Object.getOwnPropertyNames(apiClient));\\n    throw new Error(error);\\n  }\\n\\n  try {\\n    console.log('üì§ [Plan My Day] Sending request to EvoAgentX...');\\n    \\n    // Use EvoAgentX task planning endpoint instead of local server\\n    const response = await apiClient.planTasks({\\n      goal: `Create a daily schedule based on this note content`,\\n      context: noteText,\\n      timeframe: '1 day'\\n    });\\n\\n    console.log('üì• [Plan My Day] Received response:', {\\n      success: response.success,\\n      hasData: !!response.data,\\n      error: response.error\\n    });\\n\\n    console.log('üîç [Plan My Day] Raw response data:', JSON.stringify(response.data, null, 2));\\n    console.log('üîç [Plan My Day] Response data type:', typeof response.data);\\n    console.log('üîç [Plan My Day] Response data keys:', response.data ? Object.keys(response.data) : 'no data');\\n\\n    if (!response.success) {\\n      const error = response.error || 'Failed to generate schedule';\\n      console.error('‚ùå [Plan My Day] API Error:', error);\\n      throw new Error(error);\\n    }\\n\\n    if (!response.data) {\\n      const error = 'No data in API response';\\n      console.error('‚ùå [Plan My Day] Error:', error);\\n      console.log('üîç [Plan My Day] Full response:', response);\\n      throw new Error(error);\\n    }\\n\\n    // The EvoAgentX API returns a nested structure: response.data.data.plan\\n    const actualData = response.data.data || response.data;\\n    \\n    console.log('üìã [Plan My Day] Response data structure:', {\\n      hasPlan: !!actualData.plan,\\n      planKeys: actualData.plan ? Object.keys(actualData.plan) : null,\\n      hasTasks: actualData.plan?.tasks ? true : false,\\n      taskCount: actualData.plan?.tasks?.length || 0\\n    });\\n\\n    // Check if plan exists in response\\n    if (!actualData.plan) {\\n      const error = 'No plan data in API response';\\n      console.error('‚ùå [Plan My Day] Error:', error);\\n      console.log('üîç [Plan My Day] Full response data:', response.data);\\n      console.log('üîç [Plan My Day] Actual data:', actualData);\\n      throw new Error(error);\\n    }\\n\\n    // Convert EvoAgentX task planning response to schedule format\\n    const taskPlan = actualData.plan;\\n    const tasks = taskPlan.tasks || [];\\n    \\n    console.log('üìù [Plan My Day] Processing tasks:', tasks.length);\\n    \\n    if (tasks.length === 0) {\\n      console.warn('‚ö†Ô∏è [Plan My Day] No tasks in response, creating fallback schedule');\\n      return {\\n        scheduleMarkdown: '| Time | Task |\\\\n|------|------|\\\\n| 9:00 AM | Plan your day |\\\\n| 10:00 AM | Start working |\\\\n| 12:00 PM | Lunch break |',\\n        headline: 'üìÖ Basic schedule created (no tasks found in note)'\\n      };\\n    }\\n    \\n    // Generate schedule markdown from tasks\\n    let scheduleMarkdown = '| Time | Task |\\\\n|------|------|\\\\n';\\n    \\n    // Extract scheduled times from task descriptions or generate them\\n    tasks.forEach((task: any, index: number) => {\\n      console.log(`üìã [Plan My Day] Processing task ${index + 1}:`, {\\n        title: task.title,\\n        description: task.description?.substring(0, 100),\\n        priority: task.priority,\\n        estimatedTime: task.estimated_time\\n      });\\n      \\n      const timeMatch = task.description?.match(/(\\\\d{1,2}:\\\\d{2})/);\\n      const time = timeMatch ? timeMatch[1] : `${9 + Math.floor(index * 1.5)}:${(index * 30) % 60 || '00'}`;\\n      scheduleMarkdown += `| ${time} | ${task.title} |\\\\n`;\\n    });\\n\\n    const result = {\\n      scheduleMarkdown,\\n      headline: `‚ú® Smart schedule created with ${tasks.length} tasks!`\\n    };\\n\\n    console.log('‚úÖ [Plan My Day] Schedule generated successfully:', {\\n      markdownLength: scheduleMarkdown.length,\\n      taskCount: tasks.length,\\n      headline: result.headline\\n    });\\n\\n    return result;\\n\\n  } catch (error) {\\n    console.error('‚ùå [Plan My Day] Fetch error:', error);\\n    console.error('üîç [Plan My Day] Error stack:', error instanceof Error ? error.stack : 'No stack trace');\\n    \\n    // Re-throw with more context\\n    if (error instanceof Error) {\\n      throw new Error(`Schedule fetch failed: ${error.message}`);\\n    } else {\\n      throw new Error(`Schedule fetch failed: ${String(error)}`);\\n    }\\n  }\\n}\\n\\n/**\\n * Finds and extracts the VaultPilot plan section from note text using comment wrapper\\n * @param text - The full note text\\n * @returns Match result with plan section details or null\\n */\\nexport function findPlanSection(text: string): RegExpMatchArray | null {\\n  // Look for the VaultPilot plan comment wrapper\\n  const planRegex = /(<!-- vp:plan:start -->)([\\\\s\\\\S]*?)(<!-- vp:plan:end -->)/i;\\n  return text.match(planRegex);\\n}\\n\\n/**\\n * Finds and extracts the Schedule section from note text\\n * @param text - The full note text\\n * @returns Match result with schedule section details or null\\n */\\nexport function findScheduleSection(text: string): RegExpMatchArray | null {\\n  // First try to match headings that are exactly \\\"## Schedule\\\" (with optional content after)\\n  let scheduleRegex = /(^##\\\\s+Schedule\\\\b[^\\\\n]*\\\\n)([\\\\s\\\\S]*?)(?=\\\\n##\\\\s|$)/im;\\n  let match = text.match(scheduleRegex);\\n  \\n  if (match) {\\n    return match;\\n  }\\n  \\n  // If no exact match, try to match headings that contain \\\"Schedule\\\" as a word\\n  scheduleRegex = /(^##\\\\s*(?:.*\\\\s)?\\\\bSchedule\\\\b(?:\\\\s.*)?$\\\\n)([\\\\s\\\\S]*?)(?=\\\\n##\\\\s|$)/im;\\n  return text.match(scheduleRegex);\\n}\\n\\n/**\\n * Injects or replaces the schedule section in the note text\\n * @param originalText - The original note text\\n * @param scheduleMarkdown - The new schedule content to inject\\n * @returns Updated note text with the new schedule section\\n */\\nexport function injectSchedule(originalText: string, scheduleMarkdown: string): string {\\n  console.log('üìù [Plan My Day] Injecting schedule:', {\\n    originalLength: originalText.length,\\n    scheduleLength: scheduleMarkdown.length,\\n    hasOriginalContent: originalText.trim().length > 0\\n  });\\n  \\n  // First, check for VaultPilot comment wrapper\\n  const planMatch = findPlanSection(originalText);\\n  \\n  if (planMatch) {\\n    console.log('üîÑ [Plan My Day] Replacing existing plan section with comment wrapper');\\n    console.log('üìã [Plan My Day] Found wrapped plan section:', {\\n      startComment: planMatch[1],\\n      contentLength: planMatch[2]?.length || 0,\\n      endComment: planMatch[3]\\n    });\\n    \\n    // Replace everything inside the comment wrapper\\n    const [fullMatch, startComment, , endComment] = planMatch;\\n    const replacement = `${startComment}\\\\n${scheduleMarkdown}\\\\n${endComment}`;\\n    const result = originalText.replace(fullMatch, replacement);\\n    \\n    console.log('‚úÖ [Plan My Day] Plan section replaced within comment wrapper');\\n    return result;\\n  }\\n  \\n  // Fall back to checking for Schedule section\\n  const scheduleMatch = findScheduleSection(originalText);\\n  \\n  if (scheduleMatch) {\\n    console.log('üîÑ [Plan My Day] Replacing existing schedule section');\\n    console.log('üìã [Plan My Day] Found section:', {\\n      headingMatch: scheduleMatch[1]?.substring(0, 50),\\n      contentMatch: scheduleMatch[2]?.substring(0, 100)\\n    });\\n    \\n    // Replace existing schedule section (keep heading, replace content)\\n    const [fullMatch, heading] = scheduleMatch;\\n    const replacement = heading + scheduleMarkdown;\\n    const result = originalText.replace(fullMatch, replacement);\\n    \\n    console.log('‚úÖ [Plan My Day] Schedule section replaced');\\n    return result;\\n  } else {\\n    console.log('‚ûï [Plan My Day] Adding new plan section with comment wrapper at top');\\n    \\n    // Insert new plan section with comment wrapper at the top of the note\\n    const wrappedPlan = `<!-- vp:plan:start -->\\\\n${scheduleMarkdown}\\\\n<!-- vp:plan:end -->\\\\n\\\\n`;\\n    const result = wrappedPlan + originalText;\\n    \\n    console.log('‚úÖ [Plan My Day] New plan section with wrapper added at top');\\n    return result;\\n  }\\n}\\n\\n/**\\n * Validates if the schedule markdown is properly formatted\\n * @param scheduleMarkdown - The schedule content to validate\\n * @returns True if valid, false otherwise\\n */\\nexport function validateScheduleMarkdown(scheduleMarkdown: string): boolean {\\n  console.log('üîç [Plan My Day] Validating schedule markdown:', {\\n    length: scheduleMarkdown.length,\\n    trimmedLength: scheduleMarkdown.trim().length,\\n    isString: typeof scheduleMarkdown === 'string',\\n    preview: scheduleMarkdown.substring(0, 100)\\n  });\\n  \\n  // Basic validation - check if it's not empty and contains some content\\n  const isValid = scheduleMarkdown.trim().length > 0;\\n  \\n  console.log('‚úÖ [Plan My Day] Validation result:', isValid);\\n  \\n  return isValid;\\n}\\n\"]}"}
