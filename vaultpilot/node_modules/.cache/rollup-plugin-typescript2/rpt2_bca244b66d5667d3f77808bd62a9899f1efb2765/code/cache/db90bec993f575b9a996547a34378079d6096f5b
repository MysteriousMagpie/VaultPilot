{"code":"/**\n * Enhanced HTTP Transport for DevPipe communication\n * Supports Server-Sent Events, connection pooling, and advanced retry logic\n */\nimport { __awaiter } from \"tslib\";\nimport { TransportType, TransportEvent } from './DevPipeTransport';\nimport { BaseTransport } from './BaseTransport';\nimport { EnvironmentDetector } from '../../utils/EnvironmentDetector';\n/**\n * Simple connection pool for HTTP requests\n */\nclass ConnectionPool {\n    constructor(options) {\n        this.activeConnections = 0;\n        this.queue = [];\n        this.maxConnections = options.maxConnections;\n    }\n    acquire(operation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const execute = () => __awaiter(this, void 0, void 0, function* () {\n                    this.activeConnections++;\n                    try {\n                        const result = yield operation();\n                        resolve(result);\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                    finally {\n                        this.activeConnections--;\n                        if (this.queue.length > 0) {\n                            const next = this.queue.shift();\n                            if (next)\n                                next();\n                        }\n                    }\n                });\n                if (this.activeConnections < this.maxConnections) {\n                    execute();\n                }\n                else {\n                    this.queue.push(execute);\n                }\n            });\n        });\n    }\n}\n/**\n * HTTP Transport implementation with enhanced features\n */\nexport class HTTPTransport extends BaseTransport {\n    constructor(config) {\n        super(TransportType.HTTP, config);\n        this.pendingRequests = new Map();\n        this.messageQueue = [];\n        this.processingQueue = false;\n        this.httpConfig = config.http || {\n            enableSSE: true,\n            maxConnections: 10,\n            keepAlive: true,\n            compression: true\n        };\n        this.connectionPool = new ConnectionPool({\n            maxConnections: this.httpConfig.maxConnections || 10,\n            keepAlive: this.httpConfig.keepAlive !== false,\n            timeout: config.timeout\n        });\n    }\n    doInitialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Validate HTTP support in environment\n            const environment = EnvironmentDetector.detect();\n            if (!environment.hasHTTP) {\n                throw new Error('HTTP transport not supported in this environment');\n            }\n            this.debug('HTTP transport initialized');\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Test basic connectivity\n                yield this.doHealthCheck();\n                // Setup Server-Sent Events if enabled\n                if (this.httpConfig.enableSSE && this.config.serverUrl) {\n                    yield this.setupSSE();\n                }\n                this.connected = true;\n                this.healthStatus.status = 'healthy';\n                this.emit(TransportEvent.CONNECTED, { transport: this.type });\n                this.debug('HTTP transport connected');\n            }\n            catch (error) {\n                this.emit(TransportEvent.ERROR, error);\n                throw error;\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Reject all pending requests\n            const requests = Array.from(this.pendingRequests.values());\n            for (const request of requests) {\n                clearTimeout(request.timeout);\n                request.reject(new Error('Transport disconnected'));\n            }\n            this.pendingRequests.clear();\n            // Close SSE connection\n            if (this.sseConnection) {\n                this.sseConnection.close();\n                this.sseConnection = undefined;\n            }\n            this.connected = false;\n            this.healthStatus.status = 'disconnected';\n            this.emit(TransportEvent.DISCONNECTED, { transport: this.type });\n            this.debug('HTTP transport disconnected');\n        });\n    }\n    send(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isConnected()) {\n                throw new Error('HTTP transport not connected');\n            }\n            // Add message ID if not present\n            if (!message.id) {\n                message.id = this.generateMessageId();\n            }\n            // Add timestamp\n            message.timestamp = Date.now();\n            return this.executeWithCircuitBreaker(() => __awaiter(this, void 0, void 0, function* () {\n                return this.sendHttpRequest(message);\n            }), 'http_send');\n        });\n    }\n    sendHttpRequest(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const timeoutHandle = setTimeout(() => {\n                    this.pendingRequests.delete(message.id);\n                    reject(new Error(`Request timeout after ${this.config.timeout}ms`));\n                }, this.config.timeout);\n                const request = {\n                    id: message.id,\n                    message,\n                    resolve: (response) => {\n                        clearTimeout(timeoutHandle);\n                        this.pendingRequests.delete(message.id);\n                        resolve(response);\n                    },\n                    reject: (error) => {\n                        clearTimeout(timeoutHandle);\n                        this.pendingRequests.delete(message.id);\n                        reject(error);\n                    },\n                    timeout: timeoutHandle,\n                    timestamp: Date.now()\n                };\n                this.pendingRequests.set(message.id, request);\n                this.performHttpRequest(message, request);\n            });\n        });\n    }\n    performHttpRequest(message, request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield this.connectionPool.acquire(() => __awaiter(this, void 0, void 0, function* () {\n                    const fetchResponse = yield fetch(`${this.config.serverUrl}/api/v1/devpipe/message`, {\n                        method: 'POST',\n                        headers: Object.assign({ 'Content-Type': 'application/json' }, (this.httpConfig.compression && { 'Accept-Encoding': 'gzip, deflate' })),\n                        body: JSON.stringify(message)\n                    });\n                    if (!fetchResponse.ok) {\n                        throw new Error(`HTTP ${fetchResponse.status}: ${fetchResponse.statusText}`);\n                    }\n                    return fetchResponse.json();\n                }));\n                // Handle immediate response\n                if (response && response.id === message.id) {\n                    const devPipeResponse = {\n                        id: response.id,\n                        success: true,\n                        payload: response.payload || response,\n                        timestamp: Date.now()\n                    };\n                    request.resolve(devPipeResponse);\n                }\n                else {\n                    // Wait for async response via SSE or polling\n                    this.debug(`Waiting for async response for message ${message.id}`);\n                }\n            }\n            catch (error) {\n                request.reject(error instanceof Error ? error : new Error('HTTP request failed'));\n            }\n        });\n    }\n    setupSSE() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.config.serverUrl) {\n                throw new Error('Server URL required for SSE');\n            }\n            return new Promise((resolve, reject) => {\n                const sseUrl = `${this.config.serverUrl}/api/v1/devpipe/stream`;\n                this.sseConnection = new EventSource(sseUrl);\n                this.sseConnection.onopen = () => {\n                    this.debug('SSE connection established');\n                    resolve();\n                };\n                this.sseConnection.onmessage = (event) => {\n                    try {\n                        const data = JSON.parse(event.data);\n                        this.handleSSEMessage(data);\n                    }\n                    catch (error) {\n                        this.debug('Failed to parse SSE message:', error);\n                    }\n                };\n                this.sseConnection.onerror = (error) => {\n                    var _a;\n                    this.debug('SSE connection error:', error);\n                    if (((_a = this.sseConnection) === null || _a === void 0 ? void 0 : _a.readyState) === EventSource.CONNECTING) {\n                        this.emit(TransportEvent.RECONNECTING, { transport: this.type });\n                    }\n                    else {\n                        this.emit(TransportEvent.ERROR, error);\n                        reject(error);\n                    }\n                };\n            });\n        });\n    }\n    handleSSEMessage(data) {\n        if (data.type === 'response' && data.id) {\n            // Handle response to pending request\n            const request = this.pendingRequests.get(data.id);\n            if (request) {\n                const response = {\n                    id: data.id,\n                    success: data.success !== false,\n                    payload: data.payload,\n                    error: data.error,\n                    timestamp: Date.now()\n                };\n                request.resolve(response);\n            }\n        }\n        else {\n            // Handle incoming message\n            this.emit(TransportEvent.MESSAGE, data);\n        }\n    }\n    doHealthCheck() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.config.serverUrl) {\n                throw new Error('No server URL configured');\n            }\n            const response = yield fetch(`${this.config.serverUrl}/api/v1/devpipe/health`, {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' },\n                signal: AbortSignal.timeout(5000)\n            });\n            if (!response.ok) {\n                throw new Error(`Health check failed: ${response.status} ${response.statusText}`);\n            }\n        });\n    }\n    getCapabilities() {\n        return {\n            supportsRealtime: !!this.httpConfig.enableSSE,\n            supportsBidirectional: !!this.httpConfig.enableSSE,\n            supportsFileSystem: false,\n            supportsStreaming: true,\n            maxMessageSize: 10 * 1024 * 1024, // 10MB\n            averageLatency: this.healthStatus.latency,\n            maxConcurrentConnections: this.httpConfig.maxConnections || 10,\n            reliability: this.calculateReliability(),\n            supportedEnvironments: ['browser', 'node', 'obsidian']\n        };\n    }\n}\n//# sourceMappingURL=HTTPTransport.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/DevPipeTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/BaseTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/utils/EnvironmentDetector.ts"],"map":"{\"version\":3,\"file\":\"HTTPTransport.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/devpipe/transports/HTTPTransport.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * Enhanced HTTP Transport for DevPipe communication\\n * Supports Server-Sent Events, connection pooling, and advanced retry logic\\n */\\n\\nimport { \\n  DevPipeTransport,\\n  TransportType,\\n  TransportConfig,\\n  TransportCapabilities,\\n  DevPipeMessage,\\n  DevPipeResponse,\\n  TransportEvent,\\n  HTTPTransportConfig\\n} from './DevPipeTransport';\\nimport { BaseTransport } from './BaseTransport';\\nimport { EnvironmentDetector } from '../../utils/EnvironmentDetector';\\n\\ninterface PendingRequest {\\n  id: string;\\n  message: DevPipeMessage;\\n  resolve: (response: DevPipeResponse) => void;\\n  reject: (error: Error) => void;\\n  timeout: any; // Can be NodeJS.Timeout or number depending on environment\\n  timestamp: number;\\n}\\n\\ninterface ConnectionPoolOptions {\\n  maxConnections: number;\\n  keepAlive: boolean;\\n  timeout: number;\\n}\\n\\n/**\\n * Simple connection pool for HTTP requests\\n */\\nclass ConnectionPool {\\n  private activeConnections: number = 0;\\n  private maxConnections: number;\\n  private queue: (() => void)[] = [];\\n\\n  constructor(options: ConnectionPoolOptions) {\\n    this.maxConnections = options.maxConnections;\\n  }\\n\\n  async acquire<T>(operation: () => Promise<T>): Promise<T> {\\n    return new Promise((resolve, reject) => {\\n      const execute = async () => {\\n        this.activeConnections++;\\n        try {\\n          const result = await operation();\\n          resolve(result);\\n        } catch (error) {\\n          reject(error);\\n        } finally {\\n          this.activeConnections--;\\n          if (this.queue.length > 0) {\\n            const next = this.queue.shift();\\n            if (next) next();\\n          }\\n        }\\n      };\\n\\n      if (this.activeConnections < this.maxConnections) {\\n        execute();\\n      } else {\\n        this.queue.push(execute);\\n      }\\n    });\\n  }\\n}\\n\\n/**\\n * HTTP Transport implementation with enhanced features\\n */\\nexport class HTTPTransport extends BaseTransport {\\n  private sseConnection?: EventSource;\\n  private connectionPool: ConnectionPool;\\n  private pendingRequests: Map<string, PendingRequest> = new Map();\\n  private httpConfig: HTTPTransportConfig;\\n  private messageQueue: DevPipeMessage[] = [];\\n  private processingQueue: boolean = false;\\n\\n  constructor(config: TransportConfig) {\\n    super(TransportType.HTTP, config);\\n    \\n    this.httpConfig = config.http || {\\n      enableSSE: true,\\n      maxConnections: 10,\\n      keepAlive: true,\\n      compression: true\\n    };\\n    \\n    this.connectionPool = new ConnectionPool({\\n      maxConnections: this.httpConfig.maxConnections || 10,\\n      keepAlive: this.httpConfig.keepAlive !== false,\\n      timeout: config.timeout\\n    });\\n  }\\n\\n  protected async doInitialize(): Promise<void> {\\n    // Validate HTTP support in environment\\n    const environment = EnvironmentDetector.detect();\\n    if (!environment.hasHTTP) {\\n      throw new Error('HTTP transport not supported in this environment');\\n    }\\n\\n    this.debug('HTTP transport initialized');\\n  }\\n\\n  async connect(): Promise<void> {\\n    try {\\n      // Test basic connectivity\\n      await this.doHealthCheck();\\n      \\n      // Setup Server-Sent Events if enabled\\n      if (this.httpConfig.enableSSE && this.config.serverUrl) {\\n        await this.setupSSE();\\n      }\\n      \\n      this.connected = true;\\n      this.healthStatus.status = 'healthy';\\n      this.emit(TransportEvent.CONNECTED, { transport: this.type });\\n      \\n      this.debug('HTTP transport connected');\\n    } catch (error) {\\n      this.emit(TransportEvent.ERROR, error);\\n      throw error;\\n    }\\n  }\\n\\n  async disconnect(): Promise<void> {\\n    // Reject all pending requests\\n    const requests = Array.from(this.pendingRequests.values());\\n    for (const request of requests) {\\n      clearTimeout(request.timeout);\\n      request.reject(new Error('Transport disconnected'));\\n    }\\n    this.pendingRequests.clear();\\n\\n    // Close SSE connection\\n    if (this.sseConnection) {\\n      this.sseConnection.close();\\n      this.sseConnection = undefined;\\n    }\\n\\n    this.connected = false;\\n    this.healthStatus.status = 'disconnected';\\n    this.emit(TransportEvent.DISCONNECTED, { transport: this.type });\\n    \\n    this.debug('HTTP transport disconnected');\\n  }\\n\\n  async send(message: DevPipeMessage): Promise<DevPipeResponse> {\\n    if (!this.isConnected()) {\\n      throw new Error('HTTP transport not connected');\\n    }\\n\\n    // Add message ID if not present\\n    if (!message.id) {\\n      message.id = this.generateMessageId();\\n    }\\n\\n    // Add timestamp\\n    message.timestamp = Date.now();\\n\\n    return this.executeWithCircuitBreaker(async () => {\\n      return this.sendHttpRequest(message);\\n    }, 'http_send');\\n  }\\n\\n  private async sendHttpRequest(message: DevPipeMessage): Promise<DevPipeResponse> {\\n    return new Promise((resolve, reject) => {\\n      const timeoutHandle = setTimeout(() => {\\n        this.pendingRequests.delete(message.id!);\\n        reject(new Error(`Request timeout after ${this.config.timeout}ms`));\\n      }, this.config.timeout);\\n\\n      const request: PendingRequest = {\\n        id: message.id!,\\n        message,\\n        resolve: (response) => {\\n          clearTimeout(timeoutHandle);\\n          this.pendingRequests.delete(message.id!);\\n          resolve(response);\\n        },\\n        reject: (error) => {\\n          clearTimeout(timeoutHandle);\\n          this.pendingRequests.delete(message.id!);\\n          reject(error);\\n        },\\n        timeout: timeoutHandle,\\n        timestamp: Date.now()\\n      };\\n\\n      this.pendingRequests.set(message.id!, request);\\n      this.performHttpRequest(message, request);\\n    });\\n  }\\n\\n  private async performHttpRequest(message: DevPipeMessage, request: PendingRequest): Promise<void> {\\n    try {\\n      const response = await this.connectionPool.acquire(async () => {\\n        const fetchResponse = await fetch(`${this.config.serverUrl}/api/v1/devpipe/message`, {\\n          method: 'POST',\\n          headers: {\\n            'Content-Type': 'application/json',\\n            ...(this.httpConfig.compression && { 'Accept-Encoding': 'gzip, deflate' })\\n          },\\n          body: JSON.stringify(message)\\n        });\\n\\n        if (!fetchResponse.ok) {\\n          throw new Error(`HTTP ${fetchResponse.status}: ${fetchResponse.statusText}`);\\n        }\\n\\n        return fetchResponse.json();\\n      });\\n\\n      // Handle immediate response\\n      if (response && response.id === message.id) {\\n        const devPipeResponse: DevPipeResponse = {\\n          id: response.id,\\n          success: true,\\n          payload: response.payload || response,\\n          timestamp: Date.now()\\n        };\\n        request.resolve(devPipeResponse);\\n      } else {\\n        // Wait for async response via SSE or polling\\n        this.debug(`Waiting for async response for message ${message.id}`);\\n      }\\n\\n    } catch (error) {\\n      request.reject(error instanceof Error ? error : new Error('HTTP request failed'));\\n    }\\n  }\\n\\n  private async setupSSE(): Promise<void> {\\n    if (!this.config.serverUrl) {\\n      throw new Error('Server URL required for SSE');\\n    }\\n\\n    return new Promise((resolve, reject) => {\\n      const sseUrl = `${this.config.serverUrl}/api/v1/devpipe/stream`;\\n      this.sseConnection = new EventSource(sseUrl);\\n      \\n      this.sseConnection.onopen = () => {\\n        this.debug('SSE connection established');\\n        resolve();\\n      };\\n\\n      this.sseConnection.onmessage = (event) => {\\n        try {\\n          const data = JSON.parse(event.data);\\n          this.handleSSEMessage(data);\\n        } catch (error) {\\n          this.debug('Failed to parse SSE message:', error);\\n        }\\n      };\\n\\n      this.sseConnection.onerror = (error) => {\\n        this.debug('SSE connection error:', error);\\n        if (this.sseConnection?.readyState === EventSource.CONNECTING) {\\n          this.emit(TransportEvent.RECONNECTING, { transport: this.type });\\n        } else {\\n          this.emit(TransportEvent.ERROR, error);\\n          reject(error);\\n        }\\n      };\\n    });\\n  }\\n\\n  private handleSSEMessage(data: any): void {\\n    if (data.type === 'response' && data.id) {\\n      // Handle response to pending request\\n      const request = this.pendingRequests.get(data.id);\\n      if (request) {\\n        const response: DevPipeResponse = {\\n          id: data.id,\\n          success: data.success !== false,\\n          payload: data.payload,\\n          error: data.error,\\n          timestamp: Date.now()\\n        };\\n        request.resolve(response);\\n      }\\n    } else {\\n      // Handle incoming message\\n      this.emit(TransportEvent.MESSAGE, data);\\n    }\\n  }\\n\\n  protected async doHealthCheck(): Promise<void> {\\n    if (!this.config.serverUrl) {\\n      throw new Error('No server URL configured');\\n    }\\n\\n    const response = await fetch(`${this.config.serverUrl}/api/v1/devpipe/health`, {\\n      method: 'GET',\\n      headers: { 'Content-Type': 'application/json' },\\n      signal: AbortSignal.timeout(5000)\\n    });\\n\\n    if (!response.ok) {\\n      throw new Error(`Health check failed: ${response.status} ${response.statusText}`);\\n    }\\n  }\\n\\n  getCapabilities(): TransportCapabilities {\\n    return {\\n      supportsRealtime: !!this.httpConfig.enableSSE,\\n      supportsBidirectional: !!this.httpConfig.enableSSE,\\n      supportsFileSystem: false,\\n      supportsStreaming: true,\\n      maxMessageSize: 10 * 1024 * 1024, // 10MB\\n      averageLatency: this.healthStatus.latency,\\n      maxConcurrentConnections: this.httpConfig.maxConnections || 10,\\n      reliability: this.calculateReliability(),\\n      supportedEnvironments: ['browser', 'node', 'obsidian']\\n    };\\n  }\\n}\\n\"]}"}
