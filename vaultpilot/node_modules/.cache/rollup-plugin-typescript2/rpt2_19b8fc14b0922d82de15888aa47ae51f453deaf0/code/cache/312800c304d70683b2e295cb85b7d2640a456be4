{"code":"/**\n * RecommendationEngine - AI-powered optimization suggestions and insights\n */\nimport { __awaiter } from \"tslib\";\nimport { TransportType } from '../devpipe/transports/DevPipeTransport';\nexport var RecommendationType;\n(function (RecommendationType) {\n    RecommendationType[\"TRANSPORT_OPTIMIZATION\"] = \"transport_optimization\";\n    RecommendationType[\"PERFORMANCE_TUNING\"] = \"performance_tuning\";\n    RecommendationType[\"ERROR_REDUCTION\"] = \"error_reduction\";\n    RecommendationType[\"COST_OPTIMIZATION\"] = \"cost_optimization\";\n    RecommendationType[\"FEATURE_ADOPTION\"] = \"feature_adoption\";\n    RecommendationType[\"CONFIGURATION_IMPROVEMENT\"] = \"configuration_improvement\";\n    RecommendationType[\"PROACTIVE_MAINTENANCE\"] = \"proactive_maintenance\";\n})(RecommendationType || (RecommendationType = {}));\nexport class RecommendationEngine {\n    constructor() {\n        this.performanceHistory = [];\n        this.behaviorPatterns = new Map();\n        this.appliedRecommendations = new Map();\n        this.insightCache = new Map();\n        this.predictionModels = new Map();\n        this.ANALYSIS_WINDOW = 7 * 24 * 60 * 60 * 1000; // 7 days\n        this.MIN_DATA_POINTS = 10;\n        this.CONFIDENCE_THRESHOLD = 0.7;\n        this.initializePredictionModels();\n    }\n    /**\n     * Generate comprehensive recommendations based on current context\n     */\n    generateRecommendations(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const recommendations = [];\n            try {\n                // Analyze current performance and identify opportunities\n                const opportunities = yield this.analyzeOptimizationOpportunities(context);\n                // Generate transport-specific recommendations\n                const transportRecs = yield this.generateTransportRecommendations(context, opportunities);\n                recommendations.push(...transportRecs);\n                // Generate performance tuning recommendations\n                const performanceRecs = yield this.generatePerformanceRecommendations(context, opportunities);\n                recommendations.push(...performanceRecs);\n                // Generate configuration recommendations\n                const configRecs = yield this.generateConfigurationRecommendations(context);\n                recommendations.push(...configRecs);\n                // Generate proactive maintenance recommendations\n                const maintenanceRecs = yield this.generateMaintenanceRecommendations(context);\n                recommendations.push(...maintenanceRecs);\n                // Sort by priority and expected impact\n                const sortedRecommendations = this.prioritizeRecommendations(recommendations);\n                // Cache recommendations for tracking\n                sortedRecommendations.forEach(rec => {\n                    this.appliedRecommendations.set(rec.id, rec);\n                });\n                return sortedRecommendations;\n            }\n            catch (error) {\n                console.error('Failed to generate recommendations:', error);\n                return [];\n            }\n        });\n    }\n    /**\n     * Analyze current state to identify optimization opportunities\n     */\n    analyzeOptimizationOpportunities(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const opportunities = [];\n            // Analyze transport performance\n            if (context.performanceMetrics.errorRate > 0.05) {\n                opportunities.push({\n                    area: 'transport',\n                    impact: 'high',\n                    effort: 'medium',\n                    description: 'High error rate detected, transport optimization recommended',\n                    metrics: {\n                        currentValue: context.performanceMetrics.errorRate,\n                        potentialValue: 0.01,\n                        improvement: (context.performanceMetrics.errorRate - 0.01) / context.performanceMetrics.errorRate\n                    }\n                });\n            }\n            // Analyze latency issues\n            if (context.performanceMetrics.averageLatency > 500) {\n                opportunities.push({\n                    area: 'configuration',\n                    impact: 'medium',\n                    effort: 'low',\n                    description: 'High latency detected, configuration tuning recommended',\n                    metrics: {\n                        currentValue: context.performanceMetrics.averageLatency,\n                        potentialValue: 200,\n                        improvement: (context.performanceMetrics.averageLatency - 200) / context.performanceMetrics.averageLatency\n                    }\n                });\n            }\n            // Analyze transport usage patterns\n            const transportDistribution = Object.values(context.performanceMetrics.transportUsage);\n            const maxUsage = Math.max(...transportDistribution);\n            const minUsage = Math.min(...transportDistribution);\n            if (maxUsage / (minUsage || 0.001) > 10) {\n                opportunities.push({\n                    area: 'usage',\n                    impact: 'medium',\n                    effort: 'low',\n                    description: 'Unbalanced transport usage detected, load balancing recommended',\n                    metrics: {\n                        currentValue: maxUsage / (minUsage || 0.001),\n                        potentialValue: 3,\n                        improvement: 0.3\n                    }\n                });\n            }\n            return opportunities;\n        });\n    }\n    /**\n     * Generate transport-specific recommendations\n     */\n    generateTransportRecommendations(context, opportunities) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const recommendations = [];\n            // Check if current transport is optimal\n            const optimalTransport = yield this.determineOptimalTransport(context);\n            if (optimalTransport !== context.currentTransport) {\n                recommendations.push({\n                    id: `transport-switch-${Date.now()}`,\n                    type: RecommendationType.TRANSPORT_OPTIMIZATION,\n                    priority: 'high',\n                    title: `Switch to ${optimalTransport} Transport`,\n                    description: `Based on your usage patterns and environment, ${optimalTransport} transport would provide better performance.`,\n                    rationale: this.generateTransportSwitchRationale(context, optimalTransport),\n                    expectedImpact: {\n                        performanceImprovement: 25,\n                        errorReduction: 40,\n                        reliabilityImprovement: 30,\n                        confidenceScore: 0.85\n                    },\n                    implementation: {\n                        difficulty: 'easy',\n                        estimatedTime: '1 minute',\n                        steps: [\n                            {\n                                id: 'switch-transport',\n                                title: 'Switch Primary Transport',\n                                description: `Change primary transport to ${optimalTransport}`,\n                                action: 'automatic'\n                            }\n                        ],\n                        reversible: true,\n                        riskLevel: 'low'\n                    },\n                    category: 'Transport',\n                    tags: ['performance', 'optimization', 'transport'],\n                    created: new Date()\n                });\n            }\n            // Check for transport fallback improvements\n            if (context.performanceMetrics.errorRate > 0.02) {\n                recommendations.push({\n                    id: `fallback-optimization-${Date.now()}`,\n                    type: RecommendationType.TRANSPORT_OPTIMIZATION,\n                    priority: 'medium',\n                    title: 'Optimize Transport Fallback Chain',\n                    description: 'Configure intelligent fallback to reduce error impact.',\n                    rationale: 'Current error rate suggests fallback mechanisms could be improved.',\n                    expectedImpact: {\n                        performanceImprovement: 15,\n                        errorReduction: 60,\n                        reliabilityImprovement: 45,\n                        confidenceScore: 0.75\n                    },\n                    implementation: {\n                        difficulty: 'medium',\n                        estimatedTime: '5 minutes',\n                        steps: [\n                            {\n                                id: 'configure-fallback',\n                                title: 'Configure Fallback Chain',\n                                description: 'Set up intelligent transport fallback',\n                                action: 'manual'\n                            }\n                        ],\n                        reversible: true,\n                        riskLevel: 'low'\n                    },\n                    category: 'Reliability',\n                    tags: ['fallback', 'reliability', 'error-reduction'],\n                    created: new Date()\n                });\n            }\n            return recommendations;\n        });\n    }\n    /**\n     * Generate performance tuning recommendations\n     */\n    generatePerformanceRecommendations(context, opportunities) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const recommendations = [];\n            // Check for timeout optimization\n            if (context.performanceMetrics.averageLatency > 1000) {\n                recommendations.push({\n                    id: `timeout-optimization-${Date.now()}`,\n                    type: RecommendationType.PERFORMANCE_TUNING,\n                    priority: 'medium',\n                    title: 'Optimize Request Timeouts',\n                    description: 'Adjust timeout settings to reduce wait times for failed requests.',\n                    rationale: 'High average latency indicates timeout settings may need adjustment.',\n                    expectedImpact: {\n                        performanceImprovement: 20,\n                        errorReduction: 10,\n                        reliabilityImprovement: 15,\n                        confidenceScore: 0.8\n                    },\n                    implementation: {\n                        difficulty: 'easy',\n                        estimatedTime: '2 minutes',\n                        steps: [\n                            {\n                                id: 'adjust-timeouts',\n                                title: 'Adjust Timeout Settings',\n                                description: 'Optimize request timeout values',\n                                action: 'manual'\n                            }\n                        ],\n                        reversible: true,\n                        riskLevel: 'low'\n                    },\n                    category: 'Performance',\n                    tags: ['timeout', 'latency', 'performance'],\n                    created: new Date()\n                });\n            }\n            // Check for connection pooling opportunities\n            if (context.performanceMetrics.throughput < 100) {\n                recommendations.push({\n                    id: `connection-pooling-${Date.now()}`,\n                    type: RecommendationType.PERFORMANCE_TUNING,\n                    priority: 'high',\n                    title: 'Enable Connection Pooling',\n                    description: 'Enable connection pooling to improve throughput and reduce connection overhead.',\n                    rationale: 'Low throughput suggests connection pooling could provide significant benefits.',\n                    expectedImpact: {\n                        performanceImprovement: 40,\n                        errorReduction: 20,\n                        reliabilityImprovement: 25,\n                        confidenceScore: 0.9\n                    },\n                    implementation: {\n                        difficulty: 'medium',\n                        estimatedTime: '3 minutes',\n                        steps: [\n                            {\n                                id: 'enable-pooling',\n                                title: 'Enable Connection Pooling',\n                                description: 'Configure HTTP connection pooling',\n                                action: 'automatic'\n                            }\n                        ],\n                        reversible: true,\n                        riskLevel: 'low'\n                    },\n                    category: 'Performance',\n                    tags: ['connection-pooling', 'throughput', 'performance'],\n                    created: new Date()\n                });\n            }\n            return recommendations;\n        });\n    }\n    /**\n     * Generate configuration recommendations\n     */\n    generateConfigurationRecommendations(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const recommendations = [];\n            // Check for retry configuration\n            if (context.performanceMetrics.errorRate > 0.03) {\n                recommendations.push({\n                    id: `retry-config-${Date.now()}`,\n                    type: RecommendationType.CONFIGURATION_IMPROVEMENT,\n                    priority: 'medium',\n                    title: 'Optimize Retry Configuration',\n                    description: 'Fine-tune retry attempts and backoff strategy to handle transient errors better.',\n                    rationale: 'Error rate suggests retry configuration could be optimized.',\n                    expectedImpact: {\n                        performanceImprovement: 10,\n                        errorReduction: 35,\n                        reliabilityImprovement: 40,\n                        confidenceScore: 0.75\n                    },\n                    implementation: {\n                        difficulty: 'medium',\n                        estimatedTime: '5 minutes',\n                        steps: [\n                            {\n                                id: 'configure-retry',\n                                title: 'Configure Retry Strategy',\n                                description: 'Set up exponential backoff retry strategy',\n                                action: 'manual'\n                            }\n                        ],\n                        reversible: true,\n                        riskLevel: 'low'\n                    },\n                    category: 'Configuration',\n                    tags: ['retry', 'error-handling', 'reliability'],\n                    created: new Date()\n                });\n            }\n            return recommendations;\n        });\n    }\n    /**\n     * Generate proactive maintenance recommendations\n     */\n    generateMaintenanceRecommendations(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const recommendations = [];\n            // Check for health monitoring optimization\n            const healthMonitoringRecommendation = {\n                id: `health-monitoring-${Date.now()}`,\n                type: RecommendationType.PROACTIVE_MAINTENANCE,\n                priority: 'low',\n                title: 'Enhance Health Monitoring',\n                description: 'Set up comprehensive health monitoring to detect issues early.',\n                rationale: 'Proactive monitoring can prevent issues before they impact users.',\n                expectedImpact: {\n                    performanceImprovement: 5,\n                    errorReduction: 25,\n                    reliabilityImprovement: 35,\n                    confidenceScore: 0.8\n                },\n                implementation: {\n                    difficulty: 'easy',\n                    estimatedTime: '2 minutes',\n                    steps: [\n                        {\n                            id: 'enable-monitoring',\n                            title: 'Enable Enhanced Monitoring',\n                            description: 'Turn on comprehensive health monitoring',\n                            action: 'automatic'\n                        }\n                    ],\n                    reversible: true,\n                    riskLevel: 'low'\n                },\n                category: 'Maintenance',\n                tags: ['monitoring', 'proactive', 'health'],\n                created: new Date()\n            };\n            recommendations.push(healthMonitoringRecommendation);\n            return recommendations;\n        });\n    }\n    /**\n     * Determine optimal transport based on context\n     */\n    determineOptimalTransport(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const environment = context.environmentContext;\n            const behavior = context.userBehavior;\n            // Score each available transport\n            const scores = {};\n            for (const transport of context.availableTransports) {\n                let score = 0;\n                switch (transport) {\n                    case TransportType.WEBSOCKET:\n                        // WebSocket is great for real-time, low latency needs\n                        score += environment.connectivity === 'excellent' ? 40 : 20;\n                        score += environment.latency < 50 ? 30 : 10;\n                        score += behavior.performanceSensitivity === 'high' ? 20 : 10;\n                        score += behavior.usageFrequency === 'high' ? 10 : 0;\n                        break;\n                    case TransportType.HTTP:\n                        // HTTP is reliable and widely compatible\n                        score += 30; // Base reliability score\n                        score += environment.connectivity === 'poor' ? 20 : 10;\n                        score += behavior.errorTolerance === 'low' ? 20 : 10;\n                        score += 15; // Wide compatibility bonus\n                        break;\n                    case TransportType.FILESYSTEM:\n                        // FileSystem is good for offline scenarios\n                        score += environment.connectivity === 'poor' ? 40 : 5;\n                        score += behavior.usageFrequency === 'low' ? 20 : 0;\n                        score += 10; // Offline capability bonus\n                        break;\n                }\n                scores[transport] = score;\n            }\n            // Return transport with highest score\n            return Object.entries(scores).reduce((a, b) => scores[a[0]] > scores[b[0]] ? a : b)[0];\n        });\n    }\n    /**\n     * Generate rationale for transport switch recommendation\n     */\n    generateTransportSwitchRationale(context, recommendedTransport) {\n        const current = context.currentTransport;\n        const env = context.environmentContext;\n        let rationale = `Switching from ${current} to ${recommendedTransport} is recommended because: `;\n        switch (recommendedTransport) {\n            case TransportType.WEBSOCKET:\n                rationale += 'WebSocket provides real-time communication with lower latency, ';\n                if (env.connectivity === 'excellent') {\n                    rationale += 'and your excellent connectivity supports stable WebSocket connections.';\n                }\n                else {\n                    rationale += 'which would benefit your usage patterns.';\n                }\n                break;\n            case TransportType.HTTP:\n                rationale += 'HTTP offers superior reliability and error handling, ';\n                if (context.performanceMetrics.errorRate > 0.05) {\n                    rationale += 'which is especially important given your current error rate.';\n                }\n                else {\n                    rationale += 'providing a more stable foundation for your usage.';\n                }\n                break;\n            case TransportType.FILESYSTEM:\n                rationale += 'FileSystem transport provides offline capability and local storage benefits, ';\n                if (env.connectivity === 'poor') {\n                    rationale += 'which is ideal for your current connectivity situation.';\n                }\n                else {\n                    rationale += 'offering better performance for your usage patterns.';\n                }\n                break;\n        }\n        return rationale;\n    }\n    /**\n     * Prioritize recommendations by impact and feasibility\n     */\n    prioritizeRecommendations(recommendations) {\n        return recommendations.sort((a, b) => {\n            // First, sort by priority\n            const priorityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };\n            const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];\n            if (priorityDiff !== 0)\n                return priorityDiff;\n            // Then by expected impact score (combination of performance and confidence)\n            const impactA = a.expectedImpact.performanceImprovement * a.expectedImpact.confidenceScore;\n            const impactB = b.expectedImpact.performanceImprovement * b.expectedImpact.confidenceScore;\n            return impactB - impactA;\n        });\n    }\n    /**\n     * Generate insights from current performance data\n     */\n    generateInsights(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const cacheKey = this.generateInsightCacheKey(context);\n            // Check cache first\n            if (this.insightCache.has(cacheKey)) {\n                const cached = this.insightCache.get(cacheKey);\n                // Return cached insights if less than 10 minutes old\n                if (Date.now() - ((_c = (_b = (_a = cached[0]) === null || _a === void 0 ? void 0 : _a.insights[0]) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.timestamp) < 10 * 60 * 1000) {\n                    return cached;\n                }\n            }\n            const insights = [];\n            // Performance insights\n            const performanceInsights = yield this.generatePerformanceInsights(context);\n            insights.push({\n                name: 'Performance',\n                description: 'Current performance analysis and trends',\n                priority: 1,\n                insights: performanceInsights\n            });\n            // Usage insights\n            const usageInsights = yield this.generateUsageInsights(context);\n            insights.push({\n                name: 'Usage Patterns',\n                description: 'Analysis of your usage patterns and behavior',\n                priority: 2,\n                insights: usageInsights\n            });\n            // Transport insights\n            const transportInsights = yield this.generateTransportInsights(context);\n            insights.push({\n                name: 'Transport Analysis',\n                description: 'Transport performance and optimization opportunities',\n                priority: 3,\n                insights: transportInsights\n            });\n            // Cache insights\n            this.insightCache.set(cacheKey, insights);\n            return insights;\n        });\n    }\n    /**\n     * Generate performance-related insights\n     */\n    generatePerformanceInsights(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const insights = [];\n            const metrics = context.performanceMetrics;\n            // Latency insight\n            if (metrics.averageLatency < 200) {\n                insights.push({\n                    id: 'low-latency',\n                    title: 'Excellent Response Time',\n                    description: `Your average response time of ${metrics.averageLatency}ms is excellent.`,\n                    type: 'positive',\n                    confidence: 0.9,\n                    data: { latency: metrics.averageLatency, timestamp: Date.now() },\n                    actionable: false,\n                    related: []\n                });\n            }\n            else if (metrics.averageLatency > 500) {\n                insights.push({\n                    id: 'high-latency',\n                    title: 'High Response Time Detected',\n                    description: `Your average response time of ${metrics.averageLatency}ms could be improved.`,\n                    type: 'warning',\n                    confidence: 0.85,\n                    data: { latency: metrics.averageLatency, timestamp: Date.now() },\n                    actionable: true,\n                    related: []\n                });\n            }\n            // Error rate insight\n            if (metrics.errorRate < 0.01) {\n                insights.push({\n                    id: 'low-error-rate',\n                    title: 'Low Error Rate',\n                    description: `Your error rate of ${(metrics.errorRate * 100).toFixed(2)}% is very good.`,\n                    type: 'positive',\n                    confidence: 0.9,\n                    data: { errorRate: metrics.errorRate, timestamp: Date.now() },\n                    actionable: false,\n                    related: []\n                });\n            }\n            else if (metrics.errorRate > 0.05) {\n                insights.push({\n                    id: 'high-error-rate',\n                    title: 'High Error Rate',\n                    description: `Your error rate of ${(metrics.errorRate * 100).toFixed(2)}% needs attention.`,\n                    type: 'critical',\n                    confidence: 0.95,\n                    data: { errorRate: metrics.errorRate, timestamp: Date.now() },\n                    actionable: true,\n                    related: []\n                });\n            }\n            return insights;\n        });\n    }\n    /**\n     * Generate usage pattern insights\n     */\n    generateUsageInsights(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const insights = [];\n            const behavior = context.userBehavior;\n            // Usage frequency insight\n            insights.push({\n                id: 'usage-frequency',\n                title: 'Usage Pattern Analysis',\n                description: `Your usage frequency is ${behavior.usageFrequency}. ${this.getUsageFrequencyAdvice(behavior.usageFrequency)}`,\n                type: 'neutral',\n                confidence: 0.8,\n                data: { frequency: behavior.usageFrequency, timestamp: Date.now() },\n                actionable: behavior.usageFrequency !== 'medium',\n                related: []\n            });\n            // Peak usage insight\n            if (behavior.peakUsageHours.length > 0) {\n                insights.push({\n                    id: 'peak-usage',\n                    title: 'Peak Usage Hours',\n                    description: `Your peak usage occurs during hours: ${behavior.peakUsageHours.join(', ')}. Consider optimizing for these times.`,\n                    type: 'neutral',\n                    confidence: 0.7,\n                    data: { peakHours: behavior.peakUsageHours, timestamp: Date.now() },\n                    actionable: true,\n                    related: []\n                });\n            }\n            return insights;\n        });\n    }\n    /**\n     * Generate transport-specific insights\n     */\n    generateTransportInsights(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const insights = [];\n            const usage = context.performanceMetrics.transportUsage;\n            // Transport distribution insight\n            const totalUsage = Object.values(usage).reduce((sum, val) => sum + val, 0);\n            const dominantTransport = Object.entries(usage).reduce((a, b) => usage[a[0]] > usage[b[0]] ? a : b);\n            if (totalUsage > 0) {\n                const dominantPercentage = (usage[dominantTransport[0]] / totalUsage * 100);\n                if (dominantPercentage > 80) {\n                    insights.push({\n                        id: 'transport-concentration',\n                        title: 'Heavy Reliance on Single Transport',\n                        description: `You're using ${dominantTransport[0]} for ${dominantPercentage.toFixed(1)}% of requests. Consider load balancing.`,\n                        type: 'warning',\n                        confidence: 0.8,\n                        data: { distribution: usage, dominant: dominantTransport[0], timestamp: Date.now() },\n                        actionable: true,\n                        related: []\n                    });\n                }\n                else {\n                    insights.push({\n                        id: 'balanced-transport-usage',\n                        title: 'Good Transport Distribution',\n                        description: 'Your transport usage is well balanced across available options.',\n                        type: 'positive',\n                        confidence: 0.75,\n                        data: { distribution: usage, timestamp: Date.now() },\n                        actionable: false,\n                        related: []\n                    });\n                }\n            }\n            return insights;\n        });\n    }\n    /**\n     * Generate predictive alerts for potential issues\n     */\n    generatePredictiveAlerts(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const alerts = [];\n            // Predict performance degradation\n            const performanceTrend = this.analyzePerformanceTrend(context);\n            if (performanceTrend.declining && performanceTrend.severity > 0.7) {\n                alerts.push({\n                    id: `perf-degradation-${Date.now()}`,\n                    type: 'performance_degradation',\n                    severity: 'warning',\n                    probability: performanceTrend.severity,\n                    timeframe: '24h',\n                    description: 'Performance degradation trend detected. Response times may increase significantly.',\n                    preventiveActions: [],\n                    triggers: ['increasing_latency', 'error_rate_rise']\n                });\n            }\n            // Predict transport failure\n            if (context.performanceMetrics.errorRate > 0.1) {\n                alerts.push({\n                    id: `transport-failure-${Date.now()}`,\n                    type: 'transport_failure',\n                    severity: 'error',\n                    probability: Math.min(context.performanceMetrics.errorRate * 2, 0.9),\n                    timeframe: '1h',\n                    description: `${context.currentTransport} transport showing high error rate. Failure risk is elevated.`,\n                    preventiveActions: [],\n                    triggers: ['high_error_rate', 'connection_instability']\n                });\n            }\n            return alerts;\n        });\n    }\n    /**\n     * Analyze performance trend from historical data\n     */\n    analyzePerformanceTrend(context) {\n        // Simulate trend analysis - in real implementation, this would analyze historical data\n        const recentLatency = context.performanceMetrics.averageLatency;\n        const recentErrorRate = context.performanceMetrics.errorRate;\n        // Simple heuristic for trend analysis\n        const latencyScore = Math.min(recentLatency / 1000, 1); // Normalize to 0-1\n        const errorScore = Math.min(recentErrorRate * 10, 1); // Normalize to 0-1\n        const severity = (latencyScore + errorScore) / 2;\n        return {\n            declining: severity > 0.5,\n            severity: severity\n        };\n    }\n    /**\n     * Get advice based on usage frequency\n     */\n    getUsageFrequencyAdvice(frequency) {\n        switch (frequency) {\n            case 'low':\n                return 'Consider using FileSystem transport for better offline capability.';\n            case 'high':\n                return 'WebSocket transport might provide better performance for your intensive usage.';\n            default:\n                return 'Your current configuration should work well for your usage patterns.';\n        }\n    }\n    /**\n     * Generate cache key for insights\n     */\n    generateInsightCacheKey(context) {\n        return `insights-${context.sessionId}-${context.currentTransport}-${Math.floor(Date.now() / (10 * 60 * 1000))}`;\n    }\n    /**\n     * Initialize prediction models (placeholder for future ML models)\n     */\n    initializePredictionModels() {\n        // Placeholder for future machine learning model initialization\n        this.predictionModels.set('performance_trend', {\n            type: 'linear_regression',\n            features: ['latency', 'error_rate', 'throughput'],\n            trained: false\n        });\n        this.predictionModels.set('failure_prediction', {\n            type: 'classification',\n            features: ['error_rate', 'latency_variance', 'connection_failures'],\n            trained: false\n        });\n    }\n    /**\n     * Track recommendation effectiveness (called after implementation)\n     */\n    trackRecommendationEffectiveness(recommendationId, effectiveness) {\n        const recommendation = this.appliedRecommendations.get(recommendationId);\n        if (recommendation) {\n            recommendation.effectiveness = effectiveness;\n            recommendation.appliedAt = new Date();\n            // Update prediction models based on feedback (future enhancement)\n            console.log(`Recommendation ${recommendationId} effectiveness: ${effectiveness}`);\n        }\n    }\n    /**\n     * Get recommendation statistics\n     */\n    getRecommendationStats() {\n        const applied = Array.from(this.appliedRecommendations.values()).filter(r => r.appliedAt);\n        const effectiveness = applied.filter(r => r.effectiveness !== undefined);\n        const byType = {};\n        applied.forEach(rec => {\n            byType[rec.type] = (byType[rec.type] || 0) + 1;\n        });\n        return {\n            total: this.appliedRecommendations.size,\n            applied: applied.length,\n            averageEffectiveness: effectiveness.length > 0\n                ? effectiveness.reduce((sum, r) => sum + (r.effectiveness || 0), 0) / effectiveness.length\n                : 0,\n            byType\n        };\n    }\n}\n//# sourceMappingURL=RecommendationEngine.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/DevPipeTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/utils/EnvironmentDetector.ts"],"map":"{\"version\":3,\"file\":\"RecommendationEngine.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/services/RecommendationEngine.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * RecommendationEngine - AI-powered optimization suggestions and insights\\n */\\n\\nimport { TransportType } from '../devpipe/transports/DevPipeTransport';\\nimport { EnvironmentDetector } from '../utils/EnvironmentDetector';\\n\\nexport interface RecommendationContext {\\n  userId?: string;\\n  sessionId: string;\\n  timestamp: Date;\\n  currentTransport: TransportType;\\n  availableTransports: TransportType[];\\n  performanceMetrics: PerformanceSnapshot;\\n  userBehavior: UserBehaviorPattern;\\n  environmentContext: EnvironmentContext;\\n}\\n\\nexport interface PerformanceSnapshot {\\n  averageLatency: number;\\n  errorRate: number;\\n  throughput: number;\\n  reliability: number;\\n  transportUsage: Record<TransportType, number>;\\n  timeWindow: string; // e.g., '1h', '24h', '7d'\\n}\\n\\nexport interface UserBehaviorPattern {\\n  usageFrequency: 'low' | 'medium' | 'high';\\n  peakUsageHours: number[];\\n  preferredFeatures: string[];\\n  errorTolerance: 'low' | 'medium' | 'high';\\n  performanceSensitivity: 'low' | 'medium' | 'high';\\n}\\n\\nexport interface EnvironmentContext {\\n  platform: string;\\n  connectivity: 'poor' | 'fair' | 'good' | 'excellent';\\n  bandwidth: number; // Mbps\\n  latency: number; // ms\\n  stability: number; // 0-1\\n}\\n\\nexport enum RecommendationType {\\n  TRANSPORT_OPTIMIZATION = 'transport_optimization',\\n  PERFORMANCE_TUNING = 'performance_tuning',\\n  ERROR_REDUCTION = 'error_reduction',\\n  COST_OPTIMIZATION = 'cost_optimization',\\n  FEATURE_ADOPTION = 'feature_adoption',\\n  CONFIGURATION_IMPROVEMENT = 'configuration_improvement',\\n  PROACTIVE_MAINTENANCE = 'proactive_maintenance'\\n}\\n\\nexport interface Recommendation {\\n  id: string;\\n  type: RecommendationType;\\n  priority: 'low' | 'medium' | 'high' | 'critical';\\n  title: string;\\n  description: string;\\n  rationale: string;\\n  \\n  // Expected impact\\n  expectedImpact: {\\n    performanceImprovement: number; // percentage\\n    errorReduction: number; // percentage\\n    reliabilityImprovement: number; // percentage\\n    confidenceScore: number; // 0-1\\n  };\\n  \\n  // Implementation details\\n  implementation: {\\n    difficulty: 'easy' | 'medium' | 'hard';\\n    estimatedTime: string;\\n    steps: RecommendationStep[];\\n    reversible: boolean;\\n    riskLevel: 'low' | 'medium' | 'high';\\n  };\\n  \\n  // Metadata\\n  category: string;\\n  tags: string[];\\n  created: Date;\\n  validUntil?: Date;\\n  appliedAt?: Date;\\n  effectiveness?: number; // post-implementation feedback\\n}\\n\\nexport interface RecommendationStep {\\n  id: string;\\n  title: string;\\n  description: string;\\n  action: 'manual' | 'automatic';\\n  command?: string;\\n  validation?: string;\\n  dependencies?: string[];\\n}\\n\\nexport interface OptimizationOpportunity {\\n  area: 'transport' | 'configuration' | 'usage' | 'environment';\\n  impact: 'low' | 'medium' | 'high';\\n  effort: 'low' | 'medium' | 'high';\\n  description: string;\\n  metrics: {\\n    currentValue: number;\\n    potentialValue: number;\\n    improvement: number;\\n  };\\n}\\n\\nexport interface InsightCategory {\\n  name: string;\\n  description: string;\\n  priority: number;\\n  insights: Insight[];\\n}\\n\\nexport interface Insight {\\n  id: string;\\n  title: string;\\n  description: string;\\n  type: 'positive' | 'neutral' | 'warning' | 'critical';\\n  confidence: number; // 0-1\\n  data: any;\\n  actionable: boolean;\\n  related: string[]; // related recommendation IDs\\n}\\n\\nexport interface PredictiveAlert {\\n  id: string;\\n  type: 'performance_degradation' | 'transport_failure' | 'capacity_limit' | 'maintenance_required';\\n  severity: 'info' | 'warning' | 'error' | 'critical';\\n  probability: number; // 0-1\\n  timeframe: string; // e.g., '1h', '24h', '1w'\\n  description: string;\\n  preventiveActions: Recommendation[];\\n  triggers: string[];\\n}\\n\\nexport class RecommendationEngine {\\n  private performanceHistory: PerformanceSnapshot[] = [];\\n  private behaviorPatterns: Map<string, UserBehaviorPattern> = new Map();\\n  private appliedRecommendations: Map<string, Recommendation> = new Map();\\n  private insightCache: Map<string, InsightCategory[]> = new Map();\\n  private predictionModels: Map<string, any> = new Map();\\n\\n  private readonly ANALYSIS_WINDOW = 7 * 24 * 60 * 60 * 1000; // 7 days\\n  private readonly MIN_DATA_POINTS = 10;\\n  private readonly CONFIDENCE_THRESHOLD = 0.7;\\n\\n  constructor() {\\n    this.initializePredictionModels();\\n  }\\n\\n  /**\\n   * Generate comprehensive recommendations based on current context\\n   */\\n  async generateRecommendations(context: RecommendationContext): Promise<Recommendation[]> {\\n    const recommendations: Recommendation[] = [];\\n\\n    try {\\n      // Analyze current performance and identify opportunities\\n      const opportunities = await this.analyzeOptimizationOpportunities(context);\\n      \\n      // Generate transport-specific recommendations\\n      const transportRecs = await this.generateTransportRecommendations(context, opportunities);\\n      recommendations.push(...transportRecs);\\n\\n      // Generate performance tuning recommendations\\n      const performanceRecs = await this.generatePerformanceRecommendations(context, opportunities);\\n      recommendations.push(...performanceRecs);\\n\\n      // Generate configuration recommendations\\n      const configRecs = await this.generateConfigurationRecommendations(context);\\n      recommendations.push(...configRecs);\\n\\n      // Generate proactive maintenance recommendations\\n      const maintenanceRecs = await this.generateMaintenanceRecommendations(context);\\n      recommendations.push(...maintenanceRecs);\\n\\n      // Sort by priority and expected impact\\n      const sortedRecommendations = this.prioritizeRecommendations(recommendations);\\n\\n      // Cache recommendations for tracking\\n      sortedRecommendations.forEach(rec => {\\n        this.appliedRecommendations.set(rec.id, rec);\\n      });\\n\\n      return sortedRecommendations;\\n    } catch (error) {\\n      console.error('Failed to generate recommendations:', error);\\n      return [];\\n    }\\n  }\\n\\n  /**\\n   * Analyze current state to identify optimization opportunities\\n   */\\n  private async analyzeOptimizationOpportunities(context: RecommendationContext): Promise<OptimizationOpportunity[]> {\\n    const opportunities: OptimizationOpportunity[] = [];\\n\\n    // Analyze transport performance\\n    if (context.performanceMetrics.errorRate > 0.05) {\\n      opportunities.push({\\n        area: 'transport',\\n        impact: 'high',\\n        effort: 'medium',\\n        description: 'High error rate detected, transport optimization recommended',\\n        metrics: {\\n          currentValue: context.performanceMetrics.errorRate,\\n          potentialValue: 0.01,\\n          improvement: (context.performanceMetrics.errorRate - 0.01) / context.performanceMetrics.errorRate\\n        }\\n      });\\n    }\\n\\n    // Analyze latency issues\\n    if (context.performanceMetrics.averageLatency > 500) {\\n      opportunities.push({\\n        area: 'configuration',\\n        impact: 'medium',\\n        effort: 'low',\\n        description: 'High latency detected, configuration tuning recommended',\\n        metrics: {\\n          currentValue: context.performanceMetrics.averageLatency,\\n          potentialValue: 200,\\n          improvement: (context.performanceMetrics.averageLatency - 200) / context.performanceMetrics.averageLatency\\n        }\\n      });\\n    }\\n\\n    // Analyze transport usage patterns\\n    const transportDistribution = Object.values(context.performanceMetrics.transportUsage);\\n    const maxUsage = Math.max(...transportDistribution);\\n    const minUsage = Math.min(...transportDistribution);\\n    \\n    if (maxUsage / (minUsage || 0.001) > 10) {\\n      opportunities.push({\\n        area: 'usage',\\n        impact: 'medium',\\n        effort: 'low',\\n        description: 'Unbalanced transport usage detected, load balancing recommended',\\n        metrics: {\\n          currentValue: maxUsage / (minUsage || 0.001),\\n          potentialValue: 3,\\n          improvement: 0.3\\n        }\\n      });\\n    }\\n\\n    return opportunities;\\n  }\\n\\n  /**\\n   * Generate transport-specific recommendations\\n   */\\n  private async generateTransportRecommendations(\\n    context: RecommendationContext,\\n    opportunities: OptimizationOpportunity[]\\n  ): Promise<Recommendation[]> {\\n    const recommendations: Recommendation[] = [];\\n\\n    // Check if current transport is optimal\\n    const optimalTransport = await this.determineOptimalTransport(context);\\n    if (optimalTransport !== context.currentTransport) {\\n      recommendations.push({\\n        id: `transport-switch-${Date.now()}`,\\n        type: RecommendationType.TRANSPORT_OPTIMIZATION,\\n        priority: 'high',\\n        title: `Switch to ${optimalTransport} Transport`,\\n        description: `Based on your usage patterns and environment, ${optimalTransport} transport would provide better performance.`,\\n        rationale: this.generateTransportSwitchRationale(context, optimalTransport),\\n        expectedImpact: {\\n          performanceImprovement: 25,\\n          errorReduction: 40,\\n          reliabilityImprovement: 30,\\n          confidenceScore: 0.85\\n        },\\n        implementation: {\\n          difficulty: 'easy',\\n          estimatedTime: '1 minute',\\n          steps: [\\n            {\\n              id: 'switch-transport',\\n              title: 'Switch Primary Transport',\\n              description: `Change primary transport to ${optimalTransport}`,\\n              action: 'automatic'\\n            }\\n          ],\\n          reversible: true,\\n          riskLevel: 'low'\\n        },\\n        category: 'Transport',\\n        tags: ['performance', 'optimization', 'transport'],\\n        created: new Date()\\n      });\\n    }\\n\\n    // Check for transport fallback improvements\\n    if (context.performanceMetrics.errorRate > 0.02) {\\n      recommendations.push({\\n        id: `fallback-optimization-${Date.now()}`,\\n        type: RecommendationType.TRANSPORT_OPTIMIZATION,\\n        priority: 'medium',\\n        title: 'Optimize Transport Fallback Chain',\\n        description: 'Configure intelligent fallback to reduce error impact.',\\n        rationale: 'Current error rate suggests fallback mechanisms could be improved.',\\n        expectedImpact: {\\n          performanceImprovement: 15,\\n          errorReduction: 60,\\n          reliabilityImprovement: 45,\\n          confidenceScore: 0.75\\n        },\\n        implementation: {\\n          difficulty: 'medium',\\n          estimatedTime: '5 minutes',\\n          steps: [\\n            {\\n              id: 'configure-fallback',\\n              title: 'Configure Fallback Chain',\\n              description: 'Set up intelligent transport fallback',\\n              action: 'manual'\\n            }\\n          ],\\n          reversible: true,\\n          riskLevel: 'low'\\n        },\\n        category: 'Reliability',\\n        tags: ['fallback', 'reliability', 'error-reduction'],\\n        created: new Date()\\n      });\\n    }\\n\\n    return recommendations;\\n  }\\n\\n  /**\\n   * Generate performance tuning recommendations\\n   */\\n  private async generatePerformanceRecommendations(\\n    context: RecommendationContext,\\n    opportunities: OptimizationOpportunity[]\\n  ): Promise<Recommendation[]> {\\n    const recommendations: Recommendation[] = [];\\n\\n    // Check for timeout optimization\\n    if (context.performanceMetrics.averageLatency > 1000) {\\n      recommendations.push({\\n        id: `timeout-optimization-${Date.now()}`,\\n        type: RecommendationType.PERFORMANCE_TUNING,\\n        priority: 'medium',\\n        title: 'Optimize Request Timeouts',\\n        description: 'Adjust timeout settings to reduce wait times for failed requests.',\\n        rationale: 'High average latency indicates timeout settings may need adjustment.',\\n        expectedImpact: {\\n          performanceImprovement: 20,\\n          errorReduction: 10,\\n          reliabilityImprovement: 15,\\n          confidenceScore: 0.8\\n        },\\n        implementation: {\\n          difficulty: 'easy',\\n          estimatedTime: '2 minutes',\\n          steps: [\\n            {\\n              id: 'adjust-timeouts',\\n              title: 'Adjust Timeout Settings',\\n              description: 'Optimize request timeout values',\\n              action: 'manual'\\n            }\\n          ],\\n          reversible: true,\\n          riskLevel: 'low'\\n        },\\n        category: 'Performance',\\n        tags: ['timeout', 'latency', 'performance'],\\n        created: new Date()\\n      });\\n    }\\n\\n    // Check for connection pooling opportunities\\n    if (context.performanceMetrics.throughput < 100) {\\n      recommendations.push({\\n        id: `connection-pooling-${Date.now()}`,\\n        type: RecommendationType.PERFORMANCE_TUNING,\\n        priority: 'high',\\n        title: 'Enable Connection Pooling',\\n        description: 'Enable connection pooling to improve throughput and reduce connection overhead.',\\n        rationale: 'Low throughput suggests connection pooling could provide significant benefits.',\\n        expectedImpact: {\\n          performanceImprovement: 40,\\n          errorReduction: 20,\\n          reliabilityImprovement: 25,\\n          confidenceScore: 0.9\\n        },\\n        implementation: {\\n          difficulty: 'medium',\\n          estimatedTime: '3 minutes',\\n          steps: [\\n            {\\n              id: 'enable-pooling',\\n              title: 'Enable Connection Pooling',\\n              description: 'Configure HTTP connection pooling',\\n              action: 'automatic'\\n            }\\n          ],\\n          reversible: true,\\n          riskLevel: 'low'\\n        },\\n        category: 'Performance',\\n        tags: ['connection-pooling', 'throughput', 'performance'],\\n        created: new Date()\\n      });\\n    }\\n\\n    return recommendations;\\n  }\\n\\n  /**\\n   * Generate configuration recommendations\\n   */\\n  private async generateConfigurationRecommendations(context: RecommendationContext): Promise<Recommendation[]> {\\n    const recommendations: Recommendation[] = [];\\n\\n    // Check for retry configuration\\n    if (context.performanceMetrics.errorRate > 0.03) {\\n      recommendations.push({\\n        id: `retry-config-${Date.now()}`,\\n        type: RecommendationType.CONFIGURATION_IMPROVEMENT,\\n        priority: 'medium',\\n        title: 'Optimize Retry Configuration',\\n        description: 'Fine-tune retry attempts and backoff strategy to handle transient errors better.',\\n        rationale: 'Error rate suggests retry configuration could be optimized.',\\n        expectedImpact: {\\n          performanceImprovement: 10,\\n          errorReduction: 35,\\n          reliabilityImprovement: 40,\\n          confidenceScore: 0.75\\n        },\\n        implementation: {\\n          difficulty: 'medium',\\n          estimatedTime: '5 minutes',\\n          steps: [\\n            {\\n              id: 'configure-retry',\\n              title: 'Configure Retry Strategy',\\n              description: 'Set up exponential backoff retry strategy',\\n              action: 'manual'\\n            }\\n          ],\\n          reversible: true,\\n          riskLevel: 'low'\\n        },\\n        category: 'Configuration',\\n        tags: ['retry', 'error-handling', 'reliability'],\\n        created: new Date()\\n      });\\n    }\\n\\n    return recommendations;\\n  }\\n\\n  /**\\n   * Generate proactive maintenance recommendations\\n   */\\n  private async generateMaintenanceRecommendations(context: RecommendationContext): Promise<Recommendation[]> {\\n    const recommendations: Recommendation[] = [];\\n\\n    // Check for health monitoring optimization\\n    const healthMonitoringRecommendation: Recommendation = {\\n      id: `health-monitoring-${Date.now()}`,\\n      type: RecommendationType.PROACTIVE_MAINTENANCE,\\n      priority: 'low',\\n      title: 'Enhance Health Monitoring',\\n      description: 'Set up comprehensive health monitoring to detect issues early.',\\n      rationale: 'Proactive monitoring can prevent issues before they impact users.',\\n      expectedImpact: {\\n        performanceImprovement: 5,\\n        errorReduction: 25,\\n        reliabilityImprovement: 35,\\n        confidenceScore: 0.8\\n      },\\n      implementation: {\\n        difficulty: 'easy',\\n        estimatedTime: '2 minutes',\\n        steps: [\\n          {\\n            id: 'enable-monitoring',\\n            title: 'Enable Enhanced Monitoring',\\n            description: 'Turn on comprehensive health monitoring',\\n            action: 'automatic'\\n          }\\n        ],\\n        reversible: true,\\n        riskLevel: 'low'\\n      },\\n      category: 'Maintenance',\\n      tags: ['monitoring', 'proactive', 'health'],\\n      created: new Date()\\n    };\\n\\n    recommendations.push(healthMonitoringRecommendation);\\n\\n    return recommendations;\\n  }\\n\\n  /**\\n   * Determine optimal transport based on context\\n   */\\n  private async determineOptimalTransport(context: RecommendationContext): Promise<TransportType> {\\n    const environment = context.environmentContext;\\n    const behavior = context.userBehavior;\\n    \\n    // Score each available transport\\n    const scores: Record<TransportType, number> = {} as Record<TransportType, number>;\\n    \\n    for (const transport of context.availableTransports) {\\n      let score = 0;\\n      \\n      switch (transport) {\\n        case TransportType.WEBSOCKET:\\n          // WebSocket is great for real-time, low latency needs\\n          score += environment.connectivity === 'excellent' ? 40 : 20;\\n          score += environment.latency < 50 ? 30 : 10;\\n          score += behavior.performanceSensitivity === 'high' ? 20 : 10;\\n          score += behavior.usageFrequency === 'high' ? 10 : 0;\\n          break;\\n          \\n        case TransportType.HTTP:\\n          // HTTP is reliable and widely compatible\\n          score += 30; // Base reliability score\\n          score += environment.connectivity === 'poor' ? 20 : 10;\\n          score += behavior.errorTolerance === 'low' ? 20 : 10;\\n          score += 15; // Wide compatibility bonus\\n          break;\\n          \\n        case TransportType.FILESYSTEM:\\n          // FileSystem is good for offline scenarios\\n          score += environment.connectivity === 'poor' ? 40 : 5;\\n          score += behavior.usageFrequency === 'low' ? 20 : 0;\\n          score += 10; // Offline capability bonus\\n          break;\\n      }\\n      \\n      scores[transport] = score;\\n    }\\n    \\n    // Return transport with highest score\\n    return Object.entries(scores).reduce((a, b) => scores[a[0] as TransportType] > scores[b[0] as TransportType] ? a : b)[0] as TransportType;\\n  }\\n\\n  /**\\n   * Generate rationale for transport switch recommendation\\n   */\\n  private generateTransportSwitchRationale(context: RecommendationContext, recommendedTransport: TransportType): string {\\n    const current = context.currentTransport;\\n    const env = context.environmentContext;\\n    \\n    let rationale = `Switching from ${current} to ${recommendedTransport} is recommended because: `;\\n    \\n    switch (recommendedTransport) {\\n      case TransportType.WEBSOCKET:\\n        rationale += 'WebSocket provides real-time communication with lower latency, ';\\n        if (env.connectivity === 'excellent') {\\n          rationale += 'and your excellent connectivity supports stable WebSocket connections.';\\n        } else {\\n          rationale += 'which would benefit your usage patterns.';\\n        }\\n        break;\\n        \\n      case TransportType.HTTP:\\n        rationale += 'HTTP offers superior reliability and error handling, ';\\n        if (context.performanceMetrics.errorRate > 0.05) {\\n          rationale += 'which is especially important given your current error rate.';\\n        } else {\\n          rationale += 'providing a more stable foundation for your usage.';\\n        }\\n        break;\\n        \\n      case TransportType.FILESYSTEM:\\n        rationale += 'FileSystem transport provides offline capability and local storage benefits, ';\\n        if (env.connectivity === 'poor') {\\n          rationale += 'which is ideal for your current connectivity situation.';\\n        } else {\\n          rationale += 'offering better performance for your usage patterns.';\\n        }\\n        break;\\n    }\\n    \\n    return rationale;\\n  }\\n\\n  /**\\n   * Prioritize recommendations by impact and feasibility\\n   */\\n  private prioritizeRecommendations(recommendations: Recommendation[]): Recommendation[] {\\n    return recommendations.sort((a, b) => {\\n      // First, sort by priority\\n      const priorityOrder = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };\\n      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];\\n      if (priorityDiff !== 0) return priorityDiff;\\n      \\n      // Then by expected impact score (combination of performance and confidence)\\n      const impactA = a.expectedImpact.performanceImprovement * a.expectedImpact.confidenceScore;\\n      const impactB = b.expectedImpact.performanceImprovement * b.expectedImpact.confidenceScore;\\n      return impactB - impactA;\\n    });\\n  }\\n\\n  /**\\n   * Generate insights from current performance data\\n   */\\n  async generateInsights(context: RecommendationContext): Promise<InsightCategory[]> {\\n    const cacheKey = this.generateInsightCacheKey(context);\\n    \\n    // Check cache first\\n    if (this.insightCache.has(cacheKey)) {\\n      const cached = this.insightCache.get(cacheKey)!;\\n      // Return cached insights if less than 10 minutes old\\n      if (Date.now() - cached[0]?.insights[0]?.data?.timestamp < 10 * 60 * 1000) {\\n        return cached;\\n      }\\n    }\\n    \\n    const insights: InsightCategory[] = [];\\n    \\n    // Performance insights\\n    const performanceInsights = await this.generatePerformanceInsights(context);\\n    insights.push({\\n      name: 'Performance',\\n      description: 'Current performance analysis and trends',\\n      priority: 1,\\n      insights: performanceInsights\\n    });\\n    \\n    // Usage insights\\n    const usageInsights = await this.generateUsageInsights(context);\\n    insights.push({\\n      name: 'Usage Patterns',\\n      description: 'Analysis of your usage patterns and behavior',\\n      priority: 2,\\n      insights: usageInsights\\n    });\\n    \\n    // Transport insights\\n    const transportInsights = await this.generateTransportInsights(context);\\n    insights.push({\\n      name: 'Transport Analysis',\\n      description: 'Transport performance and optimization opportunities',\\n      priority: 3,\\n      insights: transportInsights\\n    });\\n    \\n    // Cache insights\\n    this.insightCache.set(cacheKey, insights);\\n    \\n    return insights;\\n  }\\n\\n  /**\\n   * Generate performance-related insights\\n   */\\n  private async generatePerformanceInsights(context: RecommendationContext): Promise<Insight[]> {\\n    const insights: Insight[] = [];\\n    const metrics = context.performanceMetrics;\\n    \\n    // Latency insight\\n    if (metrics.averageLatency < 200) {\\n      insights.push({\\n        id: 'low-latency',\\n        title: 'Excellent Response Time',\\n        description: `Your average response time of ${metrics.averageLatency}ms is excellent.`,\\n        type: 'positive',\\n        confidence: 0.9,\\n        data: { latency: metrics.averageLatency, timestamp: Date.now() },\\n        actionable: false,\\n        related: []\\n      });\\n    } else if (metrics.averageLatency > 500) {\\n      insights.push({\\n        id: 'high-latency',\\n        title: 'High Response Time Detected',\\n        description: `Your average response time of ${metrics.averageLatency}ms could be improved.`,\\n        type: 'warning',\\n        confidence: 0.85,\\n        data: { latency: metrics.averageLatency, timestamp: Date.now() },\\n        actionable: true,\\n        related: []\\n      });\\n    }\\n    \\n    // Error rate insight\\n    if (metrics.errorRate < 0.01) {\\n      insights.push({\\n        id: 'low-error-rate',\\n        title: 'Low Error Rate',\\n        description: `Your error rate of ${(metrics.errorRate * 100).toFixed(2)}% is very good.`,\\n        type: 'positive',\\n        confidence: 0.9,\\n        data: { errorRate: metrics.errorRate, timestamp: Date.now() },\\n        actionable: false,\\n        related: []\\n      });\\n    } else if (metrics.errorRate > 0.05) {\\n      insights.push({\\n        id: 'high-error-rate',\\n        title: 'High Error Rate',\\n        description: `Your error rate of ${(metrics.errorRate * 100).toFixed(2)}% needs attention.`,\\n        type: 'critical',\\n        confidence: 0.95,\\n        data: { errorRate: metrics.errorRate, timestamp: Date.now() },\\n        actionable: true,\\n        related: []\\n      });\\n    }\\n    \\n    return insights;\\n  }\\n\\n  /**\\n   * Generate usage pattern insights\\n   */\\n  private async generateUsageInsights(context: RecommendationContext): Promise<Insight[]> {\\n    const insights: Insight[] = [];\\n    const behavior = context.userBehavior;\\n    \\n    // Usage frequency insight\\n    insights.push({\\n      id: 'usage-frequency',\\n      title: 'Usage Pattern Analysis',\\n      description: `Your usage frequency is ${behavior.usageFrequency}. ${this.getUsageFrequencyAdvice(behavior.usageFrequency)}`,\\n      type: 'neutral',\\n      confidence: 0.8,\\n      data: { frequency: behavior.usageFrequency, timestamp: Date.now() },\\n      actionable: behavior.usageFrequency !== 'medium',\\n      related: []\\n    });\\n    \\n    // Peak usage insight\\n    if (behavior.peakUsageHours.length > 0) {\\n      insights.push({\\n        id: 'peak-usage',\\n        title: 'Peak Usage Hours',\\n        description: `Your peak usage occurs during hours: ${behavior.peakUsageHours.join(', ')}. Consider optimizing for these times.`,\\n        type: 'neutral',\\n        confidence: 0.7,\\n        data: { peakHours: behavior.peakUsageHours, timestamp: Date.now() },\\n        actionable: true,\\n        related: []\\n      });\\n    }\\n    \\n    return insights;\\n  }\\n\\n  /**\\n   * Generate transport-specific insights\\n   */\\n  private async generateTransportInsights(context: RecommendationContext): Promise<Insight[]> {\\n    const insights: Insight[] = [];\\n    const usage = context.performanceMetrics.transportUsage;\\n    \\n    // Transport distribution insight\\n    const totalUsage = Object.values(usage).reduce((sum, val) => sum + val, 0);\\n    const dominantTransport = Object.entries(usage).reduce((a, b) => usage[a[0] as TransportType] > usage[b[0] as TransportType] ? a : b);\\n    \\n    if (totalUsage > 0) {\\n      const dominantPercentage = (usage[dominantTransport[0] as TransportType] / totalUsage * 100);\\n      \\n      if (dominantPercentage > 80) {\\n        insights.push({\\n          id: 'transport-concentration',\\n          title: 'Heavy Reliance on Single Transport',\\n          description: `You're using ${dominantTransport[0]} for ${dominantPercentage.toFixed(1)}% of requests. Consider load balancing.`,\\n          type: 'warning',\\n          confidence: 0.8,\\n          data: { distribution: usage, dominant: dominantTransport[0], timestamp: Date.now() },\\n          actionable: true,\\n          related: []\\n        });\\n      } else {\\n        insights.push({\\n          id: 'balanced-transport-usage',\\n          title: 'Good Transport Distribution',\\n          description: 'Your transport usage is well balanced across available options.',\\n          type: 'positive',\\n          confidence: 0.75,\\n          data: { distribution: usage, timestamp: Date.now() },\\n          actionable: false,\\n          related: []\\n        });\\n      }\\n    }\\n    \\n    return insights;\\n  }\\n\\n  /**\\n   * Generate predictive alerts for potential issues\\n   */\\n  async generatePredictiveAlerts(context: RecommendationContext): Promise<PredictiveAlert[]> {\\n    const alerts: PredictiveAlert[] = [];\\n    \\n    // Predict performance degradation\\n    const performanceTrend = this.analyzePerformanceTrend(context);\\n    if (performanceTrend.declining && performanceTrend.severity > 0.7) {\\n      alerts.push({\\n        id: `perf-degradation-${Date.now()}`,\\n        type: 'performance_degradation',\\n        severity: 'warning',\\n        probability: performanceTrend.severity,\\n        timeframe: '24h',\\n        description: 'Performance degradation trend detected. Response times may increase significantly.',\\n        preventiveActions: [],\\n        triggers: ['increasing_latency', 'error_rate_rise']\\n      });\\n    }\\n    \\n    // Predict transport failure\\n    if (context.performanceMetrics.errorRate > 0.1) {\\n      alerts.push({\\n        id: `transport-failure-${Date.now()}`,\\n        type: 'transport_failure',\\n        severity: 'error',\\n        probability: Math.min(context.performanceMetrics.errorRate * 2, 0.9),\\n        timeframe: '1h',\\n        description: `${context.currentTransport} transport showing high error rate. Failure risk is elevated.`,\\n        preventiveActions: [],\\n        triggers: ['high_error_rate', 'connection_instability']\\n      });\\n    }\\n    \\n    return alerts;\\n  }\\n\\n  /**\\n   * Analyze performance trend from historical data\\n   */\\n  private analyzePerformanceTrend(context: RecommendationContext): { declining: boolean; severity: number } {\\n    // Simulate trend analysis - in real implementation, this would analyze historical data\\n    const recentLatency = context.performanceMetrics.averageLatency;\\n    const recentErrorRate = context.performanceMetrics.errorRate;\\n    \\n    // Simple heuristic for trend analysis\\n    const latencyScore = Math.min(recentLatency / 1000, 1); // Normalize to 0-1\\n    const errorScore = Math.min(recentErrorRate * 10, 1); // Normalize to 0-1\\n    \\n    const severity = (latencyScore + errorScore) / 2;\\n    \\n    return {\\n      declining: severity > 0.5,\\n      severity: severity\\n    };\\n  }\\n\\n  /**\\n   * Get advice based on usage frequency\\n   */\\n  private getUsageFrequencyAdvice(frequency: string): string {\\n    switch (frequency) {\\n      case 'low':\\n        return 'Consider using FileSystem transport for better offline capability.';\\n      case 'high':\\n        return 'WebSocket transport might provide better performance for your intensive usage.';\\n      default:\\n        return 'Your current configuration should work well for your usage patterns.';\\n    }\\n  }\\n\\n  /**\\n   * Generate cache key for insights\\n   */\\n  private generateInsightCacheKey(context: RecommendationContext): string {\\n    return `insights-${context.sessionId}-${context.currentTransport}-${Math.floor(Date.now() / (10 * 60 * 1000))}`;\\n  }\\n\\n  /**\\n   * Initialize prediction models (placeholder for future ML models)\\n   */\\n  private initializePredictionModels(): void {\\n    // Placeholder for future machine learning model initialization\\n    this.predictionModels.set('performance_trend', {\\n      type: 'linear_regression',\\n      features: ['latency', 'error_rate', 'throughput'],\\n      trained: false\\n    });\\n    \\n    this.predictionModels.set('failure_prediction', {\\n      type: 'classification',\\n      features: ['error_rate', 'latency_variance', 'connection_failures'],\\n      trained: false\\n    });\\n  }\\n\\n  /**\\n   * Track recommendation effectiveness (called after implementation)\\n   */\\n  trackRecommendationEffectiveness(recommendationId: string, effectiveness: number): void {\\n    const recommendation = this.appliedRecommendations.get(recommendationId);\\n    if (recommendation) {\\n      recommendation.effectiveness = effectiveness;\\n      recommendation.appliedAt = new Date();\\n      \\n      // Update prediction models based on feedback (future enhancement)\\n      console.log(`Recommendation ${recommendationId} effectiveness: ${effectiveness}`);\\n    }\\n  }\\n\\n  /**\\n   * Get recommendation statistics\\n   */\\n  getRecommendationStats(): {\\n    total: number;\\n    applied: number;\\n    averageEffectiveness: number;\\n    byType: Record<RecommendationType, number>;\\n  } {\\n    const applied = Array.from(this.appliedRecommendations.values()).filter(r => r.appliedAt);\\n    const effectiveness = applied.filter(r => r.effectiveness !== undefined);\\n    \\n    const byType: Record<RecommendationType, number> = {} as Record<RecommendationType, number>;\\n    applied.forEach(rec => {\\n      byType[rec.type] = (byType[rec.type] || 0) + 1;\\n    });\\n    \\n    return {\\n      total: this.appliedRecommendations.size,\\n      applied: applied.length,\\n      averageEffectiveness: effectiveness.length > 0 \\n        ? effectiveness.reduce((sum, r) => sum + (r.effectiveness || 0), 0) / effectiveness.length \\n        : 0,\\n      byType\\n    };\\n  }\\n}\\n\"]}"}
