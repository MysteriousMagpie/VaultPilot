{"code":"import { __awaiter } from \"tslib\";\nimport { EnvironmentDetector } from '../utils/EnvironmentDetector';\nexport class DevPipeClient {\n    constructor(config) {\n        this.isConnected = false;\n        this.messageId = 1;\n        this.pendingRequests = new Map();\n        this.eventListeners = new Map();\n        this.config = config;\n        this.environment = EnvironmentDetector.detect(); // Initialize environment\n        this.serverUrl = config.server_url;\n        if (this.config.debug_mode) {\n            console.log('DevPipe Environment:', this.environment);\n        }\n    }\n    // Event system implementation\n    on(event, listener) {\n        if (!this.eventListeners.has(event)) {\n            this.eventListeners.set(event, []);\n        }\n        this.eventListeners.get(event).push(listener);\n    }\n    off(event, listener) {\n        const listeners = this.eventListeners.get(event);\n        if (listeners) {\n            const index = listeners.indexOf(listener);\n            if (index > -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    emit(event, data) {\n        const listeners = this.eventListeners.get(event);\n        if (listeners) {\n            listeners.forEach(listener => listener(data));\n        }\n    }\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Validate environment compatibility\n                if (!this.environment.hasHTTP) {\n                    throw new Error('HTTP transport not available in this environment');\n                }\n                // Test connection with environment-specific method\n                yield this.testConnection();\n                this.isConnected = true;\n                this.emit('connected', {\n                    status: 'connected',\n                    environment: this.environment.platform,\n                    transport: 'http'\n                });\n                if (this.config.debug_mode) {\n                    console.log('DevPipe client initialized successfully');\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw new Error(`Failed to initialize DevPipe client: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        });\n    }\n    testConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(`${this.serverUrl}/api/v1/devpipe/health`, {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' },\n                signal: AbortSignal.timeout(5000) // 5 second timeout\n            });\n            if (!response.ok) {\n                throw new Error(`DevPipe server not accessible: ${response.status} ${response.statusText}`);\n            }\n        });\n    }\n    sendMessage(type_1, payload_1) {\n        return __awaiter(this, arguments, void 0, function* (type, payload, timeout = 30000) {\n            if (!this.isConnected) {\n                throw new Error('DevPipe client not connected');\n            }\n            const messageId = this.generateMessageId();\n            const message = {\n                id: messageId,\n                timestamp: new Date().toISOString(),\n                type,\n                payload,\n                sender: 'vaultpilot-plugin',\n                recipient: 'evoagentx-backend',\n                priority: 'normal'\n            };\n            return new Promise((resolve, reject) => {\n                const timeoutHandle = window.setTimeout(() => {\n                    this.pendingRequests.delete(messageId);\n                    reject(new Error(`Request timeout after ${timeout}ms`));\n                }, timeout);\n                this.pendingRequests.set(messageId, {\n                    resolve,\n                    reject,\n                    timeout: timeoutHandle\n                });\n                this.sendMessageToServer(message).catch(error => {\n                    this.pendingRequests.delete(messageId);\n                    window.clearTimeout(timeoutHandle);\n                    reject(error);\n                });\n            });\n        });\n    }\n    sendMessageToServer(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield fetch(`${this.serverUrl}/api/v1/devpipe/message`, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify(message)\n                });\n                if (!response.ok) {\n                    throw new Error(`DevPipe server error: ${response.status}`);\n                }\n                const result = yield response.json();\n                // Handle immediate response\n                if (result.response && result.response.id === message.id) {\n                    const pendingRequest = this.pendingRequests.get(message.id);\n                    if (pendingRequest) {\n                        window.clearTimeout(pendingRequest.timeout);\n                        this.pendingRequests.delete(message.id);\n                        pendingRequest.resolve(result.response.payload);\n                    }\n                }\n                if (this.config.debug_mode) {\n                    console.log('DevPipe message sent successfully:', message.type);\n                }\n                return result;\n            }\n            catch (error) {\n                if (this.config.debug_mode) {\n                    console.error('Error sending DevPipe message:', error);\n                }\n                throw error;\n            }\n        });\n    }\n    generateMessageId() {\n        return `msg_${Date.now()}_${this.messageId++}`;\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Reject all pending requests\n            for (const [id, request] of this.pendingRequests) {\n                window.clearTimeout(request.timeout);\n                request.reject(new Error('DevPipe client disconnected'));\n            }\n            this.pendingRequests.clear();\n            this.isConnected = false;\n            this.emit('disconnected', { status: 'disconnected' });\n        });\n    }\n    isReady() {\n        return this.isConnected;\n    }\n    getPendingRequestCount() {\n        return this.pendingRequests.size;\n    }\n}\n//# sourceMappingURL=DevPipeClient.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/types/ModelSelection.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/utils/EnvironmentDetector.ts"],"map":"{\"version\":3,\"file\":\"DevPipeClient.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/devpipe/DevPipeClient.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import { DevPipeMessage, DevPipeMessageType, ModelSelectionConfig } from '../types/ModelSelection';\\nimport { EnvironmentDetector, EnvironmentInfo } from '../utils/EnvironmentDetector';\\n\\ninterface EventListener {\\n  (data: any): void;\\n}\\n\\nexport class DevPipeClient {\\n  private serverUrl: string;\\n  private isConnected: boolean = false;\\n  private messageId: number = 1;\\n  private pendingRequests: Map<string, { resolve: Function; reject: Function; timeout: number }> = new Map();\\n  private config: ModelSelectionConfig;\\n  private eventListeners: Map<string, EventListener[]> = new Map();\\n  private environment: EnvironmentInfo;  // Add environment property\\n\\n  constructor(config: ModelSelectionConfig) {\\n    this.config = config;\\n    this.environment = EnvironmentDetector.detect();  // Initialize environment\\n    this.serverUrl = config.server_url;\\n    if (this.config.debug_mode) {\\n      console.log('DevPipe Environment:', this.environment);\\n    }\\n  }\\n\\n  // Event system implementation\\n  on(event: string, listener: EventListener): void {\\n    if (!this.eventListeners.has(event)) {\\n      this.eventListeners.set(event, []);\\n    }\\n    this.eventListeners.get(event)!.push(listener);\\n  }\\n\\n  off(event: string, listener: EventListener): void {\\n    const listeners = this.eventListeners.get(event);\\n    if (listeners) {\\n      const index = listeners.indexOf(listener);\\n      if (index > -1) {\\n        listeners.splice(index, 1);\\n      }\\n    }\\n  }\\n\\n  private emit(event: string, data: any): void {\\n    const listeners = this.eventListeners.get(event);\\n    if (listeners) {\\n      listeners.forEach(listener => listener(data));\\n    }\\n  }\\n\\n  async initialize(): Promise<void> {\\n    try {\\n      // Validate environment compatibility\\n      if (!this.environment.hasHTTP) {\\n        throw new Error('HTTP transport not available in this environment');\\n      }\\n\\n      // Test connection with environment-specific method\\n      await this.testConnection();\\n      \\n      this.isConnected = true;\\n      this.emit('connected', { \\n        status: 'connected',\\n        environment: this.environment.platform,\\n        transport: 'http'\\n      });\\n      \\n      if (this.config.debug_mode) {\\n        console.log('DevPipe client initialized successfully');\\n      }\\n    } catch (error) {\\n      this.emit('error', error);\\n      throw new Error(`Failed to initialize DevPipe client: ${error instanceof Error ? error.message : 'Unknown error'}`);\\n    }\\n  }\\n\\n  private async testConnection(): Promise<void> {\\n    const response = await fetch(`${this.serverUrl}/api/v1/devpipe/health`, {\\n      method: 'GET',\\n      headers: { 'Content-Type': 'application/json' },\\n      signal: AbortSignal.timeout(5000) // 5 second timeout\\n    });\\n\\n    if (!response.ok) {\\n      throw new Error(`DevPipe server not accessible: ${response.status} ${response.statusText}`);\\n    }\\n  }\\n\\n  async sendMessage<T>(type: DevPipeMessageType, payload: any, timeout: number = 30000): Promise<T> {\\n    if (!this.isConnected) {\\n      throw new Error('DevPipe client not connected');\\n    }\\n\\n    const messageId = this.generateMessageId();\\n    const message: DevPipeMessage = {\\n      id: messageId,\\n      timestamp: new Date().toISOString(),\\n      type,\\n      payload,\\n      sender: 'vaultpilot-plugin',\\n      recipient: 'evoagentx-backend',\\n      priority: 'normal'\\n    };\\n\\n    return new Promise<T>((resolve, reject) => {\\n      const timeoutHandle = window.setTimeout(() => {\\n        this.pendingRequests.delete(messageId);\\n        reject(new Error(`Request timeout after ${timeout}ms`));\\n      }, timeout);\\n\\n      this.pendingRequests.set(messageId, {\\n        resolve,\\n        reject,\\n        timeout: timeoutHandle\\n      });\\n\\n      this.sendMessageToServer(message).catch(error => {\\n        this.pendingRequests.delete(messageId);\\n        window.clearTimeout(timeoutHandle);\\n        reject(error);\\n      });\\n    });\\n  }\\n\\n  private async sendMessageToServer(message: DevPipeMessage): Promise<any> {\\n    try {\\n      const response = await fetch(`${this.serverUrl}/api/v1/devpipe/message`, {\\n        method: 'POST',\\n        headers: {\\n          'Content-Type': 'application/json',\\n        },\\n        body: JSON.stringify(message)\\n      });\\n\\n      if (!response.ok) {\\n        throw new Error(`DevPipe server error: ${response.status}`);\\n      }\\n\\n      const result = await response.json();\\n      \\n      // Handle immediate response\\n      if (result.response && result.response.id === message.id) {\\n        const pendingRequest = this.pendingRequests.get(message.id);\\n        if (pendingRequest) {\\n          window.clearTimeout(pendingRequest.timeout);\\n          this.pendingRequests.delete(message.id);\\n          pendingRequest.resolve(result.response.payload);\\n        }\\n      }\\n\\n      if (this.config.debug_mode) {\\n        console.log('DevPipe message sent successfully:', message.type);\\n      }\\n\\n      return result;\\n    } catch (error) {\\n      if (this.config.debug_mode) {\\n        console.error('Error sending DevPipe message:', error);\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  private generateMessageId(): string {\\n    return `msg_${Date.now()}_${this.messageId++}`;\\n  }\\n\\n  async disconnect(): Promise<void> {\\n    // Reject all pending requests\\n    for (const [id, request] of this.pendingRequests) {\\n      window.clearTimeout(request.timeout);\\n      request.reject(new Error('DevPipe client disconnected'));\\n    }\\n    this.pendingRequests.clear();\\n\\n    this.isConnected = false;\\n    this.emit('disconnected', { status: 'disconnected' });\\n  }\\n\\n  isReady(): boolean {\\n    return this.isConnected;\\n  }\\n\\n  getPendingRequestCount(): number {\\n    return this.pendingRequests.size;\\n  }\\n}\\n\"]}"}
