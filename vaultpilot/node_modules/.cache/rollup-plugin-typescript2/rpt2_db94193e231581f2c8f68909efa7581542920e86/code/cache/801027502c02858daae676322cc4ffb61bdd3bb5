{"code":"/**\n * Transport Health Monitor for monitoring transport health and performance\n */\nimport { TransportEvent } from '../transports/DevPipeTransport';\n/**\n * Collects and aggregates transport performance metrics\n */\nexport class DefaultMetricsCollector {\n    constructor() {\n        this.metrics = new Map();\n        this.latencyHistory = new Map();\n        this.MAX_HISTORY_SIZE = 100;\n    }\n    recordLatency(transport, latency) {\n        const metrics = this.getOrCreateMetrics(transport);\n        // Update latency metrics\n        const history = this.getOrCreateHistory(transport);\n        history.push(latency);\n        if (history.length > this.MAX_HISTORY_SIZE) {\n            history.shift();\n        }\n        metrics.averageLatency = history.reduce((sum, val) => sum + val, 0) / history.length;\n        metrics.minLatency = Math.min(metrics.minLatency, latency);\n        metrics.maxLatency = Math.max(metrics.maxLatency, latency);\n        metrics.lastActivity = Date.now();\n    }\n    recordSuccess(transport) {\n        const metrics = this.getOrCreateMetrics(transport);\n        metrics.totalRequests++;\n        metrics.successfulRequests++;\n        metrics.lastActivity = Date.now();\n    }\n    recordFailure(transport, error) {\n        const metrics = this.getOrCreateMetrics(transport);\n        metrics.totalRequests++;\n        metrics.failedRequests++;\n        metrics.lastActivity = Date.now();\n    }\n    getMetrics(transport) {\n        return this.getOrCreateMetrics(transport);\n    }\n    getOrCreateMetrics(transport) {\n        if (!this.metrics.has(transport)) {\n            this.metrics.set(transport, {\n                totalRequests: 0,\n                successfulRequests: 0,\n                failedRequests: 0,\n                averageLatency: 0,\n                minLatency: Infinity,\n                maxLatency: 0,\n                uptime: 0,\n                lastActivity: Date.now()\n            });\n        }\n        return this.metrics.get(transport);\n    }\n    getOrCreateHistory(transport) {\n        if (!this.latencyHistory.has(transport)) {\n            this.latencyHistory.set(transport, []);\n        }\n        return this.latencyHistory.get(transport);\n    }\n}\n/**\n * Monitors transport health and provides assessments\n */\nexport class TransportHealthMonitor {\n    constructor(metricsCollector) {\n        this.schedules = new Map();\n        this.eventListeners = new Map();\n        this.metricsCollector = metricsCollector || new DefaultMetricsCollector();\n    }\n    startMonitoring(transport, interval = 30000) {\n        const schedule = {\n            transport,\n            interval,\n            lastCheck: 0,\n            consecutiveFailures: 0\n        };\n        this.schedules.set(transport.id, schedule);\n        // Set up transport event listeners\n        transport.on(TransportEvent.HEALTH_CHECK, (result) => {\n            if (result.success) {\n                this.metricsCollector.recordLatency(transport.type, result.latency);\n                this.metricsCollector.recordSuccess(transport.type);\n                schedule.consecutiveFailures = 0;\n            }\n            else {\n                this.metricsCollector.recordFailure(transport.type, new Error(result.error || 'Health check failed'));\n                schedule.consecutiveFailures++;\n            }\n            this.emit('health-updated', this.assessTransportHealth(transport));\n        });\n        // Start periodic monitoring if not already running\n        if (!this.monitoringInterval) {\n            this.startPeriodicChecks();\n        }\n    }\n    stopMonitoring(transport) {\n        this.schedules.delete(transport.id);\n        // Stop periodic monitoring if no transports are being monitored\n        if (this.schedules.size === 0 && this.monitoringInterval) {\n            clearInterval(this.monitoringInterval);\n            this.monitoringInterval = undefined;\n        }\n    }\n    assessTransportHealth(transport) {\n        const metrics = this.metricsCollector.getMetrics(transport.type);\n        const healthStatus = transport.getHealthStatus();\n        const capabilities = transport.getCapabilities();\n        // Calculate individual metric scores (0-1)\n        const availability = this.calculateAvailabilityScore(transport);\n        const latency = this.calculateLatencyScore(healthStatus.latency);\n        const reliability = this.calculateReliabilityScore(metrics);\n        const errorRate = this.calculateErrorRateScore(metrics);\n        // Weighted overall score\n        const score = (availability * 0.3 +\n            latency * 0.25 +\n            reliability * 0.3 +\n            errorRate * 0.15);\n        // Determine status based on score\n        let status;\n        if (score >= 0.9)\n            status = 'excellent';\n        else if (score >= 0.7)\n            status = 'good';\n        else if (score >= 0.5)\n            status = 'fair';\n        else if (score >= 0.3)\n            status = 'poor';\n        else\n            status = 'failing';\n        // Determine recommendation\n        let recommendation;\n        if (score >= 0.7)\n            recommendation = 'use';\n        else if (score >= 0.4)\n            recommendation = 'monitor';\n        else\n            recommendation = 'avoid';\n        return {\n            transport: transport.type,\n            score,\n            status,\n            metrics: {\n                availability,\n                latency: latency,\n                reliability,\n                errorRate: 1 - errorRate // Invert for display (higher is better)\n            },\n            recommendation\n        };\n    }\n    calculateAvailabilityScore(transport) {\n        if (!transport.isAvailable())\n            return 0;\n        if (!transport.isConnected())\n            return 0.3;\n        const schedule = this.schedules.get(transport.id);\n        if (!schedule)\n            return 0.8; // Default if no monitoring data\n        // Penalize consecutive failures\n        const failurePenalty = Math.min(schedule.consecutiveFailures * 0.1, 0.5);\n        return Math.max(1.0 - failurePenalty, 0);\n    }\n    calculateLatencyScore(latency) {\n        // Optimal latency targets by transport type\n        const excellent = 50; // <50ms\n        const good = 200; // <200ms\n        const acceptable = 1000; // <1s\n        if (latency <= excellent)\n            return 1.0;\n        if (latency <= good)\n            return 0.8;\n        if (latency <= acceptable)\n            return 0.6;\n        return Math.max(0.2, 1.0 - (latency / 5000)); // Degrade further for very high latency\n    }\n    calculateReliabilityScore(metrics) {\n        if (metrics.totalRequests === 0)\n            return 0.5; // Unknown\n        const successRate = metrics.successfulRequests / metrics.totalRequests;\n        return successRate;\n    }\n    calculateErrorRateScore(metrics) {\n        if (metrics.totalRequests === 0)\n            return 1.0; // No errors yet\n        const errorRate = metrics.failedRequests / metrics.totalRequests;\n        return Math.max(0, 1.0 - errorRate);\n    }\n    startPeriodicChecks() {\n        this.monitoringInterval = setInterval(() => {\n            const now = Date.now();\n            const schedules = Array.from(this.schedules.values());\n            for (const schedule of schedules) {\n                if (now - schedule.lastCheck >= schedule.interval) {\n                    schedule.lastCheck = now;\n                    // Perform health check\n                    schedule.transport.performHealthCheck().catch(error => {\n                        // Error is already handled by the transport's health check event\n                    });\n                }\n            }\n        }, 5000); // Check every 5 seconds\n    }\n    // Event system\n    on(event, listener) {\n        if (!this.eventListeners.has(event)) {\n            this.eventListeners.set(event, []);\n        }\n        this.eventListeners.get(event).push(listener);\n    }\n    off(event, listener) {\n        const listeners = this.eventListeners.get(event);\n        if (listeners) {\n            const index = listeners.indexOf(listener);\n            if (index > -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    emit(event, data) {\n        const listeners = this.eventListeners.get(event);\n        if (listeners) {\n            listeners.forEach(listener => {\n                try {\n                    listener(data);\n                }\n                catch (error) {\n                    console.error(`Error in health monitor event listener for ${event}:`, error);\n                }\n            });\n        }\n    }\n    getMetricsCollector() {\n        return this.metricsCollector;\n    }\n}\n//# sourceMappingURL=TransportHealthMonitor.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/DevPipeTransport.ts"],"map":"{\"version\":3,\"file\":\"TransportHealthMonitor.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/devpipe/monitoring/TransportHealthMonitor.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * Transport Health Monitor for monitoring transport health and performance\\n */\\n\\nimport { \\n  DevPipeTransport, \\n  TransportType, \\n  TransportHealthStatus,\\n  HealthCheckResult,\\n  TransportEvent\\n} from '../transports/DevPipeTransport';\\n\\nexport interface HealthCheckSchedule {\\n  transport: DevPipeTransport;\\n  interval: number;\\n  lastCheck: number;\\n  consecutiveFailures: number;\\n}\\n\\nexport interface HealthAssessment {\\n  transport: TransportType;\\n  score: number; // 0-1, higher is better\\n  status: 'excellent' | 'good' | 'fair' | 'poor' | 'failing';\\n  metrics: {\\n    availability: number;\\n    latency: number;\\n    reliability: number;\\n    errorRate: number;\\n  };\\n  recommendation: 'use' | 'monitor' | 'avoid';\\n}\\n\\nexport interface MetricsCollector {\\n  recordLatency(transport: TransportType, latency: number): void;\\n  recordSuccess(transport: TransportType): void;\\n  recordFailure(transport: TransportType, error: Error): void;\\n  getMetrics(transport: TransportType): TransportMetrics;\\n}\\n\\nexport interface TransportMetrics {\\n  totalRequests: number;\\n  successfulRequests: number;\\n  failedRequests: number;\\n  averageLatency: number;\\n  minLatency: number;\\n  maxLatency: number;\\n  uptime: number;\\n  lastActivity: number;\\n}\\n\\n/**\\n * Collects and aggregates transport performance metrics\\n */\\nexport class DefaultMetricsCollector implements MetricsCollector {\\n  private metrics: Map<TransportType, TransportMetrics> = new Map();\\n  private latencyHistory: Map<TransportType, number[]> = new Map();\\n  private readonly MAX_HISTORY_SIZE = 100;\\n\\n  recordLatency(transport: TransportType, latency: number): void {\\n    const metrics = this.getOrCreateMetrics(transport);\\n    \\n    // Update latency metrics\\n    const history = this.getOrCreateHistory(transport);\\n    history.push(latency);\\n    if (history.length > this.MAX_HISTORY_SIZE) {\\n      history.shift();\\n    }\\n    \\n    metrics.averageLatency = history.reduce((sum, val) => sum + val, 0) / history.length;\\n    metrics.minLatency = Math.min(metrics.minLatency, latency);\\n    metrics.maxLatency = Math.max(metrics.maxLatency, latency);\\n    metrics.lastActivity = Date.now();\\n  }\\n\\n  recordSuccess(transport: TransportType): void {\\n    const metrics = this.getOrCreateMetrics(transport);\\n    metrics.totalRequests++;\\n    metrics.successfulRequests++;\\n    metrics.lastActivity = Date.now();\\n  }\\n\\n  recordFailure(transport: TransportType, error: Error): void {\\n    const metrics = this.getOrCreateMetrics(transport);\\n    metrics.totalRequests++;\\n    metrics.failedRequests++;\\n    metrics.lastActivity = Date.now();\\n  }\\n\\n  getMetrics(transport: TransportType): TransportMetrics {\\n    return this.getOrCreateMetrics(transport);\\n  }\\n\\n  private getOrCreateMetrics(transport: TransportType): TransportMetrics {\\n    if (!this.metrics.has(transport)) {\\n      this.metrics.set(transport, {\\n        totalRequests: 0,\\n        successfulRequests: 0,\\n        failedRequests: 0,\\n        averageLatency: 0,\\n        minLatency: Infinity,\\n        maxLatency: 0,\\n        uptime: 0,\\n        lastActivity: Date.now()\\n      });\\n    }\\n    return this.metrics.get(transport)!;\\n  }\\n\\n  private getOrCreateHistory(transport: TransportType): number[] {\\n    if (!this.latencyHistory.has(transport)) {\\n      this.latencyHistory.set(transport, []);\\n    }\\n    return this.latencyHistory.get(transport)!;\\n  }\\n}\\n\\n/**\\n * Monitors transport health and provides assessments\\n */\\nexport class TransportHealthMonitor {\\n  private schedules: Map<string, HealthCheckSchedule> = new Map();\\n  private metricsCollector: MetricsCollector;\\n  private monitoringInterval?: any;\\n  private eventListeners: Map<string, Function[]> = new Map();\\n\\n  constructor(metricsCollector?: MetricsCollector) {\\n    this.metricsCollector = metricsCollector || new DefaultMetricsCollector();\\n  }\\n\\n  startMonitoring(transport: DevPipeTransport, interval: number = 30000): void {\\n    const schedule: HealthCheckSchedule = {\\n      transport,\\n      interval,\\n      lastCheck: 0,\\n      consecutiveFailures: 0\\n    };\\n\\n    this.schedules.set(transport.id, schedule);\\n\\n    // Set up transport event listeners\\n    transport.on(TransportEvent.HEALTH_CHECK, (result: HealthCheckResult) => {\\n      if (result.success) {\\n        this.metricsCollector.recordLatency(transport.type, result.latency);\\n        this.metricsCollector.recordSuccess(transport.type);\\n        schedule.consecutiveFailures = 0;\\n      } else {\\n        this.metricsCollector.recordFailure(transport.type, new Error(result.error || 'Health check failed'));\\n        schedule.consecutiveFailures++;\\n      }\\n      \\n      this.emit('health-updated', this.assessTransportHealth(transport));\\n    });\\n\\n    // Start periodic monitoring if not already running\\n    if (!this.monitoringInterval) {\\n      this.startPeriodicChecks();\\n    }\\n  }\\n\\n  stopMonitoring(transport: DevPipeTransport): void {\\n    this.schedules.delete(transport.id);\\n    \\n    // Stop periodic monitoring if no transports are being monitored\\n    if (this.schedules.size === 0 && this.monitoringInterval) {\\n      clearInterval(this.monitoringInterval);\\n      this.monitoringInterval = undefined;\\n    }\\n  }\\n\\n  assessTransportHealth(transport: DevPipeTransport): HealthAssessment {\\n    const metrics = this.metricsCollector.getMetrics(transport.type);\\n    const healthStatus = transport.getHealthStatus();\\n    const capabilities = transport.getCapabilities();\\n    \\n    // Calculate individual metric scores (0-1)\\n    const availability = this.calculateAvailabilityScore(transport);\\n    const latency = this.calculateLatencyScore(healthStatus.latency);\\n    const reliability = this.calculateReliabilityScore(metrics);\\n    const errorRate = this.calculateErrorRateScore(metrics);\\n    \\n    // Weighted overall score\\n    const score = (\\n      availability * 0.3 +\\n      latency * 0.25 +\\n      reliability * 0.3 +\\n      errorRate * 0.15\\n    );\\n    \\n    // Determine status based on score\\n    let status: HealthAssessment['status'];\\n    if (score >= 0.9) status = 'excellent';\\n    else if (score >= 0.7) status = 'good';\\n    else if (score >= 0.5) status = 'fair';\\n    else if (score >= 0.3) status = 'poor';\\n    else status = 'failing';\\n    \\n    // Determine recommendation\\n    let recommendation: HealthAssessment['recommendation'];\\n    if (score >= 0.7) recommendation = 'use';\\n    else if (score >= 0.4) recommendation = 'monitor';\\n    else recommendation = 'avoid';\\n    \\n    return {\\n      transport: transport.type,\\n      score,\\n      status,\\n      metrics: {\\n        availability,\\n        latency: latency,\\n        reliability,\\n        errorRate: 1 - errorRate // Invert for display (higher is better)\\n      },\\n      recommendation\\n    };\\n  }\\n\\n  private calculateAvailabilityScore(transport: DevPipeTransport): number {\\n    if (!transport.isAvailable()) return 0;\\n    if (!transport.isConnected()) return 0.3;\\n    \\n    const schedule = this.schedules.get(transport.id);\\n    if (!schedule) return 0.8; // Default if no monitoring data\\n    \\n    // Penalize consecutive failures\\n    const failurePenalty = Math.min(schedule.consecutiveFailures * 0.1, 0.5);\\n    return Math.max(1.0 - failurePenalty, 0);\\n  }\\n\\n  private calculateLatencyScore(latency: number): number {\\n    // Optimal latency targets by transport type\\n    const excellent = 50;   // <50ms\\n    const good = 200;       // <200ms\\n    const acceptable = 1000; // <1s\\n    \\n    if (latency <= excellent) return 1.0;\\n    if (latency <= good) return 0.8;\\n    if (latency <= acceptable) return 0.6;\\n    return Math.max(0.2, 1.0 - (latency / 5000)); // Degrade further for very high latency\\n  }\\n\\n  private calculateReliabilityScore(metrics: TransportMetrics): number {\\n    if (metrics.totalRequests === 0) return 0.5; // Unknown\\n    \\n    const successRate = metrics.successfulRequests / metrics.totalRequests;\\n    return successRate;\\n  }\\n\\n  private calculateErrorRateScore(metrics: TransportMetrics): number {\\n    if (metrics.totalRequests === 0) return 1.0; // No errors yet\\n    \\n    const errorRate = metrics.failedRequests / metrics.totalRequests;\\n    return Math.max(0, 1.0 - errorRate);\\n  }\\n\\n  private startPeriodicChecks(): void {\\n    this.monitoringInterval = setInterval(() => {\\n      const now = Date.now();\\n      \\n      const schedules = Array.from(this.schedules.values());\\n      for (const schedule of schedules) {\\n        if (now - schedule.lastCheck >= schedule.interval) {\\n          schedule.lastCheck = now;\\n          \\n          // Perform health check\\n          schedule.transport.performHealthCheck().catch(error => {\\n            // Error is already handled by the transport's health check event\\n          });\\n        }\\n      }\\n    }, 5000); // Check every 5 seconds\\n  }\\n\\n  // Event system\\n  on(event: string, listener: Function): void {\\n    if (!this.eventListeners.has(event)) {\\n      this.eventListeners.set(event, []);\\n    }\\n    this.eventListeners.get(event)!.push(listener);\\n  }\\n\\n  off(event: string, listener: Function): void {\\n    const listeners = this.eventListeners.get(event);\\n    if (listeners) {\\n      const index = listeners.indexOf(listener);\\n      if (index > -1) {\\n        listeners.splice(index, 1);\\n      }\\n    }\\n  }\\n\\n  private emit(event: string, data: any): void {\\n    const listeners = this.eventListeners.get(event);\\n    if (listeners) {\\n      listeners.forEach(listener => {\\n        try {\\n          listener(data);\\n        } catch (error) {\\n          console.error(`Error in health monitor event listener for ${event}:`, error);\\n        }\\n      });\\n    }\\n  }\\n\\n  getMetricsCollector(): MetricsCollector {\\n    return this.metricsCollector;\\n  }\\n}\\n\"]}"}
