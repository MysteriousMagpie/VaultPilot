{"code":"/**\n * Base transport implementation with common functionality\n * All specific transport types extend this base class\n */\nimport { __awaiter } from \"tslib\";\nimport { TransportEvent } from './DevPipeTransport';\n/**\n * Circuit breaker pattern implementation for transport reliability\n */\nexport class CircuitBreaker {\n    constructor(config) {\n        this.state = 'closed';\n        this.failureCount = 0;\n        this.lastFailureTime = 0;\n        this.nextAttempt = 0;\n        this.config = config;\n    }\n    execute(operation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === 'open') {\n                if (Date.now() < this.nextAttempt) {\n                    throw new Error('Circuit breaker is OPEN');\n                }\n                this.state = 'half-open';\n            }\n            try {\n                const result = yield operation();\n                this.onSuccess();\n                return result;\n            }\n            catch (error) {\n                this.onFailure();\n                throw error;\n            }\n        });\n    }\n    onSuccess() {\n        this.failureCount = 0;\n        this.state = 'closed';\n    }\n    onFailure() {\n        this.failureCount++;\n        this.lastFailureTime = Date.now();\n        if (this.failureCount >= this.config.failureThreshold) {\n            this.state = 'open';\n            this.nextAttempt = Date.now() + this.config.resetTimeout;\n        }\n    }\n    getState() {\n        return this.state;\n    }\n}\n/**\n * Base transport class with common functionality\n */\nexport class BaseTransport {\n    constructor(type, config) {\n        this.eventListeners = new Map();\n        this.connected = false;\n        this.initialized = false;\n        this.type = type;\n        this.id = `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        this.config = config;\n        this.healthStatus = {\n            status: 'disconnected',\n            lastCheck: Date.now(),\n            latency: 0,\n            errorRate: 0,\n            consecutiveFailures: 0,\n            uptime: 0\n        };\n        this.circuitBreaker = new CircuitBreaker({\n            failureThreshold: 5,\n            resetTimeout: 30000,\n            monitoringPeriod: 10000\n        });\n        this.metrics = {\n            messagesSent: 0,\n            messagesReceived: 0,\n            errors: 0,\n            totalLatency: 0,\n            lastActivity: Date.now()\n        };\n        this.debug(`Transport ${this.id} created`);\n    }\n    // Event system implementation\n    on(event, listener) {\n        const eventKey = event.toString();\n        if (!this.eventListeners.has(eventKey)) {\n            this.eventListeners.set(eventKey, []);\n        }\n        this.eventListeners.get(eventKey).push(listener);\n    }\n    off(event, listener) {\n        const eventKey = event.toString();\n        const listeners = this.eventListeners.get(eventKey);\n        if (listeners) {\n            const index = listeners.indexOf(listener);\n            if (index > -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    emit(event, data) {\n        const eventKey = event.toString();\n        const listeners = this.eventListeners.get(eventKey);\n        if (listeners) {\n            listeners.forEach(listener => {\n                try {\n                    listener(data);\n                }\n                catch (error) {\n                    this.debug(`Error in event listener for ${eventKey}:`, error);\n                }\n            });\n        }\n    }\n    // Health monitoring\n    performHealthCheck() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const startTime = Date.now();\n            try {\n                yield this.doHealthCheck();\n                const latency = Date.now() - startTime;\n                this.healthStatus.status = 'healthy';\n                this.healthStatus.latency = latency;\n                this.healthStatus.consecutiveFailures = 0;\n                this.healthStatus.lastCheck = Date.now();\n                this.emit(TransportEvent.HEALTH_CHECK, { success: true, latency });\n                return { success: true, latency, timestamp: Date.now() };\n            }\n            catch (error) {\n                this.healthStatus.status = 'failing';\n                this.healthStatus.consecutiveFailures++;\n                this.healthStatus.lastCheck = Date.now();\n                const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n                this.emit(TransportEvent.HEALTH_CHECK, { success: false, error: errorMessage });\n                return { success: false, error: errorMessage, latency: Date.now() - startTime, timestamp: Date.now() };\n            }\n        });\n    }\n    // Circuit breaker wrapper for operations\n    executeWithCircuitBreaker(operation, operationName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const startTime = Date.now();\n            try {\n                const result = yield this.circuitBreaker.execute(operation);\n                const latency = Date.now() - startTime;\n                this.updateMetrics(true, latency);\n                return result;\n            }\n            catch (error) {\n                const latency = Date.now() - startTime;\n                this.updateMetrics(false, latency);\n                this.debug(`Operation ${operationName} failed:`, error);\n                throw error;\n            }\n        });\n    }\n    updateMetrics(success, latency) {\n        if (success) {\n            this.metrics.messagesSent++;\n            this.metrics.totalLatency += latency;\n        }\n        else {\n            this.metrics.errors++;\n        }\n        this.metrics.lastActivity = Date.now();\n    }\n    // Utility methods\n    generateMessageId() {\n        return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    debug(message, ...args) {\n        if (this.config.debug) {\n            console.log(`[${this.type}:${this.id}] ${message}`, ...args);\n        }\n    }\n    calculateReliability() {\n        const total = this.metrics.messagesSent + this.metrics.errors;\n        if (total === 0)\n            return 1.0;\n        return this.metrics.messagesSent / total;\n    }\n    // Standard interface implementations\n    isAvailable() {\n        return this.initialized && this.circuitBreaker.getState() !== 'open';\n    }\n    isConnected() {\n        return this.connected && this.isAvailable();\n    }\n    getHealthStatus() {\n        return Object.assign({}, this.healthStatus);\n    }\n    initialize(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.config = Object.assign(Object.assign({}, this.config), config);\n            yield this.doInitialize();\n            this.initialized = true;\n            this.debug('Transport initialized');\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.disconnect();\n            this.eventListeners.clear();\n            this.initialized = false;\n            this.debug('Transport destroyed');\n        });\n    }\n}\n//# sourceMappingURL=BaseTransport.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/DevPipeTransport.ts"],"map":"{\"version\":3,\"file\":\"BaseTransport.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/devpipe/transports/BaseTransport.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * Base transport implementation with common functionality\\n * All specific transport types extend this base class\\n */\\n\\nimport { \\n  DevPipeTransport, \\n  TransportType, \\n  TransportConfig, \\n  TransportHealthStatus, \\n  HealthCheckResult,\\n  EventListener,\\n  TransportEvent,\\n  DevPipeMessage,\\n  DevPipeResponse,\\n  TransportCapabilities\\n} from './DevPipeTransport';\\n\\nexport interface CircuitBreakerConfig {\\n  failureThreshold: number;\\n  resetTimeout: number;\\n  monitoringPeriod: number;\\n}\\n\\nexport interface TransportMetrics {\\n  messagesSent: number;\\n  messagesReceived: number;\\n  errors: number;\\n  totalLatency: number;\\n  lastActivity: number;\\n}\\n\\n/**\\n * Circuit breaker pattern implementation for transport reliability\\n */\\nexport class CircuitBreaker {\\n  private state: 'closed' | 'open' | 'half-open' = 'closed';\\n  private failureCount: number = 0;\\n  private lastFailureTime: number = 0;\\n  private nextAttempt: number = 0;\\n  private config: CircuitBreakerConfig;\\n\\n  constructor(config: CircuitBreakerConfig) {\\n    this.config = config;\\n  }\\n\\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\\n    if (this.state === 'open') {\\n      if (Date.now() < this.nextAttempt) {\\n        throw new Error('Circuit breaker is OPEN');\\n      }\\n      this.state = 'half-open';\\n    }\\n\\n    try {\\n      const result = await operation();\\n      this.onSuccess();\\n      return result;\\n    } catch (error) {\\n      this.onFailure();\\n      throw error;\\n    }\\n  }\\n\\n  private onSuccess(): void {\\n    this.failureCount = 0;\\n    this.state = 'closed';\\n  }\\n\\n  private onFailure(): void {\\n    this.failureCount++;\\n    this.lastFailureTime = Date.now();\\n\\n    if (this.failureCount >= this.config.failureThreshold) {\\n      this.state = 'open';\\n      this.nextAttempt = Date.now() + this.config.resetTimeout;\\n    }\\n  }\\n\\n  getState(): string {\\n    return this.state;\\n  }\\n}\\n\\n/**\\n * Base transport class with common functionality\\n */\\nexport abstract class BaseTransport implements DevPipeTransport {\\n  protected config: TransportConfig;\\n  protected healthStatus: TransportHealthStatus;\\n  protected circuitBreaker: CircuitBreaker;\\n  protected metrics: TransportMetrics;\\n  protected eventListeners: Map<string, EventListener[]> = new Map();\\n  \\n  public readonly type: TransportType;\\n  public readonly id: string;\\n  protected connected: boolean = false;\\n  protected initialized: boolean = false;\\n\\n  constructor(type: TransportType, config: TransportConfig) {\\n    this.type = type;\\n    this.id = `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\\n    this.config = config;\\n    \\n    this.healthStatus = {\\n      status: 'disconnected',\\n      lastCheck: Date.now(),\\n      latency: 0,\\n      errorRate: 0,\\n      consecutiveFailures: 0,\\n      uptime: 0\\n    };\\n    \\n    this.circuitBreaker = new CircuitBreaker({\\n      failureThreshold: 5,\\n      resetTimeout: 30000,\\n      monitoringPeriod: 10000\\n    });\\n    \\n    this.metrics = {\\n      messagesSent: 0,\\n      messagesReceived: 0,\\n      errors: 0,\\n      totalLatency: 0,\\n      lastActivity: Date.now()\\n    };\\n\\n    this.debug(`Transport ${this.id} created`);\\n  }\\n\\n  // Event system implementation\\n  on(event: TransportEvent | string, listener: EventListener): void {\\n    const eventKey = event.toString();\\n    if (!this.eventListeners.has(eventKey)) {\\n      this.eventListeners.set(eventKey, []);\\n    }\\n    this.eventListeners.get(eventKey)!.push(listener);\\n  }\\n\\n  off(event: TransportEvent | string, listener: EventListener): void {\\n    const eventKey = event.toString();\\n    const listeners = this.eventListeners.get(eventKey);\\n    if (listeners) {\\n      const index = listeners.indexOf(listener);\\n      if (index > -1) {\\n        listeners.splice(index, 1);\\n      }\\n    }\\n  }\\n\\n  emit(event: TransportEvent | string, data?: any): void {\\n    const eventKey = event.toString();\\n    const listeners = this.eventListeners.get(eventKey);\\n    if (listeners) {\\n      listeners.forEach(listener => {\\n        try {\\n          listener(data);\\n        } catch (error) {\\n          this.debug(`Error in event listener for ${eventKey}:`, error);\\n        }\\n      });\\n    }\\n  }\\n\\n  // Health monitoring\\n  async performHealthCheck(): Promise<HealthCheckResult> {\\n    const startTime = Date.now();\\n    try {\\n      await this.doHealthCheck();\\n      const latency = Date.now() - startTime;\\n      \\n      this.healthStatus.status = 'healthy';\\n      this.healthStatus.latency = latency;\\n      this.healthStatus.consecutiveFailures = 0;\\n      this.healthStatus.lastCheck = Date.now();\\n      \\n      this.emit(TransportEvent.HEALTH_CHECK, { success: true, latency });\\n      \\n      return { success: true, latency, timestamp: Date.now() };\\n    } catch (error) {\\n      this.healthStatus.status = 'failing';\\n      this.healthStatus.consecutiveFailures++;\\n      this.healthStatus.lastCheck = Date.now();\\n      \\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\\n      this.emit(TransportEvent.HEALTH_CHECK, { success: false, error: errorMessage });\\n      \\n      return { success: false, error: errorMessage, latency: Date.now() - startTime, timestamp: Date.now() };\\n    }\\n  }\\n\\n  // Circuit breaker wrapper for operations\\n  protected async executeWithCircuitBreaker<T>(\\n    operation: () => Promise<T>,\\n    operationName: string\\n  ): Promise<T> {\\n    const startTime = Date.now();\\n    try {\\n      const result = await this.circuitBreaker.execute(operation);\\n      const latency = Date.now() - startTime;\\n      this.updateMetrics(true, latency);\\n      return result;\\n    } catch (error) {\\n      const latency = Date.now() - startTime;\\n      this.updateMetrics(false, latency);\\n      this.debug(`Operation ${operationName} failed:`, error);\\n      throw error;\\n    }\\n  }\\n\\n  private updateMetrics(success: boolean, latency: number): void {\\n    if (success) {\\n      this.metrics.messagesSent++;\\n      this.metrics.totalLatency += latency;\\n    } else {\\n      this.metrics.errors++;\\n    }\\n    this.metrics.lastActivity = Date.now();\\n  }\\n\\n  // Utility methods\\n  protected generateMessageId(): string {\\n    return `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\\n  }\\n\\n  protected debug(message: string, ...args: any[]): void {\\n    if (this.config.debug) {\\n      console.log(`[${this.type}:${this.id}] ${message}`, ...args);\\n    }\\n  }\\n\\n  protected calculateReliability(): number {\\n    const total = this.metrics.messagesSent + this.metrics.errors;\\n    if (total === 0) return 1.0;\\n    return this.metrics.messagesSent / total;\\n  }\\n\\n  // Standard interface implementations\\n  isAvailable(): boolean {\\n    return this.initialized && this.circuitBreaker.getState() !== 'open';\\n  }\\n\\n  isConnected(): boolean {\\n    return this.connected && this.isAvailable();\\n  }\\n\\n  getHealthStatus(): TransportHealthStatus {\\n    return { ...this.healthStatus };\\n  }\\n\\n  async initialize(config: TransportConfig): Promise<void> {\\n    this.config = { ...this.config, ...config };\\n    await this.doInitialize();\\n    this.initialized = true;\\n    this.debug('Transport initialized');\\n  }\\n\\n  async destroy(): Promise<void> {\\n    await this.disconnect();\\n    this.eventListeners.clear();\\n    this.initialized = false;\\n    this.debug('Transport destroyed');\\n  }\\n\\n  // Abstract methods that must be implemented by specific transport types\\n  protected abstract doInitialize(): Promise<void>;\\n  protected abstract doHealthCheck(): Promise<void>;\\n  public abstract connect(): Promise<void>;\\n  public abstract disconnect(): Promise<void>;\\n  public abstract send(message: DevPipeMessage): Promise<DevPipeResponse>;\\n  public abstract getCapabilities(): TransportCapabilities;\\n}\\n\"]}"}
