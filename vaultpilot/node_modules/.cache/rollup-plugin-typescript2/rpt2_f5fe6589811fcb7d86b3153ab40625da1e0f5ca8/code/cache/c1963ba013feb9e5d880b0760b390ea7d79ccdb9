{"code":"import { __awaiter } from \"tslib\";\nimport { request } from 'obsidian';\n/**\n * Fetches schedule data from the planner API\n * @param noteText - The full text of the active note\n * @returns Promise with the schedule markdown and headline\n */\nexport function fetchSchedule(noteText) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const response = yield request({\n            url: 'http://localhost:3000/planday',\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ note: noteText })\n        });\n        return JSON.parse(response);\n    });\n}\n/**\n * Finds and extracts the Schedule section from note text\n * @param text - The full note text\n * @returns Match result with schedule section details or null\n */\nexport function findScheduleSection(text) {\n    // First try to match headings that are exactly \"## Schedule\" (with optional content after)\n    let scheduleRegex = /(^##\\s+Schedule\\b[^\\n]*\\n)([\\s\\S]*?)(?=\\n##\\s|$)/im;\n    let match = text.match(scheduleRegex);\n    if (match) {\n        return match;\n    }\n    // If no exact match, try to match headings that contain \"Schedule\" as a word\n    scheduleRegex = /(^##\\s*(?:.*\\s)?\\bSchedule\\b(?:\\s.*)?$\\n)([\\s\\S]*?)(?=\\n##\\s|$)/im;\n    return text.match(scheduleRegex);\n}\n/**\n * Injects or replaces the schedule section in the note text\n * @param originalText - The original note text\n * @param scheduleMarkdown - The new schedule content to inject\n * @returns Updated note text with the new schedule section\n */\nexport function injectSchedule(originalText, scheduleMarkdown) {\n    const match = findScheduleSection(originalText);\n    if (match) {\n        // Replace existing schedule section (keep heading, replace content)\n        const [fullMatch, heading] = match;\n        const replacement = heading + scheduleMarkdown;\n        return originalText.replace(fullMatch, replacement);\n    }\n    else {\n        // Append new schedule section\n        const newSection = `\\n\\n## Schedule\\n${scheduleMarkdown}`;\n        return originalText + newSection;\n    }\n}\n/**\n * Validates if the schedule markdown is properly formatted\n * @param scheduleMarkdown - The schedule content to validate\n * @returns True if valid, false otherwise\n */\nexport function validateScheduleMarkdown(scheduleMarkdown) {\n    // Basic validation - check if it's not empty and contains some content\n    return scheduleMarkdown.trim().length > 0;\n}\n//# sourceMappingURL=planner.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/node_modules/obsidian/obsidian.d.ts"],"map":"{\"version\":3,\"file\":\"planner.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/planner.ts\"],\"names\":[],\"mappings\":\";AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,UAAU,CAAC;AAYnC;;;;GAIG;AACH,MAAM,UAAgB,aAAa,CAAC,QAAgB;;QAClD,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC;YAC7B,GAAG,EAAE,+BAA+B;YACpC,MAAM,EAAE,MAAM;YACd,OAAO,EAAE,EAAE,cAAc,EAAE,kBAAkB,EAAE;YAC/C,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC;SACzC,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IAC9B,CAAC;CAAA;AAED;;;;GAIG;AACH,MAAM,UAAU,mBAAmB,CAAC,IAAY;IAC9C,2FAA2F;IAC3F,IAAI,aAAa,GAAG,oDAAoD,CAAC;IACzE,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;IAEtC,IAAI,KAAK,EAAE,CAAC;QACV,OAAO,KAAK,CAAC;IACf,CAAC;IAED,6EAA6E;IAC7E,aAAa,GAAG,mEAAmE,CAAC;IACpF,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;AACnC,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,cAAc,CAAC,YAAoB,EAAE,gBAAwB;IAC3E,MAAM,KAAK,GAAG,mBAAmB,CAAC,YAAY,CAAC,CAAC;IAEhD,IAAI,KAAK,EAAE,CAAC;QACV,oEAAoE;QACpE,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,GAAG,KAAK,CAAC;QACnC,MAAM,WAAW,GAAG,OAAO,GAAG,gBAAgB,CAAC;QAC/C,OAAO,YAAY,CAAC,OAAO,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;IACtD,CAAC;SAAM,CAAC;QACN,8BAA8B;QAC9B,MAAM,UAAU,GAAG,oBAAoB,gBAAgB,EAAE,CAAC;QAC1D,OAAO,YAAY,GAAG,UAAU,CAAC;IACnC,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,wBAAwB,CAAC,gBAAwB;IAC/D,uEAAuE;IACvE,OAAO,gBAAgB,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC;AAC5C,CAAC\",\"sourcesContent\":[\"import { request } from 'obsidian';\\n\\n// Type definitions for the planner feature\\nexport interface PlannerResponse {\\n  scheduleMarkdown: string;\\n  headline: string;\\n}\\n\\nexport interface PlannerRequest {\\n  note: string;\\n}\\n\\n/**\\n * Fetches schedule data from the planner API\\n * @param noteText - The full text of the active note\\n * @returns Promise with the schedule markdown and headline\\n */\\nexport async function fetchSchedule(noteText: string): Promise<PlannerResponse> {\\n  const response = await request({\\n    url: 'http://localhost:3000/planday',\\n    method: 'POST',\\n    headers: { 'Content-Type': 'application/json' },\\n    body: JSON.stringify({ note: noteText })\\n  });\\n\\n  return JSON.parse(response);\\n}\\n\\n/**\\n * Finds and extracts the Schedule section from note text\\n * @param text - The full note text\\n * @returns Match result with schedule section details or null\\n */\\nexport function findScheduleSection(text: string): RegExpMatchArray | null {\\n  // First try to match headings that are exactly \\\"## Schedule\\\" (with optional content after)\\n  let scheduleRegex = /(^##\\\\s+Schedule\\\\b[^\\\\n]*\\\\n)([\\\\s\\\\S]*?)(?=\\\\n##\\\\s|$)/im;\\n  let match = text.match(scheduleRegex);\\n  \\n  if (match) {\\n    return match;\\n  }\\n  \\n  // If no exact match, try to match headings that contain \\\"Schedule\\\" as a word\\n  scheduleRegex = /(^##\\\\s*(?:.*\\\\s)?\\\\bSchedule\\\\b(?:\\\\s.*)?$\\\\n)([\\\\s\\\\S]*?)(?=\\\\n##\\\\s|$)/im;\\n  return text.match(scheduleRegex);\\n}\\n\\n/**\\n * Injects or replaces the schedule section in the note text\\n * @param originalText - The original note text\\n * @param scheduleMarkdown - The new schedule content to inject\\n * @returns Updated note text with the new schedule section\\n */\\nexport function injectSchedule(originalText: string, scheduleMarkdown: string): string {\\n  const match = findScheduleSection(originalText);\\n  \\n  if (match) {\\n    // Replace existing schedule section (keep heading, replace content)\\n    const [fullMatch, heading] = match;\\n    const replacement = heading + scheduleMarkdown;\\n    return originalText.replace(fullMatch, replacement);\\n  } else {\\n    // Append new schedule section\\n    const newSection = `\\\\n\\\\n## Schedule\\\\n${scheduleMarkdown}`;\\n    return originalText + newSection;\\n  }\\n}\\n\\n/**\\n * Validates if the schedule markdown is properly formatted\\n * @param scheduleMarkdown - The schedule content to validate\\n * @returns True if valid, false otherwise\\n */\\nexport function validateScheduleMarkdown(scheduleMarkdown: string): boolean {\\n  // Basic validation - check if it's not empty and contains some content\\n  return scheduleMarkdown.trim().length > 0;\\n}\\n\"]}"}
