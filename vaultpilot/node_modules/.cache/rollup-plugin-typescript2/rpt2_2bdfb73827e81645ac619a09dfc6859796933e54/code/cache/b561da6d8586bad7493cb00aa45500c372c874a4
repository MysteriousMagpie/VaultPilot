{"code":"/**\n * API Client Extensions for VaultPilot Vault Management\n */\nimport { __awaiter } from \"tslib\";\nimport { Notice } from 'obsidian';\nimport { VaultManagementError } from './vault-types';\n/**\n * Vault Management API Client\n */\nexport class VaultManagementClient {\n    constructor(baseUrl, apiKey) {\n        this.baseUrl = baseUrl;\n        this.apiKey = apiKey;\n    }\n    // === CORE API METHODS ===\n    /**\n     * Get comprehensive vault structure with AI analysis\n     */\n    getVaultStructure(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield this.makeRequest('/api/obsidian/vault/structure', {\n                    method: 'POST',\n                    body: JSON.stringify(request)\n                });\n                if (response.status === 404) {\n                    // Endpoint not implemented - return empty structure\n                    return {\n                        vault_name: 'Vault',\n                        total_files: 0,\n                        total_folders: 0,\n                        total_size: 0,\n                        structure: { name: 'vault', type: 'folder', path: '/', children: [] },\n                        recent_files: [],\n                        orphaned_files: []\n                    };\n                }\n                if (!response.ok) {\n                    throw new VaultManagementError(`Failed to get vault structure: ${response.statusText}`, 'STRUCTURE_FETCH_FAILED', 'structure');\n                }\n                return yield response.json();\n            }\n            catch (error) {\n                if (error instanceof VaultManagementError) {\n                    throw error;\n                }\n                this.handleVaultManagementError(error, 'structure');\n                throw error;\n            }\n        });\n    }\n    /**\n     * Perform individual file operation (create, update, delete, move, copy)\n     */\n    performFileOperation(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this.validateFileOperationRequest(request);\n                const response = yield this.makeRequest('/api/obsidian/vault/file/operation', {\n                    method: 'POST',\n                    body: JSON.stringify(request)\n                });\n                if (!response.ok) {\n                    throw new VaultManagementError(`File operation failed: ${response.statusText}`, 'FILE_OPERATION_FAILED', 'file-operations');\n                }\n                const result = yield response.json();\n                if (!result.success) {\n                    throw new VaultManagementError(result.message || 'File operation failed', 'FILE_OPERATION_FAILED', 'file-operations');\n                }\n                return result;\n            }\n            catch (error) {\n                this.handleVaultManagementError(error, 'file-operations');\n                throw error;\n            }\n        });\n    }\n    /**\n     * Perform multiple file operations efficiently\n     */\n    performBatchOperations(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!request.operations || request.operations.length === 0) {\n                    throw new VaultManagementError('No operations specified for batch request', 'INVALID_BATCH_REQUEST', 'batch-operations');\n                }\n                // Validate each operation\n                request.operations.forEach((op, index) => {\n                    try {\n                        this.validateFileOperationRequest(op);\n                    }\n                    catch (err) {\n                        throw new VaultManagementError(`Invalid operation at index ${index}: ${err.message || err}`, 'INVALID_BATCH_OPERATION', 'batch-operations');\n                    }\n                });\n                const response = yield this.makeRequest('/api/obsidian/vault/file/batch', {\n                    method: 'POST',\n                    body: JSON.stringify(request)\n                });\n                if (!response.ok) {\n                    throw new VaultManagementError(`Batch operations failed: ${response.statusText}`, 'BATCH_OPERATION_FAILED', 'batch-operations');\n                }\n                const result = yield response.json();\n                if (!result.success) {\n                    throw new VaultManagementError(result.message || 'Batch operations failed', 'BATCH_OPERATION_FAILED', 'batch-operations');\n                }\n                return result;\n            }\n            catch (error) {\n                this.handleVaultManagementError(error, 'batch-operations');\n                throw error;\n            }\n        });\n    }\n    /**\n     * Search vault with AI-powered insights\n     */\n    searchVault(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!request.query || request.query.trim().length === 0) {\n                    throw new VaultManagementError('Search query cannot be empty', 'INVALID_SEARCH_QUERY', 'search');\n                }\n                const response = yield this.makeRequest('/api/obsidian/vault/search', {\n                    method: 'POST',\n                    body: JSON.stringify(request)\n                });\n                if (!response.ok) {\n                    throw new VaultManagementError(`Search failed: ${response.statusText}`, 'SEARCH_FAILED', 'search');\n                }\n                return yield response.json();\n            }\n            catch (error) {\n                this.handleVaultManagementError(error, 'search');\n                throw error;\n            }\n        });\n    }\n    /**\n     * Get AI-powered vault organization suggestions\n     */\n    organizeVault(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield this.makeRequest('/api/obsidian/vault/organize', {\n                    method: 'POST',\n                    body: JSON.stringify(request)\n                });\n                if (!response.ok) {\n                    throw new VaultManagementError(`Organization analysis failed: ${response.statusText}`, 'ORGANIZATION_FAILED', 'organization');\n                }\n                return yield response.json();\n            }\n            catch (error) {\n                this.handleVaultManagementError(error, 'organization');\n                throw error;\n            }\n        });\n    }\n    /**\n     * Create vault backup\n     */\n    backupVault(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield this.makeRequest('/api/obsidian/vault/backup', {\n                    method: 'POST',\n                    body: JSON.stringify(request)\n                });\n                if (!response.ok) {\n                    throw new VaultManagementError(`Backup failed: ${response.statusText}`, 'BACKUP_FAILED', 'backup');\n                }\n                return yield response.json();\n            }\n            catch (error) {\n                this.handleVaultManagementError(error, 'backup');\n                throw error;\n            }\n        });\n    }\n    // === CONVENIENCE METHODS ===\n    /**\n     * Create a new file with content\n     */\n    createFile(filePath_1, content_1) {\n        return __awaiter(this, arguments, void 0, function* (filePath, content, backup = false) {\n            return this.performFileOperation({\n                operation: 'create',\n                file_path: filePath,\n                content,\n                backup\n            });\n        });\n    }\n    /**\n     * Update existing file content\n     */\n    updateFile(filePath_1, content_1) {\n        return __awaiter(this, arguments, void 0, function* (filePath, content, backup = true) {\n            return this.performFileOperation({\n                operation: 'update',\n                file_path: filePath,\n                content,\n                backup\n            });\n        });\n    }\n    /**\n     * Delete a file\n     */\n    deleteFile(filePath_1) {\n        return __awaiter(this, arguments, void 0, function* (filePath, backup = true) {\n            return this.performFileOperation({\n                operation: 'delete',\n                file_path: filePath,\n                backup\n            });\n        });\n    }\n    /**\n     * Move a file to new location\n     */\n    moveFile(fromPath_1, toPath_1) {\n        return __awaiter(this, arguments, void 0, function* (fromPath, toPath, backup = true) {\n            return this.performFileOperation({\n                operation: 'move',\n                file_path: fromPath,\n                new_path: toPath,\n                backup\n            });\n        });\n    }\n    /**\n     * Copy a file to new location\n     */\n    copyFile(fromPath, toPath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.performFileOperation({\n                operation: 'copy',\n                file_path: fromPath,\n                new_path: toPath\n            });\n        });\n    }\n    /**\n     * Quick search with default settings\n     */\n    quickSearch(query_1) {\n        return __awaiter(this, arguments, void 0, function* (query, maxResults = 20) {\n            return this.searchVault({\n                query,\n                search_type: 'comprehensive',\n                max_results: maxResults,\n                include_content: true\n            });\n        });\n    }\n    // === HELPER METHODS ===\n    /**\n     * Make authenticated request to the API\n     */\n    makeRequest(endpoint_1) {\n        return __awaiter(this, arguments, void 0, function* (endpoint, options = {}) {\n            const url = `${this.baseUrl.replace(/\\/$/, '')}${endpoint}`;\n            const headers = Object.assign({ 'Content-Type': 'application/json' }, (options.headers || {}));\n            if (this.apiKey) {\n                headers['Authorization'] = `Bearer ${this.apiKey}`;\n            }\n            const requestOptions = Object.assign(Object.assign({}, options), { headers });\n            try {\n                const response = yield fetch(url, requestOptions);\n                return response;\n            }\n            catch (err) {\n                throw new VaultManagementError(`Network request failed: ${err.message || err}`, 'NETWORK_ERROR', 'api');\n            }\n        });\n    }\n    /**\n     * Validate file operation request\n     */\n    validateFileOperationRequest(request) {\n        if (!request.file_path || request.file_path.trim().length === 0) {\n            throw new VaultManagementError('File path is required', 'INVALID_FILE_PATH', 'validation');\n        }\n        if (request.operation === 'move' || request.operation === 'copy') {\n            if (!request.new_path || request.new_path.trim().length === 0) {\n                throw new VaultManagementError('New path is required for move/copy operations', 'INVALID_NEW_PATH', 'validation');\n            }\n        }\n        if (request.operation === 'create' || request.operation === 'update') {\n            if (request.content === undefined) {\n                throw new VaultManagementError('Content is required for create/update operations', 'INVALID_CONTENT', 'validation');\n            }\n        }\n    }\n    /**\n     * Handle vault management errors with user feedback\n     */\n    handleVaultManagementError(error, feature) {\n        console.error(`Vault management error in ${feature}:`, error);\n        if (error instanceof VaultManagementError) {\n            new Notice(`Vault ${feature} error: ${error.message}`, 5000);\n        }\n        else {\n            new Notice(`Vault ${feature} operation failed`, 3000);\n        }\n    }\n    /**\n     * Test connection to vault management endpoints\n     */\n    testConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Try a simple vault structure request with minimal parameters\n                const response = yield this.makeRequest('/api/obsidian/vault/structure', {\n                    method: 'POST',\n                    body: JSON.stringify({ include_content: false, max_depth: 1 })\n                });\n                if (response.ok) {\n                    return { success: true, message: 'Vault management connection successful' };\n                }\n                else {\n                    return {\n                        success: false,\n                        message: `Connection failed: ${response.status} ${response.statusText}`\n                    };\n                }\n            }\n            catch (err) {\n                return {\n                    success: false,\n                    message: `Connection error: ${err.message || err}`\n                };\n            }\n        });\n    }\n}\n// === UTILITY FUNCTIONS ===\n/**\n * Format file size in human readable format\n */\nexport function formatFileSize(bytes) {\n    if (bytes === 0)\n        return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n/**\n * Validate file path format\n */\nexport function isValidFilePath(path) {\n    if (!path || path.trim().length === 0)\n        return false;\n    // Check for invalid characters\n    const invalidChars = /[<>:\"|?*]/;\n    if (invalidChars.test(path))\n        return false;\n    // Check for reserved names on Windows\n    const reservedNames = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i;\n    const fileName = path.split('/').pop() || '';\n    if (reservedNames.test(fileName.split('.')[0]))\n        return false;\n    return true;\n}\n/**\n * Sanitize file path\n */\nexport function sanitizeFilePath(path) {\n    return path\n        .replace(/[<>:\"|?*]/g, '_')\n        .replace(/\\\\/g, '/')\n        .replace(/\\/+/g, '/')\n        .replace(/^\\/+|\\/+$/g, '');\n}\n//# sourceMappingURL=vault-api-client.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/node_modules/obsidian/obsidian.d.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/vault-types.ts"],"map":"{\"version\":3,\"file\":\"vault-api-client.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/vault-api-client.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * API Client Extensions for VaultPilot Vault Management\\n */\\n\\nimport { Notice } from 'obsidian';\\nimport {\\n  VaultStructureRequest,\\n  VaultStructureResponse,\\n  FileOperationRequest,\\n  FileOperationResponse,\\n  BatchFileOperationRequest,\\n  BatchFileOperationResponse,\\n  VaultSearchRequest,\\n  VaultSearchResponse,\\n  VaultOrganizationRequest,\\n  VaultOrganizationResponse,\\n  VaultBackupRequest,\\n  VaultBackupResponse,\\n  VaultManagementError,\\n  VaultManagementAPI\\n} from './vault-types';\\n\\n/**\\n * Vault Management API Client\\n */\\nexport class VaultManagementClient implements VaultManagementAPI {\\n  private baseUrl: string;\\n  private apiKey?: string;\\n\\n  constructor(baseUrl: string, apiKey?: string) {\\n    this.baseUrl = baseUrl;\\n    this.apiKey = apiKey;\\n  }\\n\\n  // === CORE API METHODS ===\\n\\n  /**\\n   * Get comprehensive vault structure with AI analysis\\n   */\\n  async getVaultStructure(request: VaultStructureRequest): Promise<VaultStructureResponse> {\\n    try {\\n      const response = await this.makeRequest('/api/obsidian/vault/structure', {\\n        method: 'POST',\\n        body: JSON.stringify(request)\\n      });\\n\\n      if (response.status === 404) {\\n        // Endpoint not implemented - return empty structure\\n        return {\\n          vault_name: 'Vault',\\n          total_files: 0,\\n          total_folders: 0,\\n          total_size: 0,\\n          structure: { name: 'vault', type: 'folder', path: '/', children: [] },\\n          recent_files: [],\\n          orphaned_files: []\\n        };\\n      }\\n\\n      if (!response.ok) {\\n        throw new VaultManagementError(\\n          `Failed to get vault structure: ${response.statusText}`,\\n          'STRUCTURE_FETCH_FAILED',\\n          'structure'\\n        );\\n      }\\n\\n      return await response.json();\\n    } catch (error) {\\n      if (error instanceof VaultManagementError) {\\n        throw error;\\n      }\\n      this.handleVaultManagementError(error, 'structure');\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Perform individual file operation (create, update, delete, move, copy)\\n   */\\n  async performFileOperation(request: FileOperationRequest): Promise<FileOperationResponse> {\\n    try {\\n      this.validateFileOperationRequest(request);\\n\\n      const response = await this.makeRequest('/api/obsidian/vault/file/operation', {\\n        method: 'POST',\\n        body: JSON.stringify(request)\\n      });\\n\\n      if (!response.ok) {\\n        throw new VaultManagementError(\\n          `File operation failed: ${response.statusText}`,\\n          'FILE_OPERATION_FAILED',\\n          'file-operations'\\n        );\\n      }\\n\\n      const result = await response.json();\\n      \\n      if (!result.success) {\\n        throw new VaultManagementError(\\n          result.message || 'File operation failed',\\n          'FILE_OPERATION_FAILED',\\n          'file-operations'\\n        );\\n      }\\n\\n      return result;\\n    } catch (error) {\\n      this.handleVaultManagementError(error, 'file-operations');\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Perform multiple file operations efficiently\\n   */\\n  async performBatchOperations(request: BatchFileOperationRequest): Promise<BatchFileOperationResponse> {\\n    try {\\n      if (!request.operations || request.operations.length === 0) {\\n        throw new VaultManagementError(\\n          'No operations specified for batch request',\\n          'INVALID_BATCH_REQUEST',\\n          'batch-operations'\\n        );\\n      }\\n\\n      // Validate each operation\\n      request.operations.forEach((op, index) => {\\n        try {\\n          this.validateFileOperationRequest(op);\\n        } catch (err: any) {\\n          throw new VaultManagementError(\\n            `Invalid operation at index ${index}: ${err.message || err}`,\\n            'INVALID_BATCH_OPERATION',\\n            'batch-operations'\\n          );\\n        }\\n      });\\n\\n      const response = await this.makeRequest('/api/obsidian/vault/file/batch', {\\n        method: 'POST',\\n        body: JSON.stringify(request)\\n      });\\n\\n      if (!response.ok) {\\n        throw new VaultManagementError(\\n          `Batch operations failed: ${response.statusText}`,\\n          'BATCH_OPERATION_FAILED',\\n          'batch-operations'\\n        );\\n      }\\n\\n      const result = await response.json();\\n      \\n      if (!result.success) {\\n        throw new VaultManagementError(\\n          result.message || 'Batch operations failed',\\n          'BATCH_OPERATION_FAILED',\\n          'batch-operations'\\n        );\\n      }\\n\\n      return result;\\n    } catch (error) {\\n      this.handleVaultManagementError(error, 'batch-operations');\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Search vault with AI-powered insights\\n   */\\n  async searchVault(request: VaultSearchRequest): Promise<VaultSearchResponse> {\\n    try {\\n      if (!request.query || request.query.trim().length === 0) {\\n        throw new VaultManagementError(\\n          'Search query cannot be empty',\\n          'INVALID_SEARCH_QUERY',\\n          'search'\\n        );\\n      }\\n\\n      const response = await this.makeRequest('/api/obsidian/vault/search', {\\n        method: 'POST',\\n        body: JSON.stringify(request)\\n      });\\n\\n      if (!response.ok) {\\n        throw new VaultManagementError(\\n          `Search failed: ${response.statusText}`,\\n          'SEARCH_FAILED',\\n          'search'\\n        );\\n      }\\n\\n      return await response.json();\\n    } catch (error) {\\n      this.handleVaultManagementError(error, 'search');\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Get AI-powered vault organization suggestions\\n   */\\n  async organizeVault(request: VaultOrganizationRequest): Promise<VaultOrganizationResponse> {\\n    try {\\n      const response = await this.makeRequest('/api/obsidian/vault/organize', {\\n        method: 'POST',\\n        body: JSON.stringify(request)\\n      });\\n\\n      if (!response.ok) {\\n        throw new VaultManagementError(\\n          `Organization analysis failed: ${response.statusText}`,\\n          'ORGANIZATION_FAILED',\\n          'organization'\\n        );\\n      }\\n\\n      return await response.json();\\n    } catch (error) {\\n      this.handleVaultManagementError(error, 'organization');\\n      throw error;\\n    }\\n  }\\n\\n  /**\\n   * Create vault backup\\n   */\\n  async backupVault(request: VaultBackupRequest): Promise<VaultBackupResponse> {\\n    try {\\n      const response = await this.makeRequest('/api/obsidian/vault/backup', {\\n        method: 'POST',\\n        body: JSON.stringify(request)\\n      });\\n\\n      if (!response.ok) {\\n        throw new VaultManagementError(\\n          `Backup failed: ${response.statusText}`,\\n          'BACKUP_FAILED',\\n          'backup'\\n        );\\n      }\\n\\n      return await response.json();\\n    } catch (error) {\\n      this.handleVaultManagementError(error, 'backup');\\n      throw error;\\n    }\\n  }\\n\\n  // === CONVENIENCE METHODS ===\\n\\n  /**\\n   * Create a new file with content\\n   */\\n  async createFile(filePath: string, content: string, backup: boolean = false): Promise<FileOperationResponse> {\\n    return this.performFileOperation({\\n      operation: 'create',\\n      file_path: filePath,\\n      content,\\n      backup\\n    });\\n  }\\n\\n  /**\\n   * Update existing file content\\n   */\\n  async updateFile(filePath: string, content: string, backup: boolean = true): Promise<FileOperationResponse> {\\n    return this.performFileOperation({\\n      operation: 'update',\\n      file_path: filePath,\\n      content,\\n      backup\\n    });\\n  }\\n\\n  /**\\n   * Delete a file\\n   */\\n  async deleteFile(filePath: string, backup: boolean = true): Promise<FileOperationResponse> {\\n    return this.performFileOperation({\\n      operation: 'delete',\\n      file_path: filePath,\\n      backup\\n    });\\n  }\\n\\n  /**\\n   * Move a file to new location\\n   */\\n  async moveFile(fromPath: string, toPath: string, backup: boolean = true): Promise<FileOperationResponse> {\\n    return this.performFileOperation({\\n      operation: 'move',\\n      file_path: fromPath,\\n      new_path: toPath,\\n      backup\\n    });\\n  }\\n\\n  /**\\n   * Copy a file to new location\\n   */\\n  async copyFile(fromPath: string, toPath: string): Promise<FileOperationResponse> {\\n    return this.performFileOperation({\\n      operation: 'copy',\\n      file_path: fromPath,\\n      new_path: toPath\\n    });\\n  }\\n\\n  /**\\n   * Quick search with default settings\\n   */\\n  async quickSearch(query: string, maxResults: number = 20): Promise<VaultSearchResponse> {\\n    return this.searchVault({\\n      query,\\n      search_type: 'comprehensive',\\n      max_results: maxResults,\\n      include_content: true\\n    });\\n  }\\n\\n  // === HELPER METHODS ===\\n\\n  /**\\n   * Make authenticated request to the API\\n   */\\n  private async makeRequest(endpoint: string, options: RequestInit = {}): Promise<Response> {\\n    const url = `${this.baseUrl.replace(/\\\\/$/, '')}${endpoint}`;\\n    \\n    const headers: Record<string, string> = {\\n      'Content-Type': 'application/json',\\n      ...((options.headers as Record<string, string>) || {})\\n    };\\n\\n    if (this.apiKey) {\\n      headers['Authorization'] = `Bearer ${this.apiKey}`;\\n    }\\n\\n    const requestOptions: RequestInit = {\\n      ...options,\\n      headers\\n    };\\n\\n    try {\\n      const response = await fetch(url, requestOptions);\\n      return response;\\n    } catch (err: any) {\\n      throw new VaultManagementError(\\n        `Network request failed: ${err.message || err}`,\\n        'NETWORK_ERROR',\\n        'api'\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Validate file operation request\\n   */\\n  private validateFileOperationRequest(request: FileOperationRequest): void {\\n    if (!request.file_path || request.file_path.trim().length === 0) {\\n      throw new VaultManagementError(\\n        'File path is required',\\n        'INVALID_FILE_PATH',\\n        'validation'\\n      );\\n    }\\n\\n    if (request.operation === 'move' || request.operation === 'copy') {\\n      if (!request.new_path || request.new_path.trim().length === 0) {\\n        throw new VaultManagementError(\\n          'New path is required for move/copy operations',\\n          'INVALID_NEW_PATH',\\n          'validation'\\n        );\\n      }\\n    }\\n\\n    if (request.operation === 'create' || request.operation === 'update') {\\n      if (request.content === undefined) {\\n        throw new VaultManagementError(\\n          'Content is required for create/update operations',\\n          'INVALID_CONTENT',\\n          'validation'\\n        );\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Handle vault management errors with user feedback\\n   */\\n  private handleVaultManagementError(error: any, feature: string): void {\\n    console.error(`Vault management error in ${feature}:`, error);\\n    \\n    if (error instanceof VaultManagementError) {\\n      new Notice(`Vault ${feature} error: ${error.message}`, 5000);\\n    } else {\\n      new Notice(`Vault ${feature} operation failed`, 3000);\\n    }\\n  }\\n\\n  /**\\n   * Test connection to vault management endpoints\\n   */\\n  async testConnection(): Promise<{ success: boolean; message: string }> {\\n    try {\\n      // Try a simple vault structure request with minimal parameters\\n      const response = await this.makeRequest('/api/obsidian/vault/structure', {\\n        method: 'POST',\\n        body: JSON.stringify({ include_content: false, max_depth: 1 })\\n      });\\n\\n      if (response.ok) {\\n        return { success: true, message: 'Vault management connection successful' };\\n      } else {\\n        return { \\n          success: false, \\n          message: `Connection failed: ${response.status} ${response.statusText}` \\n        };\\n      }\\n    } catch (err: any) {\\n      return { \\n        success: false, \\n        message: `Connection error: ${err.message || err}` \\n      };\\n    }\\n  }\\n}\\n\\n// === UTILITY FUNCTIONS ===\\n\\n/**\\n * Format file size in human readable format\\n */\\nexport function formatFileSize(bytes: number): string {\\n  if (bytes === 0) return '0 B';\\n  \\n  const k = 1024;\\n  const sizes = ['B', 'KB', 'MB', 'GB'];\\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\\n  \\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\\n}\\n\\n/**\\n * Validate file path format\\n */\\nexport function isValidFilePath(path: string): boolean {\\n  if (!path || path.trim().length === 0) return false;\\n  \\n  // Check for invalid characters\\n  const invalidChars = /[<>:\\\"|?*]/;\\n  if (invalidChars.test(path)) return false;\\n  \\n  // Check for reserved names on Windows\\n  const reservedNames = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i;\\n  const fileName = path.split('/').pop() || '';\\n  if (reservedNames.test(fileName.split('.')[0])) return false;\\n  \\n  return true;\\n}\\n\\n/**\\n * Sanitize file path\\n */\\nexport function sanitizeFilePath(path: string): string {\\n  return path\\n    .replace(/[<>:\\\"|?*]/g, '_')\\n    .replace(/\\\\\\\\/g, '/')\\n    .replace(/\\\\/+/g, '/')\\n    .replace(/^\\\\/+|\\\\/+$/g, '');\\n}\\n\"]}"}
