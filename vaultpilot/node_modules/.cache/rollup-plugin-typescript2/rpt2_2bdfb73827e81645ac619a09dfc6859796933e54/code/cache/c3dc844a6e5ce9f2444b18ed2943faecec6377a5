{"code":"/**\n * FileSystem Transport for DevPipe communication\n * Supports file-based communication with proper locking and atomic operations\n */\nimport { __awaiter } from \"tslib\";\nimport { TransportType, TransportEvent } from './DevPipeTransport';\nimport { BaseTransport } from './BaseTransport';\nimport { EnvironmentDetector } from '../../utils/EnvironmentDetector';\n/**\n * Simple file lock manager for atomic operations\n */\nclass FileLockManager {\n    constructor(lockTimeout = 5000) {\n        this.locks = new Set();\n        this.lockTimeout = lockTimeout;\n    }\n    acquireLock(filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const attemptLock = () => {\n                    if (!this.locks.has(filePath)) {\n                        this.locks.add(filePath);\n                        resolve();\n                    }\n                    else {\n                        setTimeout(attemptLock, 100); // Retry every 100ms\n                    }\n                };\n                // Set timeout for lock acquisition\n                setTimeout(() => {\n                    reject(new Error(`Failed to acquire lock for ${filePath} within ${this.lockTimeout}ms`));\n                }, this.lockTimeout);\n                attemptLock();\n            });\n        });\n    }\n    releaseLock(filePath) {\n        this.locks.delete(filePath);\n    }\n}\n/**\n * File watcher implementation for monitoring response files\n */\nclass FileWatcher {\n    constructor() {\n        this.watchers = new Map();\n        this.callbacks = new Map();\n    }\n    watch(filePath, callback) {\n        this.callbacks.set(filePath, callback);\n        // Simple polling implementation (could be enhanced with proper file watching)\n        const watcher = setInterval(() => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const exists = yield this.fileExists(filePath);\n                if (exists) {\n                    const content = yield this.readFile(filePath);\n                    callback(content);\n                    this.unwatch(filePath);\n                }\n            }\n            catch (error) {\n                // File doesn't exist yet or other error, continue watching\n            }\n        }), 500); // Check every 500ms\n        this.watchers.set(filePath, watcher);\n    }\n    unwatch(filePath) {\n        const watcher = this.watchers.get(filePath);\n        if (watcher) {\n            clearInterval(watcher);\n            this.watchers.delete(filePath);\n        }\n        this.callbacks.delete(filePath);\n    }\n    fileExists(filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            // Platform-specific file existence check\n            if (typeof window !== 'undefined' && ((_c = (_b = (_a = window.app) === null || _a === void 0 ? void 0 : _a.vault) === null || _b === void 0 ? void 0 : _b.adapter) === null || _c === void 0 ? void 0 : _c.exists)) {\n                // Obsidian environment\n                return window.app.vault.adapter.exists(filePath);\n            }\n            else if (typeof globalThis.require !== 'undefined') {\n                // Node.js environment\n                try {\n                    const fs = globalThis.require('fs').promises;\n                    yield fs.access(filePath);\n                    return true;\n                }\n                catch (_d) {\n                    return false;\n                }\n            }\n            return false;\n        });\n    }\n    readFile(filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            // Platform-specific file reading\n            if (typeof window !== 'undefined' && ((_c = (_b = (_a = window.app) === null || _a === void 0 ? void 0 : _a.vault) === null || _b === void 0 ? void 0 : _b.adapter) === null || _c === void 0 ? void 0 : _c.read)) {\n                // Obsidian environment\n                return window.app.vault.adapter.read(filePath);\n            }\n            else if (typeof globalThis.require !== 'undefined') {\n                // Node.js environment\n                const fs = globalThis.require('fs').promises;\n                return fs.readFile(filePath, 'utf-8');\n            }\n            throw new Error('File reading not supported in this environment');\n        });\n    }\n}\n/**\n * FileSystem Transport implementation\n */\nexport class FileSystemTransport extends BaseTransport {\n    constructor(config) {\n        super(TransportType.FILESYSTEM, config);\n        this.pendingRequests = new Map();\n        this.messageQueue = [];\n        this.fsConfig = config.filesystem || {\n            watchInterval: 500,\n            lockTimeout: 5000,\n            maxQueueSize: 100\n        };\n        this.devPipePath = config.devPipePath || './devpipe';\n        this.fileWatcher = new FileWatcher();\n        this.lockManager = new FileLockManager(this.fsConfig.lockTimeout);\n    }\n    doInitialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Validate file system support in environment\n            const environment = EnvironmentDetector.detect();\n            if (!environment.hasFileSystem) {\n                throw new Error('FileSystem transport not supported in this environment');\n            }\n            // Ensure devpipe directory exists\n            yield this.ensureDirectoryExists(this.devPipePath);\n            this.debug('FileSystem transport initialized');\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Test file system access\n                yield this.doHealthCheck();\n                // Start watching for incoming messages\n                this.setupIncomingMessageWatcher();\n                this.connected = true;\n                this.healthStatus.status = 'healthy';\n                this.emit(TransportEvent.CONNECTED, { transport: this.type });\n                this.debug('FileSystem transport connected');\n            }\n            catch (error) {\n                this.emit(TransportEvent.ERROR, error);\n                throw error;\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Reject all pending requests\n            const requests = Array.from(this.pendingRequests.values());\n            for (const request of requests) {\n                clearTimeout(request.timeout);\n                this.fileWatcher.unwatch(request.responseFile);\n                request.reject(new Error('Transport disconnected'));\n            }\n            this.pendingRequests.clear();\n            this.connected = false;\n            this.healthStatus.status = 'disconnected';\n            this.emit(TransportEvent.DISCONNECTED, { transport: this.type });\n            this.debug('FileSystem transport disconnected');\n        });\n    }\n    send(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isConnected()) {\n                throw new Error('FileSystem transport not connected');\n            }\n            // Add message ID if not present\n            if (!message.id) {\n                message.id = this.generateMessageId();\n            }\n            // Add timestamp\n            message.timestamp = Date.now();\n            return this.executeWithCircuitBreaker(() => __awaiter(this, void 0, void 0, function* () {\n                return this.sendFileMessage(message);\n            }), 'filesystem_send');\n        });\n    }\n    sendFileMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const requestFile = `${this.devPipePath}/request_${message.id}.json`;\n            const responseFile = `${this.devPipePath}/response_${message.id}.json`;\n            return new Promise((resolve, reject) => {\n                const timeoutHandle = setTimeout(() => {\n                    this.pendingRequests.delete(message.id);\n                    this.fileWatcher.unwatch(responseFile);\n                    reject(new Error(`FileSystem request timeout after ${this.config.timeout}ms`));\n                }, this.config.timeout);\n                const request = {\n                    id: message.id,\n                    message,\n                    resolve: (response) => {\n                        clearTimeout(timeoutHandle);\n                        this.pendingRequests.delete(message.id);\n                        this.fileWatcher.unwatch(responseFile);\n                        resolve(response);\n                    },\n                    reject: (error) => {\n                        clearTimeout(timeoutHandle);\n                        this.pendingRequests.delete(message.id);\n                        this.fileWatcher.unwatch(responseFile);\n                        reject(error);\n                    },\n                    timeout: timeoutHandle,\n                    timestamp: Date.now(),\n                    requestFile,\n                    responseFile\n                };\n                this.pendingRequests.set(message.id, request);\n                // Watch for response file\n                this.fileWatcher.watch(responseFile, (content) => {\n                    try {\n                        const response = JSON.parse(content);\n                        const devPipeResponse = {\n                            id: response.id,\n                            success: response.success !== false,\n                            payload: response.payload,\n                            error: response.error,\n                            timestamp: Date.now()\n                        };\n                        request.resolve(devPipeResponse);\n                    }\n                    catch (error) {\n                        request.reject(new Error('Failed to parse response file'));\n                    }\n                });\n                // Write request file\n                this.writeRequestFile(requestFile, message, request);\n            });\n        });\n    }\n    writeRequestFile(filePath, message, request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.lockManager.acquireLock(filePath);\n                yield this.writeFile(filePath, JSON.stringify(message, null, 2));\n                this.lockManager.releaseLock(filePath);\n            }\n            catch (error) {\n                this.lockManager.releaseLock(filePath);\n                request.reject(error instanceof Error ? error : new Error('Failed to write request file'));\n            }\n        });\n    }\n    setupIncomingMessageWatcher() {\n        // Watch for incoming messages (this would be implemented based on the specific protocol)\n        // For now, we'll just log that the watcher is set up\n        this.debug('Incoming message watcher setup completed');\n    }\n    ensureDirectoryExists(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            // Platform-specific directory creation\n            if (typeof window !== 'undefined' && ((_c = (_b = (_a = window.app) === null || _a === void 0 ? void 0 : _a.vault) === null || _b === void 0 ? void 0 : _b.adapter) === null || _c === void 0 ? void 0 : _c.mkdir)) {\n                // Obsidian environment\n                try {\n                    yield window.app.vault.adapter.mkdir(path);\n                }\n                catch (error) {\n                    // Directory might already exist\n                }\n            }\n            else if (typeof globalThis.require !== 'undefined') {\n                // Node.js environment\n                try {\n                    const fs = globalThis.require('fs').promises;\n                    yield fs.mkdir(path, { recursive: true });\n                }\n                catch (error) {\n                    // Directory might already exist\n                }\n            }\n        });\n    }\n    writeFile(filePath, content) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            // Platform-specific file writing\n            if (typeof window !== 'undefined' && ((_c = (_b = (_a = window.app) === null || _a === void 0 ? void 0 : _a.vault) === null || _b === void 0 ? void 0 : _b.adapter) === null || _c === void 0 ? void 0 : _c.write)) {\n                // Obsidian environment\n                return window.app.vault.adapter.write(filePath, content);\n            }\n            else if (typeof globalThis.require !== 'undefined') {\n                // Node.js environment\n                const fs = globalThis.require('fs').promises;\n                return fs.writeFile(filePath, content, 'utf-8');\n            }\n            throw new Error('File writing not supported in this environment');\n        });\n    }\n    readFile(filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            // Platform-specific file reading\n            if (typeof window !== 'undefined' && ((_c = (_b = (_a = window.app) === null || _a === void 0 ? void 0 : _a.vault) === null || _b === void 0 ? void 0 : _b.adapter) === null || _c === void 0 ? void 0 : _c.read)) {\n                // Obsidian environment\n                return window.app.vault.adapter.read(filePath);\n            }\n            else if (typeof globalThis.require !== 'undefined') {\n                // Node.js environment\n                const fs = globalThis.require('fs').promises;\n                return fs.readFile(filePath, 'utf-8');\n            }\n            throw new Error('File reading not supported in this environment');\n        });\n    }\n    doHealthCheck() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const testFile = `${this.devPipePath}/health_check_${Date.now()}.tmp`;\n            try {\n                // Test write access\n                yield this.writeFile(testFile, 'health_check');\n                // Test read access\n                const content = yield this.readFile(testFile);\n                if (content !== 'health_check') {\n                    throw new Error('File content mismatch during health check');\n                }\n                // Clean up test file\n                yield this.deleteFile(testFile);\n            }\n            catch (error) {\n                throw new Error(`FileSystem health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        });\n    }\n    deleteFile(filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            // Platform-specific file deletion\n            if (typeof window !== 'undefined' && ((_c = (_b = (_a = window.app) === null || _a === void 0 ? void 0 : _a.vault) === null || _b === void 0 ? void 0 : _b.adapter) === null || _c === void 0 ? void 0 : _c.remove)) {\n                // Obsidian environment\n                try {\n                    yield window.app.vault.adapter.remove(filePath);\n                }\n                catch (error) {\n                    // File might not exist\n                }\n            }\n            else if (typeof globalThis.require !== 'undefined') {\n                // Node.js environment\n                try {\n                    const fs = globalThis.require('fs').promises;\n                    yield fs.unlink(filePath);\n                }\n                catch (error) {\n                    // File might not exist\n                }\n            }\n        });\n    }\n    getCapabilities() {\n        return {\n            supportsRealtime: false,\n            supportsBidirectional: true,\n            supportsFileSystem: true,\n            supportsStreaming: false,\n            maxMessageSize: 10 * 1024 * 1024, // 10MB\n            averageLatency: this.healthStatus.latency,\n            maxConcurrentConnections: 1,\n            reliability: this.calculateReliability(),\n            supportedEnvironments: ['node', 'obsidian']\n        };\n    }\n}\n//# sourceMappingURL=FileSystemTransport.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/DevPipeTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/BaseTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/utils/EnvironmentDetector.ts"],"map":"{\"version\":3,\"file\":\"FileSystemTransport.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/devpipe/transports/FileSystemTransport.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * FileSystem Transport for DevPipe communication\\n * Supports file-based communication with proper locking and atomic operations\\n */\\n\\nimport { \\n  DevPipeTransport,\\n  TransportType,\\n  TransportConfig,\\n  TransportCapabilities,\\n  DevPipeMessage,\\n  DevPipeResponse,\\n  TransportEvent,\\n  FileSystemTransportConfig\\n} from './DevPipeTransport';\\nimport { BaseTransport } from './BaseTransport';\\nimport { EnvironmentDetector } from '../../utils/EnvironmentDetector';\\n\\ninterface PendingFileRequest {\\n  id: string;\\n  message: DevPipeMessage;\\n  resolve: (response: DevPipeResponse) => void;\\n  reject: (error: Error) => void;\\n  timeout: any;\\n  timestamp: number;\\n  requestFile: string;\\n  responseFile: string;\\n}\\n\\n/**\\n * Simple file lock manager for atomic operations\\n */\\nclass FileLockManager {\\n  private locks: Set<string> = new Set();\\n  private lockTimeout: number;\\n\\n  constructor(lockTimeout: number = 5000) {\\n    this.lockTimeout = lockTimeout;\\n  }\\n\\n  async acquireLock(filePath: string): Promise<void> {\\n    return new Promise((resolve, reject) => {\\n      const attemptLock = () => {\\n        if (!this.locks.has(filePath)) {\\n          this.locks.add(filePath);\\n          resolve();\\n        } else {\\n          setTimeout(attemptLock, 100); // Retry every 100ms\\n        }\\n      };\\n\\n      // Set timeout for lock acquisition\\n      setTimeout(() => {\\n        reject(new Error(`Failed to acquire lock for ${filePath} within ${this.lockTimeout}ms`));\\n      }, this.lockTimeout);\\n\\n      attemptLock();\\n    });\\n  }\\n\\n  releaseLock(filePath: string): void {\\n    this.locks.delete(filePath);\\n  }\\n}\\n\\n/**\\n * File watcher implementation for monitoring response files\\n */\\nclass FileWatcher {\\n  private watchers: Map<string, any> = new Map();\\n  private callbacks: Map<string, (content: string) => void> = new Map();\\n\\n  watch(filePath: string, callback: (content: string) => void): void {\\n    this.callbacks.set(filePath, callback);\\n    \\n    // Simple polling implementation (could be enhanced with proper file watching)\\n    const watcher = setInterval(async () => {\\n      try {\\n        const exists = await this.fileExists(filePath);\\n        if (exists) {\\n          const content = await this.readFile(filePath);\\n          callback(content);\\n          this.unwatch(filePath);\\n        }\\n      } catch (error) {\\n        // File doesn't exist yet or other error, continue watching\\n      }\\n    }, 500); // Check every 500ms\\n\\n    this.watchers.set(filePath, watcher);\\n  }\\n\\n  unwatch(filePath: string): void {\\n    const watcher = this.watchers.get(filePath);\\n    if (watcher) {\\n      clearInterval(watcher);\\n      this.watchers.delete(filePath);\\n    }\\n    this.callbacks.delete(filePath);\\n  }\\n\\n  private async fileExists(filePath: string): Promise<boolean> {\\n    // Platform-specific file existence check\\n    if (typeof window !== 'undefined' && window.app?.vault?.adapter?.exists) {\\n      // Obsidian environment\\n      return window.app.vault.adapter.exists(filePath);\\n    } else if (typeof (globalThis as any).require !== 'undefined') {\\n      // Node.js environment\\n      try {\\n        const fs = (globalThis as any).require('fs').promises;\\n        await fs.access(filePath);\\n        return true;\\n      } catch {\\n        return false;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  private async readFile(filePath: string): Promise<string> {\\n    // Platform-specific file reading\\n    if (typeof window !== 'undefined' && window.app?.vault?.adapter?.read) {\\n      // Obsidian environment\\n      return window.app.vault.adapter.read(filePath);\\n    } else if (typeof (globalThis as any).require !== 'undefined') {\\n      // Node.js environment\\n      const fs = (globalThis as any).require('fs').promises;\\n      return fs.readFile(filePath, 'utf-8');\\n    }\\n    throw new Error('File reading not supported in this environment');\\n  }\\n}\\n\\n/**\\n * FileSystem Transport implementation\\n */\\nexport class FileSystemTransport extends BaseTransport {\\n  private devPipePath: string;\\n  private fileWatcher: FileWatcher;\\n  private lockManager: FileLockManager;\\n  private pendingRequests: Map<string, PendingFileRequest> = new Map();\\n  private fsConfig: FileSystemTransportConfig;\\n  private messageQueue: DevPipeMessage[] = [];\\n\\n  constructor(config: TransportConfig) {\\n    super(TransportType.FILESYSTEM, config);\\n    \\n    this.fsConfig = config.filesystem || {\\n      watchInterval: 500,\\n      lockTimeout: 5000,\\n      maxQueueSize: 100\\n    };\\n    \\n    this.devPipePath = config.devPipePath || './devpipe';\\n    this.fileWatcher = new FileWatcher();\\n    this.lockManager = new FileLockManager(this.fsConfig.lockTimeout);\\n  }\\n\\n  protected async doInitialize(): Promise<void> {\\n    // Validate file system support in environment\\n    const environment = EnvironmentDetector.detect();\\n    if (!environment.hasFileSystem) {\\n      throw new Error('FileSystem transport not supported in this environment');\\n    }\\n\\n    // Ensure devpipe directory exists\\n    await this.ensureDirectoryExists(this.devPipePath);\\n    \\n    this.debug('FileSystem transport initialized');\\n  }\\n\\n  async connect(): Promise<void> {\\n    try {\\n      // Test file system access\\n      await this.doHealthCheck();\\n      \\n      // Start watching for incoming messages\\n      this.setupIncomingMessageWatcher();\\n      \\n      this.connected = true;\\n      this.healthStatus.status = 'healthy';\\n      this.emit(TransportEvent.CONNECTED, { transport: this.type });\\n      \\n      this.debug('FileSystem transport connected');\\n    } catch (error) {\\n      this.emit(TransportEvent.ERROR, error);\\n      throw error;\\n    }\\n  }\\n\\n  async disconnect(): Promise<void> {\\n    // Reject all pending requests\\n    const requests = Array.from(this.pendingRequests.values());\\n    for (const request of requests) {\\n      clearTimeout(request.timeout);\\n      this.fileWatcher.unwatch(request.responseFile);\\n      request.reject(new Error('Transport disconnected'));\\n    }\\n    this.pendingRequests.clear();\\n\\n    this.connected = false;\\n    this.healthStatus.status = 'disconnected';\\n    this.emit(TransportEvent.DISCONNECTED, { transport: this.type });\\n    \\n    this.debug('FileSystem transport disconnected');\\n  }\\n\\n  async send(message: DevPipeMessage): Promise<DevPipeResponse> {\\n    if (!this.isConnected()) {\\n      throw new Error('FileSystem transport not connected');\\n    }\\n\\n    // Add message ID if not present\\n    if (!message.id) {\\n      message.id = this.generateMessageId();\\n    }\\n\\n    // Add timestamp\\n    message.timestamp = Date.now();\\n\\n    return this.executeWithCircuitBreaker(async () => {\\n      return this.sendFileMessage(message);\\n    }, 'filesystem_send');\\n  }\\n\\n  private async sendFileMessage(message: DevPipeMessage): Promise<DevPipeResponse> {\\n    const requestFile = `${this.devPipePath}/request_${message.id}.json`;\\n    const responseFile = `${this.devPipePath}/response_${message.id}.json`;\\n\\n    return new Promise((resolve, reject) => {\\n      const timeoutHandle = setTimeout(() => {\\n        this.pendingRequests.delete(message.id!);\\n        this.fileWatcher.unwatch(responseFile);\\n        reject(new Error(`FileSystem request timeout after ${this.config.timeout}ms`));\\n      }, this.config.timeout);\\n\\n      const request: PendingFileRequest = {\\n        id: message.id!,\\n        message,\\n        resolve: (response) => {\\n          clearTimeout(timeoutHandle);\\n          this.pendingRequests.delete(message.id!);\\n          this.fileWatcher.unwatch(responseFile);\\n          resolve(response);\\n        },\\n        reject: (error) => {\\n          clearTimeout(timeoutHandle);\\n          this.pendingRequests.delete(message.id!);\\n          this.fileWatcher.unwatch(responseFile);\\n          reject(error);\\n        },\\n        timeout: timeoutHandle,\\n        timestamp: Date.now(),\\n        requestFile,\\n        responseFile\\n      };\\n\\n      this.pendingRequests.set(message.id!, request);\\n\\n      // Watch for response file\\n      this.fileWatcher.watch(responseFile, (content) => {\\n        try {\\n          const response = JSON.parse(content);\\n          const devPipeResponse: DevPipeResponse = {\\n            id: response.id,\\n            success: response.success !== false,\\n            payload: response.payload,\\n            error: response.error,\\n            timestamp: Date.now()\\n          };\\n          request.resolve(devPipeResponse);\\n        } catch (error) {\\n          request.reject(new Error('Failed to parse response file'));\\n        }\\n      });\\n\\n      // Write request file\\n      this.writeRequestFile(requestFile, message, request);\\n    });\\n  }\\n\\n  private async writeRequestFile(filePath: string, message: DevPipeMessage, request: PendingFileRequest): Promise<void> {\\n    try {\\n      await this.lockManager.acquireLock(filePath);\\n      await this.writeFile(filePath, JSON.stringify(message, null, 2));\\n      this.lockManager.releaseLock(filePath);\\n    } catch (error) {\\n      this.lockManager.releaseLock(filePath);\\n      request.reject(error instanceof Error ? error : new Error('Failed to write request file'));\\n    }\\n  }\\n\\n  private setupIncomingMessageWatcher(): void {\\n    // Watch for incoming messages (this would be implemented based on the specific protocol)\\n    // For now, we'll just log that the watcher is set up\\n    this.debug('Incoming message watcher setup completed');\\n  }\\n\\n  private async ensureDirectoryExists(path: string): Promise<void> {\\n    // Platform-specific directory creation\\n    if (typeof window !== 'undefined' && window.app?.vault?.adapter?.mkdir) {\\n      // Obsidian environment\\n      try {\\n        await window.app.vault.adapter.mkdir(path);\\n      } catch (error) {\\n        // Directory might already exist\\n      }\\n    } else if (typeof (globalThis as any).require !== 'undefined') {\\n      // Node.js environment\\n      try {\\n        const fs = (globalThis as any).require('fs').promises;\\n        await fs.mkdir(path, { recursive: true });\\n      } catch (error) {\\n        // Directory might already exist\\n      }\\n    }\\n  }\\n\\n  private async writeFile(filePath: string, content: string): Promise<void> {\\n    // Platform-specific file writing\\n    if (typeof window !== 'undefined' && window.app?.vault?.adapter?.write) {\\n      // Obsidian environment\\n      return window.app.vault.adapter.write(filePath, content);\\n    } else if (typeof (globalThis as any).require !== 'undefined') {\\n      // Node.js environment\\n      const fs = (globalThis as any).require('fs').promises;\\n      return fs.writeFile(filePath, content, 'utf-8');\\n    }\\n    throw new Error('File writing not supported in this environment');\\n  }\\n\\n  private async readFile(filePath: string): Promise<string> {\\n    // Platform-specific file reading\\n    if (typeof window !== 'undefined' && window.app?.vault?.adapter?.read) {\\n      // Obsidian environment\\n      return window.app.vault.adapter.read(filePath);\\n    } else if (typeof (globalThis as any).require !== 'undefined') {\\n      // Node.js environment\\n      const fs = (globalThis as any).require('fs').promises;\\n      return fs.readFile(filePath, 'utf-8');\\n    }\\n    throw new Error('File reading not supported in this environment');\\n  }\\n\\n  protected async doHealthCheck(): Promise<void> {\\n    const testFile = `${this.devPipePath}/health_check_${Date.now()}.tmp`;\\n    \\n    try {\\n      // Test write access\\n      await this.writeFile(testFile, 'health_check');\\n      \\n      // Test read access\\n      const content = await this.readFile(testFile);\\n      if (content !== 'health_check') {\\n        throw new Error('File content mismatch during health check');\\n      }\\n      \\n      // Clean up test file\\n      await this.deleteFile(testFile);\\n      \\n    } catch (error) {\\n      throw new Error(`FileSystem health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\\n    }\\n  }\\n\\n  private async deleteFile(filePath: string): Promise<void> {\\n    // Platform-specific file deletion\\n    if (typeof window !== 'undefined' && window.app?.vault?.adapter?.remove) {\\n      // Obsidian environment\\n      try {\\n        await window.app.vault.adapter.remove(filePath);\\n      } catch (error) {\\n        // File might not exist\\n      }\\n    } else if (typeof (globalThis as any).require !== 'undefined') {\\n      // Node.js environment\\n      try {\\n        const fs = (globalThis as any).require('fs').promises;\\n        await fs.unlink(filePath);\\n      } catch (error) {\\n        // File might not exist\\n      }\\n    }\\n  }\\n\\n  getCapabilities(): TransportCapabilities {\\n    return {\\n      supportsRealtime: false,\\n      supportsBidirectional: true,\\n      supportsFileSystem: true,\\n      supportsStreaming: false,\\n      maxMessageSize: 10 * 1024 * 1024, // 10MB\\n      averageLatency: this.healthStatus.latency,\\n      maxConcurrentConnections: 1,\\n      reliability: this.calculateReliability(),\\n      supportedEnvironments: ['node', 'obsidian']\\n    };\\n  }\\n}\\n\"]}"}
