{"code":"/**\n * Development Context Service for VaultPilot\n *\n * Provides comprehensive development context for AI conversations including:\n * - Workspace structure and file analysis\n * - Active file content and metadata\n * - User selection and cursor context\n * - Project type and dependency detection\n * - Git repository information\n */\nimport { __awaiter } from \"tslib\";\nimport { TFile } from 'obsidian';\n/**\n * Main Development Context Service\n */\nexport class DevelopmentContextService {\n    constructor(app, plugin) {\n        this.contextCache = new Map();\n        this.cacheTimeout = 30000; // 30 seconds\n        this.app = app;\n        this.plugin = plugin;\n    }\n    /**\n     * Get comprehensive development context\n     */\n    getFullContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cacheKey = 'full_context';\n            const cached = this.getCachedResult(cacheKey);\n            if (cached)\n                return cached;\n            const context = {\n                workspace: yield this.getWorkspaceContext(),\n                activeFile: yield this.getActiveFileContext(),\n                selection: yield this.getSelectionContext(),\n                project: yield this.getProjectContext(),\n                git: yield this.getGitContext(),\n                timestamp: Date.now()\n            };\n            this.setCachedResult(cacheKey, context);\n            return context;\n        });\n    }\n    /**\n     * Get workspace-level context\n     */\n    getWorkspaceContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const cacheKey = 'workspace_context';\n            const cached = this.getCachedResult(cacheKey);\n            if (cached)\n                return cached;\n            const vault = this.app.vault;\n            const allFiles = vault.getMarkdownFiles();\n            // Get recent files (last 10 accessed)\n            const recentFiles = this.getRecentFiles(10);\n            // Analyze file types\n            const fileTypes = {};\n            allFiles.forEach(file => {\n                const ext = file.extension || 'md';\n                fileTypes[ext] = (fileTypes[ext] || 0) + 1;\n            });\n            // Get all tags\n            const tags = this.extractAllTags();\n            // Build folder structure\n            const folders = this.buildFolderStructure();\n            const context = {\n                totalFiles: allFiles.length,\n                recentFiles,\n                tags,\n                folders,\n                fileTypes,\n                vaultPath: vault.adapter.basePath || ((_b = (_a = vault.adapter).getName) === null || _b === void 0 ? void 0 : _b.call(_a)) || ''\n            };\n            this.setCachedResult(cacheKey, context, 60000); // Cache for 1 minute\n            return context;\n        });\n    }\n    /**\n     * Get active file context\n     */\n    getActiveFileContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const activeFile = this.app.workspace.getActiveFile();\n            if (!activeFile)\n                return null;\n            const cacheKey = `file_context_${activeFile.path}_${activeFile.stat.mtime}`;\n            const cached = this.getCachedResult(cacheKey);\n            if (cached)\n                return cached;\n            const content = yield this.app.vault.read(activeFile);\n            const metadata = this.app.metadataCache.getFileCache(activeFile);\n            const context = {\n                path: activeFile.path,\n                name: activeFile.name,\n                content,\n                language: this.detectLanguage(activeFile.extension),\n                extension: activeFile.extension,\n                size: activeFile.stat.size,\n                lastModified: activeFile.stat.mtime,\n                metadata: {\n                    frontmatter: (metadata === null || metadata === void 0 ? void 0 : metadata.frontmatter) || {},\n                    tags: this.extractTags(metadata),\n                    links: this.extractLinks(metadata),\n                    backlinks: this.getBacklinks(activeFile),\n                    headings: this.extractHeadings(metadata),\n                    wordCount: content.split(/\\s+/).length\n                },\n                symbols: yield this.extractCodeSymbols(content, activeFile.extension),\n                dependencies: yield this.extractDependencies(content, activeFile.extension)\n            };\n            this.setCachedResult(cacheKey, context);\n            return context;\n        });\n    }\n    /**\n     * Get current selection context\n     */\n    getSelectionContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const activeLeaf = this.app.workspace.activeLeaf;\n            if (!(activeLeaf === null || activeLeaf === void 0 ? void 0 : activeLeaf.view))\n                return null;\n            // Check if this is a markdown view with an editor\n            const view = activeLeaf.view;\n            if (!view.editor)\n                return null;\n            const editor = view.editor;\n            const selection = editor.getSelection();\n            if (!selection)\n                return null;\n            const selectionRange = editor.listSelections()[0];\n            const startPos = selectionRange.anchor;\n            const endPos = selectionRange.head;\n            // Ensure start is before end\n            const actualStart = startPos.line < endPos.line || (startPos.line === endPos.line && startPos.ch < endPos.ch) ? startPos : endPos;\n            const actualEnd = startPos.line > endPos.line || (startPos.line === endPos.line && startPos.ch > endPos.ch) ? startPos : endPos;\n            const line = editor.getLine(actualStart.line);\n            // Get surrounding context (5 lines before and after)\n            const contextStartLine = Math.max(0, actualStart.line - 5);\n            const contextEndLine = Math.min(editor.lineCount() - 1, actualEnd.line + 5);\n            const surroundingLines = [];\n            for (let i = contextStartLine; i <= contextEndLine; i++) {\n                surroundingLines.push(editor.getLine(i));\n            }\n            return {\n                text: selection,\n                startLine: actualStart.line,\n                endLine: actualEnd.line,\n                startCol: actualStart.ch,\n                endCol: actualEnd.ch,\n                surroundingContext: surroundingLines.join('\\n'),\n                lineContext: line\n            };\n        });\n    }\n    /**\n     * Get project context\n     */\n    getProjectContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cacheKey = 'project_context';\n            const cached = this.getCachedResult(cacheKey);\n            if (cached)\n                return cached;\n            const projectType = yield this.detectProjectType();\n            const structure = yield this.analyzeProjectStructure();\n            const dependencies = yield this.analyzeDependencies();\n            const buildSystem = yield this.detectBuildSystem();\n            const testFramework = yield this.detectTestFramework();\n            const documentation = yield this.findDocumentation();\n            const context = {\n                type: projectType,\n                structure,\n                dependencies,\n                buildSystem,\n                testFramework,\n                documentation\n            };\n            this.setCachedResult(cacheKey, context, 120000); // Cache for 2 minutes\n            return context;\n        });\n    }\n    /**\n     * Get Git context\n     */\n    getGitContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const vault = this.app.vault;\n            // Check if .git directory exists\n            const gitDir = vault.getAbstractFileByPath('.git');\n            if (!gitDir)\n                return null;\n            // Basic Git context - for full implementation, we'd need to read Git files\n            // For now, just indicate it's a Git repository\n            return {\n                isRepository: true,\n                currentBranch: 'main', // Default assumption\n                uncommittedChanges: 0, // Would need to check git status\n                lastCommit: null, // Would need to parse git log\n                remoteUrl: undefined // Would need to parse git config\n            };\n        });\n    }\n    // Caching methods\n    getCachedResult(key) {\n        const cached = this.contextCache.get(key);\n        if (!cached)\n            return null;\n        if (Date.now() - cached.timestamp > cached.timeout) {\n            this.contextCache.delete(key);\n            return null;\n        }\n        return cached.data;\n    }\n    setCachedResult(key, data, timeout = this.cacheTimeout) {\n        this.contextCache.set(key, {\n            data,\n            timestamp: Date.now(),\n            timeout\n        });\n    }\n    // Helper methods for workspace analysis\n    getRecentFiles(limit) {\n        var _a, _b;\n        const recentFiles = [];\n        const workspace = this.app.workspace;\n        // Get recent files from workspace leaf history\n        workspace.iterateAllLeaves(leaf => {\n            if (leaf.view && 'file' in leaf.view && leaf.view.file) {\n                const file = leaf.view.file;\n                const filePath = file.path;\n                if (!recentFiles.includes(filePath)) {\n                    recentFiles.push(filePath);\n                }\n            }\n        });\n        // Also check recently opened files from workspace if available\n        try {\n            const lastOpenFiles = ((_b = (_a = workspace).getLastOpenFiles) === null || _b === void 0 ? void 0 : _b.call(_a)) || [];\n            lastOpenFiles.forEach((filePath) => {\n                if (!recentFiles.includes(filePath)) {\n                    recentFiles.push(filePath);\n                }\n            });\n        }\n        catch (e) {\n            // Fallback if method doesn't exist\n        }\n        return recentFiles.slice(0, limit);\n    }\n    extractAllTags() {\n        const tags = new Set();\n        const metadataCache = this.app.metadataCache;\n        const vault = this.app.vault;\n        // Get all markdown files and extract tags from their metadata\n        vault.getMarkdownFiles().forEach(file => {\n            var _a;\n            const cache = metadataCache.getFileCache(file);\n            if (cache === null || cache === void 0 ? void 0 : cache.tags) {\n                cache.tags.forEach(tag => tags.add(tag.tag));\n            }\n            if ((_a = cache === null || cache === void 0 ? void 0 : cache.frontmatter) === null || _a === void 0 ? void 0 : _a.tags) {\n                const frontmatterTags = Array.isArray(cache.frontmatter.tags)\n                    ? cache.frontmatter.tags\n                    : [cache.frontmatter.tags];\n                frontmatterTags.forEach(tag => tags.add(tag));\n            }\n        });\n        return Array.from(tags);\n    }\n    buildFolderStructure() {\n        const folders = [];\n        const vault = this.app.vault;\n        const folderMap = new Map();\n        // Analyze all files to build folder structure\n        vault.getAllLoadedFiles().forEach(file => {\n            const pathParts = file.path.split('/');\n            if (pathParts.length > 1) {\n                // Build all folder paths in the hierarchy\n                for (let i = 1; i < pathParts.length; i++) {\n                    const folderPath = pathParts.slice(0, i).join('/');\n                    const folderName = pathParts[i - 1];\n                    if (!folderMap.has(folderPath)) {\n                        folderMap.set(folderPath, { fileCount: 0, subfolders: new Set() });\n                    }\n                    const folderInfo = folderMap.get(folderPath);\n                    // If this is the file's direct parent folder, count it\n                    if (i === pathParts.length - 1) {\n                        folderInfo.fileCount++;\n                    }\n                    // Add subfolder if there are more path parts\n                    if (i < pathParts.length - 1) {\n                        folderInfo.subfolders.add(pathParts[i]);\n                    }\n                }\n            }\n        });\n        // Convert map to folder structures\n        folderMap.forEach((info, path) => {\n            const name = path.split('/').pop() || path;\n            folders.push({\n                name,\n                path,\n                fileCount: info.fileCount,\n                subfolders: Array.from(info.subfolders)\n            });\n        });\n        return folders.sort((a, b) => a.path.localeCompare(b.path));\n    }\n    // Helper methods for file analysis\n    detectLanguage(extension) {\n        const languageMap = {\n            'ts': 'typescript',\n            'js': 'javascript',\n            'tsx': 'typescript-react',\n            'jsx': 'javascript-react',\n            'py': 'python',\n            'java': 'java',\n            'cpp': 'cpp',\n            'c': 'c',\n            'cs': 'csharp',\n            'php': 'php',\n            'rb': 'ruby',\n            'go': 'go',\n            'rs': 'rust',\n            'kt': 'kotlin',\n            'swift': 'swift',\n            'md': 'markdown',\n            'json': 'json',\n            'yaml': 'yaml',\n            'yml': 'yaml',\n            'xml': 'xml',\n            'html': 'html',\n            'css': 'css',\n            'scss': 'scss',\n            'less': 'less'\n        };\n        return languageMap[extension] || 'text';\n    }\n    extractTags(metadata) {\n        if (!(metadata === null || metadata === void 0 ? void 0 : metadata.tags))\n            return [];\n        return metadata.tags.map((tag) => tag.tag || tag);\n    }\n    extractLinks(metadata) {\n        if (!(metadata === null || metadata === void 0 ? void 0 : metadata.links))\n            return [];\n        return metadata.links.map((link) => link.link);\n    }\n    getBacklinks(file) {\n        const backlinks = [];\n        const metadataCache = this.app.metadataCache;\n        const vault = this.app.vault;\n        // Check all markdown files for links to the target file\n        vault.getMarkdownFiles().forEach(otherFile => {\n            if (otherFile.path === file.path)\n                return; // Skip self\n            const cache = metadataCache.getFileCache(otherFile);\n            if (cache === null || cache === void 0 ? void 0 : cache.links) {\n                cache.links.forEach((link) => {\n                    if (link.link === file.basename || link.link === file.path) {\n                        backlinks.push(otherFile.path);\n                    }\n                });\n            }\n        });\n        return backlinks;\n    }\n    extractHeadings(metadata) {\n        if (!(metadata === null || metadata === void 0 ? void 0 : metadata.headings))\n            return [];\n        return metadata.headings.map((heading) => {\n            var _a, _b;\n            return ({\n                level: heading.level,\n                text: heading.heading,\n                line: ((_b = (_a = heading.position) === null || _a === void 0 ? void 0 : _a.start) === null || _b === void 0 ? void 0 : _b.line) || 0\n            });\n        });\n    }\n    extractCodeSymbols(content, extension) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const symbols = [];\n            const lines = content.split('\\n');\n            // Simple symbol extraction for common languages\n            if (extension === 'ts' || extension === 'js') {\n                lines.forEach((line, index) => {\n                    // Extract functions\n                    const functionMatch = line.match(/(function|const|let|var)\\s+(\\w+)/);\n                    if (functionMatch) {\n                        symbols.push({\n                            name: functionMatch[2],\n                            type: 'function',\n                            line: index + 1,\n                            scope: 'global', // TODO: Implement proper scope detection\n                            signature: line.trim()\n                        });\n                    }\n                    // Extract classes\n                    const classMatch = line.match(/class\\s+(\\w+)/);\n                    if (classMatch) {\n                        symbols.push({\n                            name: classMatch[1],\n                            type: 'class',\n                            line: index + 1,\n                            scope: 'global',\n                            signature: line.trim()\n                        });\n                    }\n                });\n            }\n            return symbols;\n        });\n    }\n    extractDependencies(content, extension) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const dependencies = [];\n            const lines = content.split('\\n');\n            // Extract imports/requires\n            lines.forEach(line => {\n                // TypeScript/JavaScript imports\n                const importMatch = line.match(/import.*from\\s+['\"]([^'\"]+)['\"]/);\n                if (importMatch) {\n                    dependencies.push(importMatch[1]);\n                }\n                // Require statements\n                const requireMatch = line.match(/require\\(['\"]([^'\"]+)['\"]\\)/);\n                if (requireMatch) {\n                    dependencies.push(requireMatch[1]);\n                }\n                // Python imports\n                const pythonMatch = line.match(/(?:from\\s+(\\w+)|import\\s+(\\w+))/);\n                if (pythonMatch) {\n                    dependencies.push(pythonMatch[1] || pythonMatch[2]);\n                }\n            });\n            return dependencies;\n        });\n    }\n    // Project analysis methods\n    detectProjectType() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const vault = this.app.vault;\n            const files = vault.getAllLoadedFiles();\n            // Check for specific project indicators\n            const hasPackageJson = files.some(f => f.name === 'package.json');\n            const hasManifestJson = files.some(f => f.name === 'manifest.json');\n            const hasTsConfig = files.some(f => f.name === 'tsconfig.json');\n            const hasPyProject = files.some(f => f.name === 'pyproject.toml' || f.name === 'setup.py');\n            if (hasManifestJson && hasPackageJson)\n                return 'obsidian-plugin';\n            if (hasPackageJson && hasTsConfig)\n                return 'typescript-library';\n            if (hasPackageJson)\n                return 'javascript-library';\n            if (hasPyProject)\n                return 'python-package';\n            // Check for framework-specific files\n            const hasReactFiles = files.some(f => f instanceof TFile && (f.name.includes('.jsx') || f.name.includes('.tsx')));\n            if (hasReactFiles)\n                return 'react-app';\n            // Default classifications\n            const hasMarkdownFiles = files.some(f => f instanceof TFile && f.extension === 'md');\n            if (hasMarkdownFiles)\n                return 'documentation';\n            return 'unknown';\n        });\n    }\n    analyzeProjectStructure() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const vault = this.app.vault;\n            const files = vault.getAllLoadedFiles();\n            const rootFiles = [];\n            const sourceDirectories = [];\n            const testDirectories = [];\n            const configFiles = [];\n            const documentationFiles = [];\n            files.forEach(file => {\n                if (file.path.split('/').length === 1) {\n                    rootFiles.push(file.name);\n                }\n                if (file.path.includes('/src/')) {\n                    sourceDirectories.push(file.path);\n                }\n                if (file.path.includes('/test/') || file.path.includes('/__tests__/')) {\n                    testDirectories.push(file.path);\n                }\n                if (file.name.includes('config') || file.name.includes('.json') || file.name.includes('.yml')) {\n                    configFiles.push(file.path);\n                }\n                if (file instanceof TFile && (file.extension === 'md' || file.name.toLowerCase().includes('readme'))) {\n                    documentationFiles.push(file.path);\n                }\n            });\n            return {\n                rootFiles,\n                sourceDirectories,\n                testDirectories,\n                configFiles,\n                documentationFiles,\n                depth: Math.max(...files.map(f => f.path.split('/').length)),\n                estimatedSize: files.length < 50 ? 'small' : files.length < 200 ? 'medium' : 'large'\n            };\n        });\n    }\n    analyzeDependencies() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const dependencies = [];\n            const vault = this.app.vault;\n            try {\n                // Try to read package.json\n                const packageJsonFile = vault.getAbstractFileByPath('package.json');\n                if (packageJsonFile instanceof TFile) {\n                    const content = yield vault.read(packageJsonFile);\n                    const packageData = JSON.parse(content);\n                    // Parse dependencies\n                    Object.entries(packageData.dependencies || {}).forEach(([name, version]) => {\n                        dependencies.push({\n                            name,\n                            version: version,\n                            type: 'runtime',\n                            source: 'package.json'\n                        });\n                    });\n                    // Parse devDependencies\n                    Object.entries(packageData.devDependencies || {}).forEach(([name, version]) => {\n                        dependencies.push({\n                            name,\n                            version: version,\n                            type: 'dev',\n                            source: 'package.json'\n                        });\n                    });\n                    // Parse peerDependencies\n                    Object.entries(packageData.peerDependencies || {}).forEach(([name, version]) => {\n                        dependencies.push({\n                            name,\n                            version: version,\n                            type: 'peer',\n                            source: 'package.json'\n                        });\n                    });\n                }\n            }\n            catch (e) {\n                // Package.json not found or invalid, try other dependency files\n            }\n            // TODO: Add support for requirements.txt, Cargo.toml, etc.\n            return dependencies;\n        });\n    }\n    detectBuildSystem() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const vault = this.app.vault;\n            // Check for package.json (npm/yarn)\n            const packageJsonFile = vault.getAbstractFileByPath('package.json');\n            if (packageJsonFile instanceof TFile) {\n                try {\n                    const content = yield vault.read(packageJsonFile);\n                    const packageData = JSON.parse(content);\n                    const scripts = Object.keys(packageData.scripts || {});\n                    return {\n                        type: 'npm',\n                        configFile: 'package.json',\n                        scripts\n                    };\n                }\n                catch (e) {\n                    // Invalid package.json\n                }\n            }\n            // Check for other build systems\n            if (vault.getAbstractFileByPath('pom.xml')) {\n                return {\n                    type: 'maven',\n                    configFile: 'pom.xml',\n                    scripts: ['compile', 'test', 'package']\n                };\n            }\n            if (vault.getAbstractFileByPath('build.gradle')) {\n                return {\n                    type: 'gradle',\n                    configFile: 'build.gradle',\n                    scripts: ['build', 'test', 'clean']\n                };\n            }\n            if (vault.getAbstractFileByPath('CMakeLists.txt')) {\n                return {\n                    type: 'cmake',\n                    configFile: 'CMakeLists.txt',\n                    scripts: ['build', 'install']\n                };\n            }\n            if (vault.getAbstractFileByPath('Makefile')) {\n                return {\n                    type: 'make',\n                    configFile: 'Makefile',\n                    scripts: ['all', 'clean', 'install']\n                };\n            }\n            return null;\n        });\n    }\n    detectTestFramework() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const vault = this.app.vault;\n            const files = vault.getAllLoadedFiles();\n            // Check for Jest\n            if (vault.getAbstractFileByPath('jest.config.js') || vault.getAbstractFileByPath('jest.config.json')) {\n                return {\n                    type: 'jest',\n                    configFile: vault.getAbstractFileByPath('jest.config.js') ? 'jest.config.js' : 'jest.config.json',\n                    testPatterns: ['**/__tests__/**/*.test.js', '**/*.test.js', '**/*.spec.js']\n                };\n            }\n            // Check package.json for test frameworks\n            const packageJsonFile = vault.getAbstractFileByPath('package.json');\n            if (packageJsonFile instanceof TFile) {\n                try {\n                    const content = yield vault.read(packageJsonFile);\n                    const packageData = JSON.parse(content);\n                    const allDeps = Object.assign(Object.assign({}, packageData.dependencies), packageData.devDependencies);\n                    if (allDeps.jest) {\n                        return {\n                            type: 'jest',\n                            testPatterns: ['**/__tests__/**/*.test.js', '**/*.test.js', '**/*.spec.js']\n                        };\n                    }\n                    if (allDeps.mocha) {\n                        return {\n                            type: 'mocha',\n                            testPatterns: ['test/**/*.js', 'test/**/*.spec.js']\n                        };\n                    }\n                    if (allDeps.pytest) {\n                        return {\n                            type: 'pytest',\n                            testPatterns: ['test_*.py', '*_test.py', 'tests/**/*.py']\n                        };\n                    }\n                }\n                catch (e) {\n                    // Invalid package.json\n                }\n            }\n            // Check for Python test files\n            const hasPytestFiles = files.some(f => f instanceof TFile &&\n                (f.name.startsWith('test_') || f.name.endsWith('_test.py')));\n            if (hasPytestFiles) {\n                return {\n                    type: 'pytest',\n                    testPatterns: ['test_*.py', '*_test.py', 'tests/**/*.py']\n                };\n            }\n            // Check for JUnit\n            const hasJunitFiles = files.some(f => f instanceof TFile &&\n                f.name.includes('Test.java'));\n            if (hasJunitFiles) {\n                return {\n                    type: 'junit',\n                    testPatterns: ['**/*Test.java', '**/Test*.java']\n                };\n            }\n            return null;\n        });\n    }\n    findDocumentation() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const vault = this.app.vault;\n            const files = vault.getAllLoadedFiles();\n            const docs = [];\n            files.forEach(file => {\n                if (!(file instanceof TFile))\n                    return;\n                if (file.name.toLowerCase().includes('readme')) {\n                    docs.push({\n                        type: 'readme',\n                        path: file.path,\n                        lastUpdated: file.stat.mtime\n                    });\n                }\n                if (file.name.toLowerCase().includes('changelog')) {\n                    docs.push({\n                        type: 'changelog',\n                        path: file.path,\n                        lastUpdated: file.stat.mtime\n                    });\n                }\n                if (file.name.toLowerCase().includes('license')) {\n                    docs.push({\n                        type: 'license',\n                        path: file.path,\n                        lastUpdated: file.stat.mtime\n                    });\n                }\n            });\n            return docs;\n        });\n    }\n    /**\n     * Clear all cached context data\n     */\n    clearCache() {\n        this.contextCache.clear();\n    }\n    /**\n     * Get context summary for chat\n     */\n    getContextSummary() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const context = yield this.getFullContext();\n            let summary = `## Development Context\\n\\n`;\n            // Workspace info\n            summary += `**Workspace**: ${context.workspace.totalFiles} files, ${context.workspace.folders.length} folders\\n`;\n            // Active file info\n            if (context.activeFile) {\n                summary += `**Active File**: ${context.activeFile.name} (${context.activeFile.language})\\n`;\n                summary += `**File Size**: ${Math.round(context.activeFile.size / 1024)}KB, ${context.activeFile.metadata.wordCount} words\\n`;\n                if (context.activeFile.symbols.length > 0) {\n                    summary += `**Code Symbols**: ${context.activeFile.symbols.length} found\\n`;\n                }\n            }\n            // Project info\n            summary += `**Project Type**: ${context.project.type}\\n`;\n            summary += `**Project Size**: ${context.project.structure.estimatedSize}\\n`;\n            // Selection info\n            if (context.selection) {\n                summary += `**Current Selection**: \"${context.selection.text.substring(0, 50)}${context.selection.text.length > 50 ? '...' : ''}\"\\n`;\n            }\n            return summary;\n        });\n    }\n}\n//# sourceMappingURL=DevelopmentContextService.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/node_modules/obsidian/obsidian.d.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/main.ts"],"map":"{\"version\":3,\"file\":\"DevelopmentContextService.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/services/DevelopmentContextService.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;;;;GASG;;AAEH,OAAO,EAAO,KAAK,EAAmC,MAAM,UAAU,CAAC;AAgJvE;;GAEG;AACH,MAAM,OAAO,yBAAyB;IAMpC,YAAY,GAAQ,EAAE,MAAwB;QAHtC,iBAAY,GAAqB,IAAI,GAAG,EAAE,CAAC;QAC3C,iBAAY,GAAG,KAAK,CAAC,CAAC,aAAa;QAGzC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAED;;OAEG;IACG,cAAc;;YAClB,MAAM,QAAQ,GAAG,cAAc,CAAC;YAChC,MAAM,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAC9C,IAAI,MAAM;gBAAE,OAAO,MAAM,CAAC;YAE1B,MAAM,OAAO,GAAuB;gBAClC,SAAS,EAAE,MAAM,IAAI,CAAC,mBAAmB,EAAE;gBAC3C,UAAU,EAAE,MAAM,IAAI,CAAC,oBAAoB,EAAE;gBAC7C,SAAS,EAAE,MAAM,IAAI,CAAC,mBAAmB,EAAE;gBAC3C,OAAO,EAAE,MAAM,IAAI,CAAC,iBAAiB,EAAE;gBACvC,GAAG,EAAE,MAAM,IAAI,CAAC,aAAa,EAAE;gBAC/B,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;aACtB,CAAC;YAEF,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACxC,OAAO,OAAO,CAAC;QACjB,CAAC;KAAA;IAED;;OAEG;IACG,mBAAmB;;;YACvB,MAAM,QAAQ,GAAG,mBAAmB,CAAC;YACrC,MAAM,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAC9C,IAAI,MAAM;gBAAE,OAAO,MAAM,CAAC;YAE1B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAC7B,MAAM,QAAQ,GAAG,KAAK,CAAC,gBAAgB,EAAE,CAAC;YAE1C,sCAAsC;YACtC,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;YAE5C,qBAAqB;YACrB,MAAM,SAAS,GAA2B,EAAE,CAAC;YAC7C,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACtB,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC;gBACnC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;YAC7C,CAAC,CAAC,CAAC;YAEH,eAAe;YACf,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;YAEnC,yBAAyB;YACzB,MAAM,OAAO,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAE5C,MAAM,OAAO,GAAqB;gBAChC,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,WAAW;gBACX,IAAI;gBACJ,OAAO;gBACP,SAAS;gBACT,SAAS,EAAG,KAAK,CAAC,OAAe,CAAC,QAAQ,KAAI,MAAA,MAAA,KAAK,CAAC,OAAO,EAAC,OAAO,kDAAI,CAAA,IAAI,EAAE;aAC9E,CAAC;YAEF,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC,qBAAqB;YACrE,OAAO,OAAO,CAAC;QACjB,CAAC;KAAA;IAED;;OAEG;IACG,oBAAoB;;YACxB,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,aAAa,EAAE,CAAC;YACtD,IAAI,CAAC,UAAU;gBAAE,OAAO,IAAI,CAAC;YAE7B,MAAM,QAAQ,GAAG,gBAAgB,UAAU,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;YAC5E,MAAM,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAC9C,IAAI,MAAM;gBAAE,OAAO,MAAM,CAAC;YAE1B,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACtD,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;YAEjE,MAAM,OAAO,GAAgB;gBAC3B,IAAI,EAAE,UAAU,CAAC,IAAI;gBACrB,IAAI,EAAE,UAAU,CAAC,IAAI;gBACrB,OAAO;gBACP,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,SAAS,CAAC;gBACnD,SAAS,EAAE,UAAU,CAAC,SAAS;gBAC/B,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,IAAI;gBAC1B,YAAY,EAAE,UAAU,CAAC,IAAI,CAAC,KAAK;gBACnC,QAAQ,EAAE;oBACR,WAAW,EAAE,CAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,WAAW,KAAI,EAAE;oBACxC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC;oBAChC,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;oBAClC,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC;oBACxC,QAAQ,EAAE,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC;oBACxC,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,MAAM;iBACvC;gBACD,OAAO,EAAE,MAAM,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,UAAU,CAAC,SAAS,CAAC;gBACrE,YAAY,EAAE,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,UAAU,CAAC,SAAS,CAAC;aAC5E,CAAC;YAEF,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACxC,OAAO,OAAO,CAAC;QACjB,CAAC;KAAA;IAED;;OAEG;IACG,mBAAmB;;YACvB,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,UAAU,CAAC;YACjD,IAAI,CAAC,CAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,IAAI,CAAA;gBAAE,OAAO,IAAI,CAAC;YAEnC,kDAAkD;YAClD,MAAM,IAAI,GAAG,UAAU,CAAC,IAAW,CAAC;YACpC,IAAI,CAAC,IAAI,CAAC,MAAM;gBAAE,OAAO,IAAI,CAAC;YAE9B,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,MAAM,SAAS,GAAG,MAAM,CAAC,YAAY,EAAE,CAAC;YAExC,IAAI,CAAC,SAAS;gBAAE,OAAO,IAAI,CAAC;YAE5B,MAAM,cAAc,GAAG,MAAM,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,CAAC;YAClD,MAAM,QAAQ,GAAG,cAAc,CAAC,MAAM,CAAC;YACvC,MAAM,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC;YAEnC,6BAA6B;YAC7B,MAAM,WAAW,GAAG,QAAQ,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,IAAI,QAAQ,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC;YAClI,MAAM,SAAS,GAAG,QAAQ,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,IAAI,QAAQ,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC;YAEhI,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YAE9C,qDAAqD;YACrD,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;YAC3D,MAAM,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS,EAAE,GAAG,CAAC,EAAE,SAAS,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;YAC5E,MAAM,gBAAgB,GAAG,EAAE,CAAC;YAE5B,KAAK,IAAI,CAAC,GAAG,gBAAgB,EAAE,CAAC,IAAI,cAAc,EAAE,CAAC,EAAE,EAAE,CAAC;gBACxD,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3C,CAAC;YAED,OAAO;gBACL,IAAI,EAAE,SAAS;gBACf,SAAS,EAAE,WAAW,CAAC,IAAI;gBAC3B,OAAO,EAAE,SAAS,CAAC,IAAI;gBACvB,QAAQ,EAAE,WAAW,CAAC,EAAE;gBACxB,MAAM,EAAE,SAAS,CAAC,EAAE;gBACpB,kBAAkB,EAAE,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC/C,WAAW,EAAE,IAAI;aAClB,CAAC;QACJ,CAAC;KAAA;IAED;;OAEG;IACG,iBAAiB;;YACrB,MAAM,QAAQ,GAAG,iBAAiB,CAAC;YACnC,MAAM,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAC9C,IAAI,MAAM;gBAAE,OAAO,MAAM,CAAC;YAE1B,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACnD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAC;YACvD,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACtD,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACnD,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACvD,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAErD,MAAM,OAAO,GAAmB;gBAC9B,IAAI,EAAE,WAAW;gBACjB,SAAS;gBACT,YAAY;gBACZ,WAAW;gBACX,aAAa;gBACb,aAAa;aACd,CAAC;YAEF,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC,sBAAsB;YACvE,OAAO,OAAO,CAAC;QACjB,CAAC;KAAA;IAED;;OAEG;IACG,aAAa;;YACjB,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAE7B,iCAAiC;YACjC,MAAM,MAAM,GAAG,KAAK,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;YACnD,IAAI,CAAC,MAAM;gBAAE,OAAO,IAAI,CAAC;YAEzB,2EAA2E;YAC3E,+CAA+C;YAC/C,OAAO;gBACL,YAAY,EAAE,IAAI;gBAClB,aAAa,EAAE,MAAM,EAAE,qBAAqB;gBAC5C,kBAAkB,EAAE,CAAC,EAAE,iCAAiC;gBACxD,UAAU,EAAE,IAAI,EAAE,8BAA8B;gBAChD,SAAS,EAAE,SAAS,CAAC,iCAAiC;aACvD,CAAC;QACJ,CAAC;KAAA;IAED,kBAAkB;IACV,eAAe,CAAC,GAAW;QACjC,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,OAAO,IAAI,CAAC;QAEzB,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,MAAM,CAAC,SAAS,GAAG,MAAM,CAAC,OAAO,EAAE,CAAC;YACnD,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAC9B,OAAO,IAAI,CAAC;QACd,CAAC;QAED,OAAO,MAAM,CAAC,IAAI,CAAC;IACrB,CAAC;IAEO,eAAe,CAAC,GAAW,EAAE,IAAS,EAAE,OAAO,GAAG,IAAI,CAAC,YAAY;QACzE,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE;YACzB,IAAI;YACJ,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,OAAO;SACR,CAAC,CAAC;IACL,CAAC;IAED,wCAAwC;IAChC,cAAc,CAAC,KAAa;;QAClC,MAAM,WAAW,GAAa,EAAE,CAAC;QACjC,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC;QAErC,+CAA+C;QAC/C,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;YAChC,IAAI,IAAI,CAAC,IAAI,IAAI,MAAM,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;gBACvD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAa,CAAC;gBACrC,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;gBAC3B,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;oBACpC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC7B,CAAC;YACH,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,+DAA+D;QAC/D,IAAI,CAAC;YACH,MAAM,aAAa,GAAG,CAAA,MAAA,MAAC,SAAiB,EAAC,gBAAgB,kDAAI,KAAI,EAAE,CAAC;YACpE,aAAa,CAAC,OAAO,CAAC,CAAC,QAAgB,EAAE,EAAE;gBACzC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;oBACpC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC7B,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACX,mCAAmC;QACrC,CAAC;QAED,OAAO,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IACrC,CAAC;IAEO,cAAc;QACpB,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;QAC/B,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC;QAC7C,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;QAE7B,8DAA8D;QAC9D,KAAK,CAAC,gBAAgB,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;;YACtC,MAAM,KAAK,GAAG,aAAa,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAC/C,IAAI,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,IAAI,EAAE,CAAC;gBAChB,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;YAC/C,CAAC;YACD,IAAI,MAAA,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,WAAW,0CAAE,IAAI,EAAE,CAAC;gBAC7B,MAAM,eAAe,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC;oBAC3D,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI;oBACxB,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC7B,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;YAChD,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;IAEO,oBAAoB;QAC1B,MAAM,OAAO,GAAsB,EAAE,CAAC;QACtC,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;QAC7B,MAAM,SAAS,GAAG,IAAI,GAAG,EAA0D,CAAC;QAEpF,8CAA8C;QAC9C,KAAK,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACvC,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YACvC,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACzB,0CAA0C;gBAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC1C,MAAM,UAAU,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACnD,MAAM,UAAU,GAAG,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBAEpC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC;wBAC/B,SAAS,CAAC,GAAG,CAAC,UAAU,EAAE,EAAE,SAAS,EAAE,CAAC,EAAE,UAAU,EAAE,IAAI,GAAG,EAAE,EAAE,CAAC,CAAC;oBACrE,CAAC;oBAED,MAAM,UAAU,GAAG,SAAS,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC;oBAE9C,uDAAuD;oBACvD,IAAI,CAAC,KAAK,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBAC/B,UAAU,CAAC,SAAS,EAAE,CAAC;oBACzB,CAAC;oBAED,6CAA6C;oBAC7C,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;wBAC7B,UAAU,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC1C,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,mCAAmC;QACnC,SAAS,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE;YAC/B,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC;YAC3C,OAAO,CAAC,IAAI,CAAC;gBACX,IAAI;gBACJ,IAAI;gBACJ,SAAS,EAAE,IAAI,CAAC,SAAS;gBACzB,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;aACxC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IAC9D,CAAC;IAED,mCAAmC;IAC3B,cAAc,CAAC,SAAiB;QACtC,MAAM,WAAW,GAA2B;YAC1C,IAAI,EAAE,YAAY;YAClB,IAAI,EAAE,YAAY;YAClB,KAAK,EAAE,kBAAkB;YACzB,KAAK,EAAE,kBAAkB;YACzB,IAAI,EAAE,QAAQ;YACd,MAAM,EAAE,MAAM;YACd,KAAK,EAAE,KAAK;YACZ,GAAG,EAAE,GAAG;YACR,IAAI,EAAE,QAAQ;YACd,KAAK,EAAE,KAAK;YACZ,IAAI,EAAE,MAAM;YACZ,IAAI,EAAE,IAAI;YACV,IAAI,EAAE,MAAM;YACZ,IAAI,EAAE,QAAQ;YACd,OAAO,EAAE,OAAO;YAChB,IAAI,EAAE,UAAU;YAChB,MAAM,EAAE,MAAM;YACd,MAAM,EAAE,MAAM;YACd,KAAK,EAAE,MAAM;YACb,KAAK,EAAE,KAAK;YACZ,MAAM,EAAE,MAAM;YACd,KAAK,EAAE,KAAK;YACZ,MAAM,EAAE,MAAM;YACd,MAAM,EAAE,MAAM;SACf,CAAC;QAEF,OAAO,WAAW,CAAC,SAAS,CAAC,IAAI,MAAM,CAAC;IAC1C,CAAC;IAEO,WAAW,CAAC,QAAa;QAC/B,IAAI,CAAC,CAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,IAAI,CAAA;YAAE,OAAO,EAAE,CAAC;QAC/B,OAAO,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAQ,EAAE,EAAE,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC;IACzD,CAAC;IAEO,YAAY,CAAC,QAAa;QAChC,IAAI,CAAC,CAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,KAAK,CAAA;YAAE,OAAO,EAAE,CAAC;QAChC,OAAO,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAS,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACtD,CAAC;IAEO,YAAY,CAAC,IAAW;QAC9B,MAAM,SAAS,GAAa,EAAE,CAAC;QAC/B,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC;QAC7C,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;QAE7B,wDAAwD;QACxD,KAAK,CAAC,gBAAgB,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;YAC3C,IAAI,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI;gBAAE,OAAO,CAAC,YAAY;YAEtD,MAAM,KAAK,GAAG,aAAa,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;YACpD,IAAI,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,KAAK,EAAE,CAAC;gBACjB,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAS,EAAE,EAAE;oBAChC,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE,CAAC;wBAC3D,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;oBACjC,CAAC;gBACH,CAAC,CAAC,CAAC;YACL,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,SAAS,CAAC;IACnB,CAAC;IAEO,eAAe,CAAC,QAAa;QACnC,IAAI,CAAC,CAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,QAAQ,CAAA;YAAE,OAAO,EAAE,CAAC;QAEnC,OAAO,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAY,EAAE,EAAE;;YAAC,OAAA,CAAC;gBAC9C,KAAK,EAAE,OAAO,CAAC,KAAK;gBACpB,IAAI,EAAE,OAAO,CAAC,OAAO;gBACrB,IAAI,EAAE,CAAA,MAAA,MAAA,OAAO,CAAC,QAAQ,0CAAE,KAAK,0CAAE,IAAI,KAAI,CAAC;aACzC,CAAC,CAAA;SAAA,CAAC,CAAC;IACN,CAAC;IAEa,kBAAkB,CAAC,OAAe,EAAE,SAAiB;;YACjE,MAAM,OAAO,GAAiB,EAAE,CAAC;YACjC,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAElC,gDAAgD;YAChD,IAAI,SAAS,KAAK,IAAI,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;gBAC7C,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;oBAC5B,oBAAoB;oBACpB,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,kCAAkC,CAAC,CAAC;oBACrE,IAAI,aAAa,EAAE,CAAC;wBAClB,OAAO,CAAC,IAAI,CAAC;4BACX,IAAI,EAAE,aAAa,CAAC,CAAC,CAAC;4BACtB,IAAI,EAAE,UAAU;4BAChB,IAAI,EAAE,KAAK,GAAG,CAAC;4BACf,KAAK,EAAE,QAAQ,EAAE,yCAAyC;4BAC1D,SAAS,EAAE,IAAI,CAAC,IAAI,EAAE;yBACvB,CAAC,CAAC;oBACL,CAAC;oBAED,kBAAkB;oBAClB,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;oBAC/C,IAAI,UAAU,EAAE,CAAC;wBACf,OAAO,CAAC,IAAI,CAAC;4BACX,IAAI,EAAE,UAAU,CAAC,CAAC,CAAC;4BACnB,IAAI,EAAE,OAAO;4BACb,IAAI,EAAE,KAAK,GAAG,CAAC;4BACf,KAAK,EAAE,QAAQ;4BACf,SAAS,EAAE,IAAI,CAAC,IAAI,EAAE;yBACvB,CAAC,CAAC;oBACL,CAAC;gBACH,CAAC,CAAC,CAAC;YACL,CAAC;YAED,OAAO,OAAO,CAAC;QACjB,CAAC;KAAA;IAEa,mBAAmB,CAAC,OAAe,EAAE,SAAiB;;YAClE,MAAM,YAAY,GAAa,EAAE,CAAC;YAClC,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAElC,2BAA2B;YAC3B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACnB,gCAAgC;gBAChC,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,iCAAiC,CAAC,CAAC;gBAClE,IAAI,WAAW,EAAE,CAAC;oBAChB,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpC,CAAC;gBAED,qBAAqB;gBACrB,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC,CAAC;gBAC/D,IAAI,YAAY,EAAE,CAAC;oBACjB,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrC,CAAC;gBAED,iBAAiB;gBACjB,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,iCAAiC,CAAC,CAAC;gBAClE,IAAI,WAAW,EAAE,CAAC;oBAChB,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtD,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,OAAO,YAAY,CAAC;QACtB,CAAC;KAAA;IAED,2BAA2B;IACb,iBAAiB;;YAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAC7B,MAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,EAAE,CAAC;YAExC,wCAAwC;YACxC,MAAM,cAAc,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,cAAc,CAAC,CAAC;YAClE,MAAM,eAAe,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,eAAe,CAAC,CAAC;YACpE,MAAM,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,eAAe,CAAC,CAAC;YAChE,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,gBAAgB,IAAI,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC;YAE3F,IAAI,eAAe,IAAI,cAAc;gBAAE,OAAO,iBAAiB,CAAC;YAChE,IAAI,cAAc,IAAI,WAAW;gBAAE,OAAO,oBAAoB,CAAC;YAC/D,IAAI,cAAc;gBAAE,OAAO,oBAAoB,CAAC;YAChD,IAAI,YAAY;gBAAE,OAAO,gBAAgB,CAAC;YAE1C,qCAAqC;YACrC,MAAM,aAAa,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CACnC,CAAC,YAAY,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAC3E,CAAC;YACF,IAAI,aAAa;gBAAE,OAAO,WAAW,CAAC;YAEtC,0BAA0B;YAC1B,MAAM,gBAAgB,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,YAAY,KAAK,IAAI,CAAC,CAAC,SAAS,KAAK,IAAI,CAAC,CAAC;YACrF,IAAI,gBAAgB;gBAAE,OAAO,eAAe,CAAC;YAE7C,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAEa,uBAAuB;;YACnC,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAC7B,MAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,EAAE,CAAC;YAExC,MAAM,SAAS,GAAa,EAAE,CAAC;YAC/B,MAAM,iBAAiB,GAAa,EAAE,CAAC;YACvC,MAAM,eAAe,GAAa,EAAE,CAAC;YACrC,MAAM,WAAW,GAAa,EAAE,CAAC;YACjC,MAAM,kBAAkB,GAAa,EAAE,CAAC;YAExC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACnB,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACtC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC5B,CAAC;gBAED,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC;oBAChC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACpC,CAAC;gBAED,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE,CAAC;oBACtE,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAClC,CAAC;gBAED,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;oBAC9F,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC9B,CAAC;gBAED,IAAI,IAAI,YAAY,KAAK,IAAI,CAAC,IAAI,CAAC,SAAS,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC;oBACrG,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACrC,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,OAAO;gBACL,SAAS;gBACT,iBAAiB;gBACjB,eAAe;gBACf,WAAW;gBACX,kBAAkB;gBAClB,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC;gBAC5D,aAAa,EAAE,KAAK,CAAC,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO;aACrF,CAAC;QACJ,CAAC;KAAA;IAEa,mBAAmB;;YAC/B,MAAM,YAAY,GAAqB,EAAE,CAAC;YAC1C,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAE7B,IAAI,CAAC;gBACH,2BAA2B;gBAC3B,MAAM,eAAe,GAAG,KAAK,CAAC,qBAAqB,CAAC,cAAc,CAAC,CAAC;gBACpE,IAAI,eAAe,YAAY,KAAK,EAAE,CAAC;oBACrC,MAAM,OAAO,GAAG,MAAM,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;oBAClD,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;oBAExC,qBAAqB;oBACrB,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,YAAY,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,EAAE;wBACzE,YAAY,CAAC,IAAI,CAAC;4BAChB,IAAI;4BACJ,OAAO,EAAE,OAAiB;4BAC1B,IAAI,EAAE,SAAS;4BACf,MAAM,EAAE,cAAc;yBACvB,CAAC,CAAC;oBACL,CAAC,CAAC,CAAC;oBAEH,wBAAwB;oBACxB,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,eAAe,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,EAAE;wBAC5E,YAAY,CAAC,IAAI,CAAC;4BAChB,IAAI;4BACJ,OAAO,EAAE,OAAiB;4BAC1B,IAAI,EAAE,KAAK;4BACX,MAAM,EAAE,cAAc;yBACvB,CAAC,CAAC;oBACL,CAAC,CAAC,CAAC;oBAEH,yBAAyB;oBACzB,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,gBAAgB,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE,EAAE;wBAC7E,YAAY,CAAC,IAAI,CAAC;4BAChB,IAAI;4BACJ,OAAO,EAAE,OAAiB;4BAC1B,IAAI,EAAE,MAAM;4BACZ,MAAM,EAAE,cAAc;yBACvB,CAAC,CAAC;oBACL,CAAC,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACX,gEAAgE;YAClE,CAAC;YAED,2DAA2D;YAE3D,OAAO,YAAY,CAAC;QACtB,CAAC;KAAA;IAEa,iBAAiB;;YAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAE7B,oCAAoC;YACpC,MAAM,eAAe,GAAG,KAAK,CAAC,qBAAqB,CAAC,cAAc,CAAC,CAAC;YACpE,IAAI,eAAe,YAAY,KAAK,EAAE,CAAC;gBACrC,IAAI,CAAC;oBACH,MAAM,OAAO,GAAG,MAAM,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;oBAClD,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;oBACxC,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;oBAEvD,OAAO;wBACL,IAAI,EAAE,KAAK;wBACX,UAAU,EAAE,cAAc;wBAC1B,OAAO;qBACR,CAAC;gBACJ,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACX,uBAAuB;gBACzB,CAAC;YACH,CAAC;YAED,gCAAgC;YAChC,IAAI,KAAK,CAAC,qBAAqB,CAAC,SAAS,CAAC,EAAE,CAAC;gBAC3C,OAAO;oBACL,IAAI,EAAE,OAAO;oBACb,UAAU,EAAE,SAAS;oBACrB,OAAO,EAAE,CAAC,SAAS,EAAE,MAAM,EAAE,SAAS,CAAC;iBACxC,CAAC;YACJ,CAAC;YAED,IAAI,KAAK,CAAC,qBAAqB,CAAC,cAAc,CAAC,EAAE,CAAC;gBAChD,OAAO;oBACL,IAAI,EAAE,QAAQ;oBACd,UAAU,EAAE,cAAc;oBAC1B,OAAO,EAAE,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC;iBACpC,CAAC;YACJ,CAAC;YAED,IAAI,KAAK,CAAC,qBAAqB,CAAC,gBAAgB,CAAC,EAAE,CAAC;gBAClD,OAAO;oBACL,IAAI,EAAE,OAAO;oBACb,UAAU,EAAE,gBAAgB;oBAC5B,OAAO,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC;iBAC9B,CAAC;YACJ,CAAC;YAED,IAAI,KAAK,CAAC,qBAAqB,CAAC,UAAU,CAAC,EAAE,CAAC;gBAC5C,OAAO;oBACL,IAAI,EAAE,MAAM;oBACZ,UAAU,EAAE,UAAU;oBACtB,OAAO,EAAE,CAAC,KAAK,EAAE,OAAO,EAAE,SAAS,CAAC;iBACrC,CAAC;YACJ,CAAC;YAED,OAAO,IAAI,CAAC;QACd,CAAC;KAAA;IAEa,mBAAmB;;YAC/B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAC7B,MAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,EAAE,CAAC;YAExC,iBAAiB;YACjB,IAAI,KAAK,CAAC,qBAAqB,CAAC,gBAAgB,CAAC,IAAI,KAAK,CAAC,qBAAqB,CAAC,kBAAkB,CAAC,EAAE,CAAC;gBACrG,OAAO;oBACL,IAAI,EAAE,MAAM;oBACZ,UAAU,EAAE,KAAK,CAAC,qBAAqB,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,kBAAkB;oBACjG,YAAY,EAAE,CAAC,2BAA2B,EAAE,cAAc,EAAE,cAAc,CAAC;iBAC5E,CAAC;YACJ,CAAC;YAED,yCAAyC;YACzC,MAAM,eAAe,GAAG,KAAK,CAAC,qBAAqB,CAAC,cAAc,CAAC,CAAC;YACpE,IAAI,eAAe,YAAY,KAAK,EAAE,CAAC;gBACrC,IAAI,CAAC;oBACH,MAAM,OAAO,GAAG,MAAM,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;oBAClD,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;oBACxC,MAAM,OAAO,mCACR,WAAW,CAAC,YAAY,GACxB,WAAW,CAAC,eAAe,CAC/B,CAAC;oBAEF,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;wBACjB,OAAO;4BACL,IAAI,EAAE,MAAM;4BACZ,YAAY,EAAE,CAAC,2BAA2B,EAAE,cAAc,EAAE,cAAc,CAAC;yBAC5E,CAAC;oBACJ,CAAC;oBAED,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;wBAClB,OAAO;4BACL,IAAI,EAAE,OAAO;4BACb,YAAY,EAAE,CAAC,cAAc,EAAE,mBAAmB,CAAC;yBACpD,CAAC;oBACJ,CAAC;oBAED,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;wBACnB,OAAO;4BACL,IAAI,EAAE,QAAQ;4BACd,YAAY,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,eAAe,CAAC;yBAC1D,CAAC;oBACJ,CAAC;gBACH,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACX,uBAAuB;gBACzB,CAAC;YACH,CAAC;YAED,8BAA8B;YAC9B,MAAM,cAAc,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CACpC,CAAC,YAAY,KAAK;gBAClB,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAC5D,CAAC;YACF,IAAI,cAAc,EAAE,CAAC;gBACnB,OAAO;oBACL,IAAI,EAAE,QAAQ;oBACd,YAAY,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,eAAe,CAAC;iBAC1D,CAAC;YACJ,CAAC;YAED,kBAAkB;YAClB,MAAM,aAAa,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CACnC,CAAC,YAAY,KAAK;gBAClB,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAC7B,CAAC;YACF,IAAI,aAAa,EAAE,CAAC;gBAClB,OAAO;oBACL,IAAI,EAAE,OAAO;oBACb,YAAY,EAAE,CAAC,eAAe,EAAE,eAAe,CAAC;iBACjD,CAAC;YACJ,CAAC;YAED,OAAO,IAAI,CAAC;QACd,CAAC;KAAA;IAEa,iBAAiB;;YAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YAC7B,MAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,EAAE,CAAC;YACxC,MAAM,IAAI,GAAwB,EAAE,CAAC;YAErC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACnB,IAAI,CAAC,CAAC,IAAI,YAAY,KAAK,CAAC;oBAAE,OAAO;gBAErC,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;oBAC/C,IAAI,CAAC,IAAI,CAAC;wBACR,IAAI,EAAE,QAAQ;wBACd,IAAI,EAAE,IAAI,CAAC,IAAI;wBACf,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK;qBAC7B,CAAC,CAAC;gBACL,CAAC;gBAED,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;oBAClD,IAAI,CAAC,IAAI,CAAC;wBACR,IAAI,EAAE,WAAW;wBACjB,IAAI,EAAE,IAAI,CAAC,IAAI;wBACf,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK;qBAC7B,CAAC,CAAC;gBACL,CAAC;gBAED,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;oBAChD,IAAI,CAAC,IAAI,CAAC;wBACR,IAAI,EAAE,SAAS;wBACf,IAAI,EAAE,IAAI,CAAC,IAAI;wBACf,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK;qBAC7B,CAAC,CAAC;gBACL,CAAC;YACH,CAAC,CAAC,CAAC;YAEH,OAAO,IAAI,CAAC;QACd,CAAC;KAAA;IAED;;OAEG;IACI,UAAU;QACf,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;IAC5B,CAAC;IAED;;OAEG;IACG,iBAAiB;;YACrB,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;YAE5C,IAAI,OAAO,GAAG,4BAA4B,CAAC;YAE3C,iBAAiB;YACjB,OAAO,IAAI,kBAAkB,OAAO,CAAC,SAAS,CAAC,UAAU,WAAW,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,YAAY,CAAC;YAEjH,mBAAmB;YACnB,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;gBACvB,OAAO,IAAI,oBAAoB,OAAO,CAAC,UAAU,CAAC,IAAI,KAAK,OAAO,CAAC,UAAU,CAAC,QAAQ,KAAK,CAAC;gBAC5F,OAAO,IAAI,kBAAkB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,SAAS,UAAU,CAAC;gBAE9H,IAAI,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAC1C,OAAO,IAAI,qBAAqB,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,UAAU,CAAC;gBAC9E,CAAC;YACH,CAAC;YAED,eAAe;YACf,OAAO,IAAI,qBAAqB,OAAO,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC;YACzD,OAAO,IAAI,qBAAqB,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,aAAa,IAAI,CAAC;YAE5E,iBAAiB;YACjB,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;gBACtB,OAAO,IAAI,2BAA2B,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;YACvI,CAAC;YAED,OAAO,OAAO,CAAC;QACjB,CAAC;KAAA;CACF\",\"sourcesContent\":[\"/**\\n * Development Context Service for VaultPilot\\n * \\n * Provides comprehensive development context for AI conversations including:\\n * - Workspace structure and file analysis\\n * - Active file content and metadata\\n * - User selection and cursor context\\n * - Project type and dependency detection\\n * - Git repository information\\n */\\n\\nimport { App, TFile, Vault, MetadataCache, Workspace } from 'obsidian';\\nimport type VaultPilotPlugin from '../main';\\n\\n// Context Interfaces\\nexport interface DevelopmentContext {\\n  workspace: WorkspaceContext;\\n  activeFile: FileContext | null;\\n  selection: SelectionContext | null;\\n  project: ProjectContext;\\n  git: GitContext | null;\\n  timestamp: number;\\n}\\n\\nexport interface WorkspaceContext {\\n  totalFiles: number;\\n  recentFiles: string[];\\n  tags: string[];\\n  folders: FolderStructure[];\\n  fileTypes: Record<string, number>;\\n  vaultPath: string;\\n}\\n\\nexport interface FileContext {\\n  path: string;\\n  name: string;\\n  content: string;\\n  language: string;\\n  extension: string;\\n  size: number;\\n  metadata: FileMetadata;\\n  symbols: CodeSymbol[];\\n  dependencies: string[];\\n  lastModified: number;\\n}\\n\\nexport interface FileMetadata {\\n  frontmatter: Record<string, any>;\\n  tags: string[];\\n  links: string[];\\n  backlinks: string[];\\n  headings: HeadingInfo[];\\n  wordCount: number;\\n}\\n\\nexport interface HeadingInfo {\\n  level: number;\\n  text: string;\\n  line: number;\\n}\\n\\nexport interface SelectionContext {\\n  text: string;\\n  startLine: number;\\n  endLine: number;\\n  startCol: number;\\n  endCol: number;\\n  surroundingContext: string;\\n  lineContext: string;\\n}\\n\\nexport interface CodeSymbol {\\n  name: string;\\n  type: 'function' | 'class' | 'variable' | 'interface' | 'type' | 'constant';\\n  line: number;\\n  scope: string;\\n  signature?: string;\\n}\\n\\nexport interface ProjectContext {\\n  type: ProjectType;\\n  structure: ProjectStructure;\\n  dependencies: DependencyInfo[];\\n  buildSystem: BuildSystemInfo | null;\\n  testFramework: TestFrameworkInfo | null;\\n  documentation: DocumentationInfo[];\\n}\\n\\nexport interface ProjectStructure {\\n  rootFiles: string[];\\n  sourceDirectories: string[];\\n  testDirectories: string[];\\n  configFiles: string[];\\n  documentationFiles: string[];\\n  depth: number;\\n  estimatedSize: 'small' | 'medium' | 'large';\\n}\\n\\nexport interface DependencyInfo {\\n  name: string;\\n  version?: string;\\n  type: 'dev' | 'runtime' | 'peer';\\n  source: string;\\n}\\n\\nexport interface BuildSystemInfo {\\n  type: 'npm' | 'yarn' | 'maven' | 'gradle' | 'cmake' | 'make' | 'other';\\n  configFile: string;\\n  scripts: string[];\\n}\\n\\nexport interface TestFrameworkInfo {\\n  type: 'jest' | 'mocha' | 'pytest' | 'junit' | 'other';\\n  configFile?: string;\\n  testPatterns: string[];\\n}\\n\\nexport interface DocumentationInfo {\\n  type: 'readme' | 'api' | 'guide' | 'changelog' | 'license';\\n  path: string;\\n  lastUpdated: number;\\n}\\n\\nexport interface FolderStructure {\\n  name: string;\\n  path: string;\\n  fileCount: number;\\n  subfolders: string[];\\n}\\n\\nexport interface GitContext {\\n  isRepository: boolean;\\n  currentBranch: string;\\n  uncommittedChanges: number;\\n  lastCommit: {\\n    hash: string;\\n    message: string;\\n    author: string;\\n    date: number;\\n  } | null;\\n  remoteUrl?: string;\\n}\\n\\nexport type ProjectType = \\n  | 'obsidian-plugin'\\n  | 'typescript-library'\\n  | 'javascript-library'\\n  | 'react-app'\\n  | 'vue-app'\\n  | 'node-app'\\n  | 'python-package'\\n  | 'documentation'\\n  | 'notes'\\n  | 'unknown';\\n\\n/**\\n * Main Development Context Service\\n */\\nexport class DevelopmentContextService {\\n  private app: App;\\n  private plugin: VaultPilotPlugin;\\n  private contextCache: Map<string, any> = new Map();\\n  private cacheTimeout = 30000; // 30 seconds\\n\\n  constructor(app: App, plugin: VaultPilotPlugin) {\\n    this.app = app;\\n    this.plugin = plugin;\\n  }\\n\\n  /**\\n   * Get comprehensive development context\\n   */\\n  async getFullContext(): Promise<DevelopmentContext> {\\n    const cacheKey = 'full_context';\\n    const cached = this.getCachedResult(cacheKey);\\n    if (cached) return cached;\\n\\n    const context: DevelopmentContext = {\\n      workspace: await this.getWorkspaceContext(),\\n      activeFile: await this.getActiveFileContext(),\\n      selection: await this.getSelectionContext(),\\n      project: await this.getProjectContext(),\\n      git: await this.getGitContext(),\\n      timestamp: Date.now()\\n    };\\n\\n    this.setCachedResult(cacheKey, context);\\n    return context;\\n  }\\n\\n  /**\\n   * Get workspace-level context\\n   */\\n  async getWorkspaceContext(): Promise<WorkspaceContext> {\\n    const cacheKey = 'workspace_context';\\n    const cached = this.getCachedResult(cacheKey);\\n    if (cached) return cached;\\n\\n    const vault = this.app.vault;\\n    const allFiles = vault.getMarkdownFiles();\\n    \\n    // Get recent files (last 10 accessed)\\n    const recentFiles = this.getRecentFiles(10);\\n    \\n    // Analyze file types\\n    const fileTypes: Record<string, number> = {};\\n    allFiles.forEach(file => {\\n      const ext = file.extension || 'md';\\n      fileTypes[ext] = (fileTypes[ext] || 0) + 1;\\n    });\\n\\n    // Get all tags\\n    const tags = this.extractAllTags();\\n\\n    // Build folder structure\\n    const folders = this.buildFolderStructure();\\n\\n    const context: WorkspaceContext = {\\n      totalFiles: allFiles.length,\\n      recentFiles,\\n      tags,\\n      folders,\\n      fileTypes,\\n      vaultPath: (vault.adapter as any).basePath || vault.adapter.getName?.() || ''\\n    };\\n\\n    this.setCachedResult(cacheKey, context, 60000); // Cache for 1 minute\\n    return context;\\n  }\\n\\n  /**\\n   * Get active file context\\n   */\\n  async getActiveFileContext(): Promise<FileContext | null> {\\n    const activeFile = this.app.workspace.getActiveFile();\\n    if (!activeFile) return null;\\n\\n    const cacheKey = `file_context_${activeFile.path}_${activeFile.stat.mtime}`;\\n    const cached = this.getCachedResult(cacheKey);\\n    if (cached) return cached;\\n\\n    const content = await this.app.vault.read(activeFile);\\n    const metadata = this.app.metadataCache.getFileCache(activeFile);\\n\\n    const context: FileContext = {\\n      path: activeFile.path,\\n      name: activeFile.name,\\n      content,\\n      language: this.detectLanguage(activeFile.extension),\\n      extension: activeFile.extension,\\n      size: activeFile.stat.size,\\n      lastModified: activeFile.stat.mtime,\\n      metadata: {\\n        frontmatter: metadata?.frontmatter || {},\\n        tags: this.extractTags(metadata),\\n        links: this.extractLinks(metadata),\\n        backlinks: this.getBacklinks(activeFile),\\n        headings: this.extractHeadings(metadata),\\n        wordCount: content.split(/\\\\s+/).length\\n      },\\n      symbols: await this.extractCodeSymbols(content, activeFile.extension),\\n      dependencies: await this.extractDependencies(content, activeFile.extension)\\n    };\\n\\n    this.setCachedResult(cacheKey, context);\\n    return context;\\n  }\\n\\n  /**\\n   * Get current selection context\\n   */\\n  async getSelectionContext(): Promise<SelectionContext | null> {\\n    const activeLeaf = this.app.workspace.activeLeaf;\\n    if (!activeLeaf?.view) return null;\\n\\n    // Check if this is a markdown view with an editor\\n    const view = activeLeaf.view as any;\\n    if (!view.editor) return null;\\n\\n    const editor = view.editor;\\n    const selection = editor.getSelection();\\n    \\n    if (!selection) return null;\\n\\n    const selectionRange = editor.listSelections()[0];\\n    const startPos = selectionRange.anchor;\\n    const endPos = selectionRange.head;\\n    \\n    // Ensure start is before end\\n    const actualStart = startPos.line < endPos.line || (startPos.line === endPos.line && startPos.ch < endPos.ch) ? startPos : endPos;\\n    const actualEnd = startPos.line > endPos.line || (startPos.line === endPos.line && startPos.ch > endPos.ch) ? startPos : endPos;\\n    \\n    const line = editor.getLine(actualStart.line);\\n    \\n    // Get surrounding context (5 lines before and after)\\n    const contextStartLine = Math.max(0, actualStart.line - 5);\\n    const contextEndLine = Math.min(editor.lineCount() - 1, actualEnd.line + 5);\\n    const surroundingLines = [];\\n    \\n    for (let i = contextStartLine; i <= contextEndLine; i++) {\\n      surroundingLines.push(editor.getLine(i));\\n    }\\n\\n    return {\\n      text: selection,\\n      startLine: actualStart.line,\\n      endLine: actualEnd.line,\\n      startCol: actualStart.ch,\\n      endCol: actualEnd.ch,\\n      surroundingContext: surroundingLines.join('\\\\n'),\\n      lineContext: line\\n    };\\n  }\\n\\n  /**\\n   * Get project context\\n   */\\n  async getProjectContext(): Promise<ProjectContext> {\\n    const cacheKey = 'project_context';\\n    const cached = this.getCachedResult(cacheKey);\\n    if (cached) return cached;\\n\\n    const projectType = await this.detectProjectType();\\n    const structure = await this.analyzeProjectStructure();\\n    const dependencies = await this.analyzeDependencies();\\n    const buildSystem = await this.detectBuildSystem();\\n    const testFramework = await this.detectTestFramework();\\n    const documentation = await this.findDocumentation();\\n\\n    const context: ProjectContext = {\\n      type: projectType,\\n      structure,\\n      dependencies,\\n      buildSystem,\\n      testFramework,\\n      documentation\\n    };\\n\\n    this.setCachedResult(cacheKey, context, 120000); // Cache for 2 minutes\\n    return context;\\n  }\\n\\n  /**\\n   * Get Git context\\n   */\\n  async getGitContext(): Promise<GitContext | null> {\\n    const vault = this.app.vault;\\n    \\n    // Check if .git directory exists\\n    const gitDir = vault.getAbstractFileByPath('.git');\\n    if (!gitDir) return null;\\n    \\n    // Basic Git context - for full implementation, we'd need to read Git files\\n    // For now, just indicate it's a Git repository\\n    return {\\n      isRepository: true,\\n      currentBranch: 'main', // Default assumption\\n      uncommittedChanges: 0, // Would need to check git status\\n      lastCommit: null, // Would need to parse git log\\n      remoteUrl: undefined // Would need to parse git config\\n    };\\n  }\\n\\n  // Caching methods\\n  private getCachedResult(key: string): any {\\n    const cached = this.contextCache.get(key);\\n    if (!cached) return null;\\n    \\n    if (Date.now() - cached.timestamp > cached.timeout) {\\n      this.contextCache.delete(key);\\n      return null;\\n    }\\n    \\n    return cached.data;\\n  }\\n\\n  private setCachedResult(key: string, data: any, timeout = this.cacheTimeout): void {\\n    this.contextCache.set(key, {\\n      data,\\n      timestamp: Date.now(),\\n      timeout\\n    });\\n  }\\n\\n  // Helper methods for workspace analysis\\n  private getRecentFiles(limit: number): string[] {\\n    const recentFiles: string[] = [];\\n    const workspace = this.app.workspace;\\n    \\n    // Get recent files from workspace leaf history\\n    workspace.iterateAllLeaves(leaf => {\\n      if (leaf.view && 'file' in leaf.view && leaf.view.file) {\\n        const file = leaf.view.file as TFile;\\n        const filePath = file.path;\\n        if (!recentFiles.includes(filePath)) {\\n          recentFiles.push(filePath);\\n        }\\n      }\\n    });\\n    \\n    // Also check recently opened files from workspace if available\\n    try {\\n      const lastOpenFiles = (workspace as any).getLastOpenFiles?.() || [];\\n      lastOpenFiles.forEach((filePath: string) => {\\n        if (!recentFiles.includes(filePath)) {\\n          recentFiles.push(filePath);\\n        }\\n      });\\n    } catch (e) {\\n      // Fallback if method doesn't exist\\n    }\\n    \\n    return recentFiles.slice(0, limit);\\n  }\\n\\n  private extractAllTags(): string[] {\\n    const tags = new Set<string>();\\n    const metadataCache = this.app.metadataCache;\\n    const vault = this.app.vault;\\n    \\n    // Get all markdown files and extract tags from their metadata\\n    vault.getMarkdownFiles().forEach(file => {\\n      const cache = metadataCache.getFileCache(file);\\n      if (cache?.tags) {\\n        cache.tags.forEach(tag => tags.add(tag.tag));\\n      }\\n      if (cache?.frontmatter?.tags) {\\n        const frontmatterTags = Array.isArray(cache.frontmatter.tags) \\n          ? cache.frontmatter.tags \\n          : [cache.frontmatter.tags];\\n        frontmatterTags.forEach(tag => tags.add(tag));\\n      }\\n    });\\n    \\n    return Array.from(tags);\\n  }\\n\\n  private buildFolderStructure(): FolderStructure[] {\\n    const folders: FolderStructure[] = [];\\n    const vault = this.app.vault;\\n    const folderMap = new Map<string, { fileCount: number; subfolders: Set<string> }>();\\n    \\n    // Analyze all files to build folder structure\\n    vault.getAllLoadedFiles().forEach(file => {\\n      const pathParts = file.path.split('/');\\n      if (pathParts.length > 1) {\\n        // Build all folder paths in the hierarchy\\n        for (let i = 1; i < pathParts.length; i++) {\\n          const folderPath = pathParts.slice(0, i).join('/');\\n          const folderName = pathParts[i - 1];\\n          \\n          if (!folderMap.has(folderPath)) {\\n            folderMap.set(folderPath, { fileCount: 0, subfolders: new Set() });\\n          }\\n          \\n          const folderInfo = folderMap.get(folderPath)!;\\n          \\n          // If this is the file's direct parent folder, count it\\n          if (i === pathParts.length - 1) {\\n            folderInfo.fileCount++;\\n          }\\n          \\n          // Add subfolder if there are more path parts\\n          if (i < pathParts.length - 1) {\\n            folderInfo.subfolders.add(pathParts[i]);\\n          }\\n        }\\n      }\\n    });\\n    \\n    // Convert map to folder structures\\n    folderMap.forEach((info, path) => {\\n      const name = path.split('/').pop() || path;\\n      folders.push({\\n        name,\\n        path,\\n        fileCount: info.fileCount,\\n        subfolders: Array.from(info.subfolders)\\n      });\\n    });\\n    \\n    return folders.sort((a, b) => a.path.localeCompare(b.path));\\n  }\\n\\n  // Helper methods for file analysis\\n  private detectLanguage(extension: string): string {\\n    const languageMap: Record<string, string> = {\\n      'ts': 'typescript',\\n      'js': 'javascript',\\n      'tsx': 'typescript-react',\\n      'jsx': 'javascript-react',\\n      'py': 'python',\\n      'java': 'java',\\n      'cpp': 'cpp',\\n      'c': 'c',\\n      'cs': 'csharp',\\n      'php': 'php',\\n      'rb': 'ruby',\\n      'go': 'go',\\n      'rs': 'rust',\\n      'kt': 'kotlin',\\n      'swift': 'swift',\\n      'md': 'markdown',\\n      'json': 'json',\\n      'yaml': 'yaml',\\n      'yml': 'yaml',\\n      'xml': 'xml',\\n      'html': 'html',\\n      'css': 'css',\\n      'scss': 'scss',\\n      'less': 'less'\\n    };\\n    \\n    return languageMap[extension] || 'text';\\n  }\\n\\n  private extractTags(metadata: any): string[] {\\n    if (!metadata?.tags) return [];\\n    return metadata.tags.map((tag: any) => tag.tag || tag);\\n  }\\n\\n  private extractLinks(metadata: any): string[] {\\n    if (!metadata?.links) return [];\\n    return metadata.links.map((link: any) => link.link);\\n  }\\n\\n  private getBacklinks(file: TFile): string[] {\\n    const backlinks: string[] = [];\\n    const metadataCache = this.app.metadataCache;\\n    const vault = this.app.vault;\\n    \\n    // Check all markdown files for links to the target file\\n    vault.getMarkdownFiles().forEach(otherFile => {\\n      if (otherFile.path === file.path) return; // Skip self\\n      \\n      const cache = metadataCache.getFileCache(otherFile);\\n      if (cache?.links) {\\n        cache.links.forEach((link: any) => {\\n          if (link.link === file.basename || link.link === file.path) {\\n            backlinks.push(otherFile.path);\\n          }\\n        });\\n      }\\n    });\\n    \\n    return backlinks;\\n  }\\n\\n  private extractHeadings(metadata: any): HeadingInfo[] {\\n    if (!metadata?.headings) return [];\\n    \\n    return metadata.headings.map((heading: any) => ({\\n      level: heading.level,\\n      text: heading.heading,\\n      line: heading.position?.start?.line || 0\\n    }));\\n  }\\n\\n  private async extractCodeSymbols(content: string, extension: string): Promise<CodeSymbol[]> {\\n    const symbols: CodeSymbol[] = [];\\n    const lines = content.split('\\\\n');\\n    \\n    // Simple symbol extraction for common languages\\n    if (extension === 'ts' || extension === 'js') {\\n      lines.forEach((line, index) => {\\n        // Extract functions\\n        const functionMatch = line.match(/(function|const|let|var)\\\\s+(\\\\w+)/);\\n        if (functionMatch) {\\n          symbols.push({\\n            name: functionMatch[2],\\n            type: 'function',\\n            line: index + 1,\\n            scope: 'global', // TODO: Implement proper scope detection\\n            signature: line.trim()\\n          });\\n        }\\n        \\n        // Extract classes\\n        const classMatch = line.match(/class\\\\s+(\\\\w+)/);\\n        if (classMatch) {\\n          symbols.push({\\n            name: classMatch[1],\\n            type: 'class',\\n            line: index + 1,\\n            scope: 'global',\\n            signature: line.trim()\\n          });\\n        }\\n      });\\n    }\\n    \\n    return symbols;\\n  }\\n\\n  private async extractDependencies(content: string, extension: string): Promise<string[]> {\\n    const dependencies: string[] = [];\\n    const lines = content.split('\\\\n');\\n    \\n    // Extract imports/requires\\n    lines.forEach(line => {\\n      // TypeScript/JavaScript imports\\n      const importMatch = line.match(/import.*from\\\\s+['\\\"]([^'\\\"]+)['\\\"]/);\\n      if (importMatch) {\\n        dependencies.push(importMatch[1]);\\n      }\\n      \\n      // Require statements\\n      const requireMatch = line.match(/require\\\\(['\\\"]([^'\\\"]+)['\\\"]\\\\)/);\\n      if (requireMatch) {\\n        dependencies.push(requireMatch[1]);\\n      }\\n      \\n      // Python imports\\n      const pythonMatch = line.match(/(?:from\\\\s+(\\\\w+)|import\\\\s+(\\\\w+))/);\\n      if (pythonMatch) {\\n        dependencies.push(pythonMatch[1] || pythonMatch[2]);\\n      }\\n    });\\n    \\n    return dependencies;\\n  }\\n\\n  // Project analysis methods\\n  private async detectProjectType(): Promise<ProjectType> {\\n    const vault = this.app.vault;\\n    const files = vault.getAllLoadedFiles();\\n    \\n    // Check for specific project indicators\\n    const hasPackageJson = files.some(f => f.name === 'package.json');\\n    const hasManifestJson = files.some(f => f.name === 'manifest.json');\\n    const hasTsConfig = files.some(f => f.name === 'tsconfig.json');\\n    const hasPyProject = files.some(f => f.name === 'pyproject.toml' || f.name === 'setup.py');\\n    \\n    if (hasManifestJson && hasPackageJson) return 'obsidian-plugin';\\n    if (hasPackageJson && hasTsConfig) return 'typescript-library';\\n    if (hasPackageJson) return 'javascript-library';\\n    if (hasPyProject) return 'python-package';\\n    \\n    // Check for framework-specific files\\n    const hasReactFiles = files.some(f => \\n      f instanceof TFile && (f.name.includes('.jsx') || f.name.includes('.tsx'))\\n    );\\n    if (hasReactFiles) return 'react-app';\\n    \\n    // Default classifications\\n    const hasMarkdownFiles = files.some(f => f instanceof TFile && f.extension === 'md');\\n    if (hasMarkdownFiles) return 'documentation';\\n    \\n    return 'unknown';\\n  }\\n\\n  private async analyzeProjectStructure(): Promise<ProjectStructure> {\\n    const vault = this.app.vault;\\n    const files = vault.getAllLoadedFiles();\\n    \\n    const rootFiles: string[] = [];\\n    const sourceDirectories: string[] = [];\\n    const testDirectories: string[] = [];\\n    const configFiles: string[] = [];\\n    const documentationFiles: string[] = [];\\n    \\n    files.forEach(file => {\\n      if (file.path.split('/').length === 1) {\\n        rootFiles.push(file.name);\\n      }\\n      \\n      if (file.path.includes('/src/')) {\\n        sourceDirectories.push(file.path);\\n      }\\n      \\n      if (file.path.includes('/test/') || file.path.includes('/__tests__/')) {\\n        testDirectories.push(file.path);\\n      }\\n      \\n      if (file.name.includes('config') || file.name.includes('.json') || file.name.includes('.yml')) {\\n        configFiles.push(file.path);\\n      }\\n      \\n      if (file instanceof TFile && (file.extension === 'md' || file.name.toLowerCase().includes('readme'))) {\\n        documentationFiles.push(file.path);\\n      }\\n    });\\n    \\n    return {\\n      rootFiles,\\n      sourceDirectories,\\n      testDirectories,\\n      configFiles,\\n      documentationFiles,\\n      depth: Math.max(...files.map(f => f.path.split('/').length)),\\n      estimatedSize: files.length < 50 ? 'small' : files.length < 200 ? 'medium' : 'large'\\n    };\\n  }\\n\\n  private async analyzeDependencies(): Promise<DependencyInfo[]> {\\n    const dependencies: DependencyInfo[] = [];\\n    const vault = this.app.vault;\\n    \\n    try {\\n      // Try to read package.json\\n      const packageJsonFile = vault.getAbstractFileByPath('package.json');\\n      if (packageJsonFile instanceof TFile) {\\n        const content = await vault.read(packageJsonFile);\\n        const packageData = JSON.parse(content);\\n        \\n        // Parse dependencies\\n        Object.entries(packageData.dependencies || {}).forEach(([name, version]) => {\\n          dependencies.push({\\n            name,\\n            version: version as string,\\n            type: 'runtime',\\n            source: 'package.json'\\n          });\\n        });\\n        \\n        // Parse devDependencies\\n        Object.entries(packageData.devDependencies || {}).forEach(([name, version]) => {\\n          dependencies.push({\\n            name,\\n            version: version as string,\\n            type: 'dev',\\n            source: 'package.json'\\n          });\\n        });\\n        \\n        // Parse peerDependencies\\n        Object.entries(packageData.peerDependencies || {}).forEach(([name, version]) => {\\n          dependencies.push({\\n            name,\\n            version: version as string,\\n            type: 'peer',\\n            source: 'package.json'\\n          });\\n        });\\n      }\\n    } catch (e) {\\n      // Package.json not found or invalid, try other dependency files\\n    }\\n    \\n    // TODO: Add support for requirements.txt, Cargo.toml, etc.\\n    \\n    return dependencies;\\n  }\\n\\n  private async detectBuildSystem(): Promise<BuildSystemInfo | null> {\\n    const vault = this.app.vault;\\n    \\n    // Check for package.json (npm/yarn)\\n    const packageJsonFile = vault.getAbstractFileByPath('package.json');\\n    if (packageJsonFile instanceof TFile) {\\n      try {\\n        const content = await vault.read(packageJsonFile);\\n        const packageData = JSON.parse(content);\\n        const scripts = Object.keys(packageData.scripts || {});\\n        \\n        return {\\n          type: 'npm',\\n          configFile: 'package.json',\\n          scripts\\n        };\\n      } catch (e) {\\n        // Invalid package.json\\n      }\\n    }\\n    \\n    // Check for other build systems\\n    if (vault.getAbstractFileByPath('pom.xml')) {\\n      return {\\n        type: 'maven',\\n        configFile: 'pom.xml',\\n        scripts: ['compile', 'test', 'package']\\n      };\\n    }\\n    \\n    if (vault.getAbstractFileByPath('build.gradle')) {\\n      return {\\n        type: 'gradle',\\n        configFile: 'build.gradle',\\n        scripts: ['build', 'test', 'clean']\\n      };\\n    }\\n    \\n    if (vault.getAbstractFileByPath('CMakeLists.txt')) {\\n      return {\\n        type: 'cmake',\\n        configFile: 'CMakeLists.txt',\\n        scripts: ['build', 'install']\\n      };\\n    }\\n    \\n    if (vault.getAbstractFileByPath('Makefile')) {\\n      return {\\n        type: 'make',\\n        configFile: 'Makefile',\\n        scripts: ['all', 'clean', 'install']\\n      };\\n    }\\n    \\n    return null;\\n  }\\n\\n  private async detectTestFramework(): Promise<TestFrameworkInfo | null> {\\n    const vault = this.app.vault;\\n    const files = vault.getAllLoadedFiles();\\n    \\n    // Check for Jest\\n    if (vault.getAbstractFileByPath('jest.config.js') || vault.getAbstractFileByPath('jest.config.json')) {\\n      return {\\n        type: 'jest',\\n        configFile: vault.getAbstractFileByPath('jest.config.js') ? 'jest.config.js' : 'jest.config.json',\\n        testPatterns: ['**/__tests__/**/*.test.js', '**/*.test.js', '**/*.spec.js']\\n      };\\n    }\\n    \\n    // Check package.json for test frameworks\\n    const packageJsonFile = vault.getAbstractFileByPath('package.json');\\n    if (packageJsonFile instanceof TFile) {\\n      try {\\n        const content = await vault.read(packageJsonFile);\\n        const packageData = JSON.parse(content);\\n        const allDeps = {\\n          ...packageData.dependencies,\\n          ...packageData.devDependencies\\n        };\\n        \\n        if (allDeps.jest) {\\n          return {\\n            type: 'jest',\\n            testPatterns: ['**/__tests__/**/*.test.js', '**/*.test.js', '**/*.spec.js']\\n          };\\n        }\\n        \\n        if (allDeps.mocha) {\\n          return {\\n            type: 'mocha',\\n            testPatterns: ['test/**/*.js', 'test/**/*.spec.js']\\n          };\\n        }\\n        \\n        if (allDeps.pytest) {\\n          return {\\n            type: 'pytest',\\n            testPatterns: ['test_*.py', '*_test.py', 'tests/**/*.py']\\n          };\\n        }\\n      } catch (e) {\\n        // Invalid package.json\\n      }\\n    }\\n    \\n    // Check for Python test files\\n    const hasPytestFiles = files.some(f => \\n      f instanceof TFile && \\n      (f.name.startsWith('test_') || f.name.endsWith('_test.py'))\\n    );\\n    if (hasPytestFiles) {\\n      return {\\n        type: 'pytest',\\n        testPatterns: ['test_*.py', '*_test.py', 'tests/**/*.py']\\n      };\\n    }\\n    \\n    // Check for JUnit\\n    const hasJunitFiles = files.some(f => \\n      f instanceof TFile && \\n      f.name.includes('Test.java')\\n    );\\n    if (hasJunitFiles) {\\n      return {\\n        type: 'junit',\\n        testPatterns: ['**/*Test.java', '**/Test*.java']\\n      };\\n    }\\n    \\n    return null;\\n  }\\n\\n  private async findDocumentation(): Promise<DocumentationInfo[]> {\\n    const vault = this.app.vault;\\n    const files = vault.getAllLoadedFiles();\\n    const docs: DocumentationInfo[] = [];\\n    \\n    files.forEach(file => {\\n      if (!(file instanceof TFile)) return;\\n      \\n      if (file.name.toLowerCase().includes('readme')) {\\n        docs.push({\\n          type: 'readme',\\n          path: file.path,\\n          lastUpdated: file.stat.mtime\\n        });\\n      }\\n      \\n      if (file.name.toLowerCase().includes('changelog')) {\\n        docs.push({\\n          type: 'changelog',\\n          path: file.path,\\n          lastUpdated: file.stat.mtime\\n        });\\n      }\\n      \\n      if (file.name.toLowerCase().includes('license')) {\\n        docs.push({\\n          type: 'license',\\n          path: file.path,\\n          lastUpdated: file.stat.mtime\\n        });\\n      }\\n    });\\n    \\n    return docs;\\n  }\\n\\n  /**\\n   * Clear all cached context data\\n   */\\n  public clearCache(): void {\\n    this.contextCache.clear();\\n  }\\n\\n  /**\\n   * Get context summary for chat\\n   */\\n  async getContextSummary(): Promise<string> {\\n    const context = await this.getFullContext();\\n    \\n    let summary = `## Development Context\\\\n\\\\n`;\\n    \\n    // Workspace info\\n    summary += `**Workspace**: ${context.workspace.totalFiles} files, ${context.workspace.folders.length} folders\\\\n`;\\n    \\n    // Active file info\\n    if (context.activeFile) {\\n      summary += `**Active File**: ${context.activeFile.name} (${context.activeFile.language})\\\\n`;\\n      summary += `**File Size**: ${Math.round(context.activeFile.size / 1024)}KB, ${context.activeFile.metadata.wordCount} words\\\\n`;\\n      \\n      if (context.activeFile.symbols.length > 0) {\\n        summary += `**Code Symbols**: ${context.activeFile.symbols.length} found\\\\n`;\\n      }\\n    }\\n    \\n    // Project info\\n    summary += `**Project Type**: ${context.project.type}\\\\n`;\\n    summary += `**Project Size**: ${context.project.structure.estimatedSize}\\\\n`;\\n    \\n    // Selection info\\n    if (context.selection) {\\n      summary += `**Current Selection**: \\\"${context.selection.text.substring(0, 50)}${context.selection.text.length > 50 ? '...' : ''}\\\"\\\\n`;\\n    }\\n    \\n    return summary;\\n  }\\n}\\n\"]}"}
