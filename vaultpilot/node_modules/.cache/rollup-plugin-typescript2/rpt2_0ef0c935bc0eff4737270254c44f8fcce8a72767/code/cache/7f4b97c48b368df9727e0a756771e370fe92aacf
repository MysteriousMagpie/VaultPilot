{"code":"import { __awaiter } from \"tslib\";\n/**\n * Fetches schedule data from the EvoAgentX API\n * @param noteText - The full text of the active note\n * @param apiClient - The EvoAgentX API client instance\n * @returns Promise with the schedule markdown and headline\n */\nexport function fetchSchedule(noteText, apiClient) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Use EvoAgentX task planning endpoint instead of local server\n        const response = yield apiClient.planTasks({\n            goal: `Create a daily schedule based on this note content`,\n            context: noteText,\n            timeframe: '1 day'\n        });\n        if (!response.success) {\n            throw new Error(response.error || 'Failed to generate schedule');\n        }\n        // Convert EvoAgentX task planning response to schedule format\n        const taskPlan = response.data.plan;\n        const tasks = taskPlan.tasks || [];\n        // Generate schedule markdown from tasks\n        let scheduleMarkdown = '| Time | Task |\\n|------|------|\\n';\n        // Extract scheduled times from task descriptions or generate them\n        tasks.forEach((task, index) => {\n            const timeMatch = task.description.match(/(\\d{1,2}:\\d{2})/);\n            const time = timeMatch ? timeMatch[1] : `${9 + Math.floor(index * 1.5)}:${(index * 30) % 60 || '00'}`;\n            scheduleMarkdown += `| ${time} | ${task.title} |\\n`;\n        });\n        return {\n            scheduleMarkdown,\n            headline: `✨ Smart schedule created with ${tasks.length} tasks!`\n        };\n    });\n}\n/**\n * Finds and extracts the Schedule section from note text\n * @param text - The full note text\n * @returns Match result with schedule section details or null\n */\nexport function findScheduleSection(text) {\n    // First try to match headings that are exactly \"## Schedule\" (with optional content after)\n    let scheduleRegex = /(^##\\s+Schedule\\b[^\\n]*\\n)([\\s\\S]*?)(?=\\n##\\s|$)/im;\n    let match = text.match(scheduleRegex);\n    if (match) {\n        return match;\n    }\n    // If no exact match, try to match headings that contain \"Schedule\" as a word\n    scheduleRegex = /(^##\\s*(?:.*\\s)?\\bSchedule\\b(?:\\s.*)?$\\n)([\\s\\S]*?)(?=\\n##\\s|$)/im;\n    return text.match(scheduleRegex);\n}\n/**\n * Injects or replaces the schedule section in the note text\n * @param originalText - The original note text\n * @param scheduleMarkdown - The new schedule content to inject\n * @returns Updated note text with the new schedule section\n */\nexport function injectSchedule(originalText, scheduleMarkdown) {\n    const match = findScheduleSection(originalText);\n    if (match) {\n        // Replace existing schedule section (keep heading, replace content)\n        const [fullMatch, heading] = match;\n        const replacement = heading + scheduleMarkdown;\n        return originalText.replace(fullMatch, replacement);\n    }\n    else {\n        // Append new schedule section\n        const newSection = `\\n\\n## Schedule\\n${scheduleMarkdown}`;\n        return originalText + newSection;\n    }\n}\n/**\n * Validates if the schedule markdown is properly formatted\n * @param scheduleMarkdown - The schedule content to validate\n * @returns True if valid, false otherwise\n */\nexport function validateScheduleMarkdown(scheduleMarkdown) {\n    // Basic validation - check if it's not empty and contains some content\n    return scheduleMarkdown.trim().length > 0;\n}\n//# sourceMappingURL=planner.js.map","references":[],"map":"{\"version\":3,\"file\":\"planner.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/planner.ts\"],\"names\":[],\"mappings\":\";AAUA;;;;;GAKG;AACH,MAAM,UAAgB,aAAa,CAAC,QAAgB,EAAE,SAAc;;QAClE,+DAA+D;QAC/D,MAAM,QAAQ,GAAG,MAAM,SAAS,CAAC,SAAS,CAAC;YACzC,IAAI,EAAE,oDAAoD;YAC1D,OAAO,EAAE,QAAQ;YACjB,SAAS,EAAE,OAAO;SACnB,CAAC,CAAC;QAEH,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;YACtB,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,IAAI,6BAA6B,CAAC,CAAC;QACnE,CAAC;QAED,8DAA8D;QAC9D,MAAM,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;QACpC,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,IAAI,EAAE,CAAC;QAEnC,wCAAwC;QACxC,IAAI,gBAAgB,GAAG,oCAAoC,CAAC;QAE5D,kEAAkE;QAClE,KAAK,CAAC,OAAO,CAAC,CAAC,IAAS,EAAE,KAAa,EAAE,EAAE;YACzC,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;YAC5D,MAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC,GAAG,EAAE,IAAI,IAAI,EAAE,CAAC;YACtG,gBAAgB,IAAI,KAAK,IAAI,MAAM,IAAI,CAAC,KAAK,MAAM,CAAC;QACtD,CAAC,CAAC,CAAC;QAEH,OAAO;YACL,gBAAgB;YAChB,QAAQ,EAAE,iCAAiC,KAAK,CAAC,MAAM,SAAS;SACjE,CAAC;IACJ,CAAC;CAAA;AAED;;;;GAIG;AACH,MAAM,UAAU,mBAAmB,CAAC,IAAY;IAC9C,2FAA2F;IAC3F,IAAI,aAAa,GAAG,oDAAoD,CAAC;IACzE,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;IAEtC,IAAI,KAAK,EAAE,CAAC;QACV,OAAO,KAAK,CAAC;IACf,CAAC;IAED,6EAA6E;IAC7E,aAAa,GAAG,mEAAmE,CAAC;IACpF,OAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;AACnC,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,cAAc,CAAC,YAAoB,EAAE,gBAAwB;IAC3E,MAAM,KAAK,GAAG,mBAAmB,CAAC,YAAY,CAAC,CAAC;IAEhD,IAAI,KAAK,EAAE,CAAC;QACV,oEAAoE;QACpE,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,GAAG,KAAK,CAAC;QACnC,MAAM,WAAW,GAAG,OAAO,GAAG,gBAAgB,CAAC;QAC/C,OAAO,YAAY,CAAC,OAAO,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;IACtD,CAAC;SAAM,CAAC;QACN,8BAA8B;QAC9B,MAAM,UAAU,GAAG,oBAAoB,gBAAgB,EAAE,CAAC;QAC1D,OAAO,YAAY,GAAG,UAAU,CAAC;IACnC,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,wBAAwB,CAAC,gBAAwB;IAC/D,uEAAuE;IACvE,OAAO,gBAAgB,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC;AAC5C,CAAC\",\"sourcesContent\":[\"// Type definitions for the planner feature\\nexport interface PlannerResponse {\\n  scheduleMarkdown: string;\\n  headline: string;\\n}\\n\\nexport interface PlannerRequest {\\n  note: string;\\n}\\n\\n/**\\n * Fetches schedule data from the EvoAgentX API\\n * @param noteText - The full text of the active note\\n * @param apiClient - The EvoAgentX API client instance\\n * @returns Promise with the schedule markdown and headline\\n */\\nexport async function fetchSchedule(noteText: string, apiClient: any): Promise<PlannerResponse> {\\n  // Use EvoAgentX task planning endpoint instead of local server\\n  const response = await apiClient.planTasks({\\n    goal: `Create a daily schedule based on this note content`,\\n    context: noteText,\\n    timeframe: '1 day'\\n  });\\n\\n  if (!response.success) {\\n    throw new Error(response.error || 'Failed to generate schedule');\\n  }\\n\\n  // Convert EvoAgentX task planning response to schedule format\\n  const taskPlan = response.data.plan;\\n  const tasks = taskPlan.tasks || [];\\n  \\n  // Generate schedule markdown from tasks\\n  let scheduleMarkdown = '| Time | Task |\\\\n|------|------|\\\\n';\\n  \\n  // Extract scheduled times from task descriptions or generate them\\n  tasks.forEach((task: any, index: number) => {\\n    const timeMatch = task.description.match(/(\\\\d{1,2}:\\\\d{2})/);\\n    const time = timeMatch ? timeMatch[1] : `${9 + Math.floor(index * 1.5)}:${(index * 30) % 60 || '00'}`;\\n    scheduleMarkdown += `| ${time} | ${task.title} |\\\\n`;\\n  });\\n\\n  return {\\n    scheduleMarkdown,\\n    headline: `✨ Smart schedule created with ${tasks.length} tasks!`\\n  };\\n}\\n\\n/**\\n * Finds and extracts the Schedule section from note text\\n * @param text - The full note text\\n * @returns Match result with schedule section details or null\\n */\\nexport function findScheduleSection(text: string): RegExpMatchArray | null {\\n  // First try to match headings that are exactly \\\"## Schedule\\\" (with optional content after)\\n  let scheduleRegex = /(^##\\\\s+Schedule\\\\b[^\\\\n]*\\\\n)([\\\\s\\\\S]*?)(?=\\\\n##\\\\s|$)/im;\\n  let match = text.match(scheduleRegex);\\n  \\n  if (match) {\\n    return match;\\n  }\\n  \\n  // If no exact match, try to match headings that contain \\\"Schedule\\\" as a word\\n  scheduleRegex = /(^##\\\\s*(?:.*\\\\s)?\\\\bSchedule\\\\b(?:\\\\s.*)?$\\\\n)([\\\\s\\\\S]*?)(?=\\\\n##\\\\s|$)/im;\\n  return text.match(scheduleRegex);\\n}\\n\\n/**\\n * Injects or replaces the schedule section in the note text\\n * @param originalText - The original note text\\n * @param scheduleMarkdown - The new schedule content to inject\\n * @returns Updated note text with the new schedule section\\n */\\nexport function injectSchedule(originalText: string, scheduleMarkdown: string): string {\\n  const match = findScheduleSection(originalText);\\n  \\n  if (match) {\\n    // Replace existing schedule section (keep heading, replace content)\\n    const [fullMatch, heading] = match;\\n    const replacement = heading + scheduleMarkdown;\\n    return originalText.replace(fullMatch, replacement);\\n  } else {\\n    // Append new schedule section\\n    const newSection = `\\\\n\\\\n## Schedule\\\\n${scheduleMarkdown}`;\\n    return originalText + newSection;\\n  }\\n}\\n\\n/**\\n * Validates if the schedule markdown is properly formatted\\n * @param scheduleMarkdown - The schedule content to validate\\n * @returns True if valid, false otherwise\\n */\\nexport function validateScheduleMarkdown(scheduleMarkdown: string): boolean {\\n  // Basic validation - check if it's not empty and contains some content\\n  return scheduleMarkdown.trim().length > 0;\\n}\\n\"]}"}
