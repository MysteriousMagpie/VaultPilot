{"code":"/**\n * WebSocket Transport for DevPipe communication\n * Supports real-time bidirectional communication with automatic reconnection\n */\nimport { __awaiter } from \"tslib\";\nimport { TransportType, TransportEvent } from './DevPipeTransport';\nimport { BaseTransport } from './BaseTransport';\nimport { EnvironmentDetector } from '../../utils/EnvironmentDetector';\n/**\n * Simple reconnecting WebSocket wrapper\n */\nclass ReconnectingWebSocket {\n    constructor(url, protocols = [], options = {}) {\n        this.reconnectAttempts = 0;\n        this.shouldReconnect = true;\n        this.url = url;\n        this.protocols = protocols;\n        this.options = options;\n        this.maxReconnectAttempts = options.maxReconnectAttempts || 10;\n        this.reconnectDelay = options.reconnectDelay || 1000;\n        this.connect();\n    }\n    connect() {\n        try {\n            this.ws = new WebSocket(this.url, this.protocols);\n            this.ws.onopen = (event) => {\n                this.reconnectAttempts = 0;\n                if (this.onopen)\n                    this.onopen(event);\n            };\n            this.ws.onclose = (event) => {\n                if (this.onclose)\n                    this.onclose(event);\n                if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\n                    setTimeout(() => this.reconnect(), this.reconnectDelay * Math.pow(2, this.reconnectAttempts));\n                }\n            };\n            this.ws.onmessage = (event) => {\n                if (this.onmessage)\n                    this.onmessage(event);\n            };\n            this.ws.onerror = (event) => {\n                if (this.onerror)\n                    this.onerror(event);\n            };\n        }\n        catch (error) {\n            if (this.onerror)\n                this.onerror(new Event('error'));\n        }\n    }\n    reconnect() {\n        if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.reconnectAttempts++;\n            this.connect();\n        }\n    }\n    send(data) {\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            throw new Error('WebSocket not connected');\n        }\n    }\n    close() {\n        this.shouldReconnect = false;\n        if (this.ws) {\n            this.ws.close();\n        }\n    }\n    get readyState() {\n        return this.ws ? this.ws.readyState : WebSocket.CLOSED;\n    }\n}\n/**\n * WebSocket Transport implementation\n */\nexport class WebSocketTransport extends BaseTransport {\n    constructor(config) {\n        super(TransportType.WEBSOCKET, config);\n        this.responseHandlers = new Map();\n        this.wsConfig = config.websocket || {\n            heartbeatInterval: 30000,\n            reconnectDelay: 1000,\n            maxReconnectAttempts: 10,\n            persistMessages: false\n        };\n        this.messageQueue = {\n            messages: [],\n            maxSize: 1000,\n            persistToDisk: this.wsConfig.persistMessages || false\n        };\n    }\n    doInitialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Validate WebSocket support in environment\n            const environment = EnvironmentDetector.detect();\n            if (!environment.hasWebSocket) {\n                throw new Error('WebSocket transport not supported in this environment');\n            }\n            this.debug('WebSocket transport initialized');\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.config.serverUrl) {\n                throw new Error('Server URL required for WebSocket transport');\n            }\n            return new Promise((resolve, reject) => {\n                const wsUrl = this.config.serverUrl.replace(/^http/, 'ws') + '/api/v1/devpipe/ws';\n                this.websocket = new ReconnectingWebSocket(wsUrl, [], {\n                    connectionTimeout: this.config.timeout,\n                    debug: this.config.debug,\n                    maxReconnectAttempts: this.wsConfig.maxReconnectAttempts,\n                    reconnectDelay: this.wsConfig.reconnectDelay\n                });\n                this.websocket.onopen = () => {\n                    this.connected = true;\n                    this.healthStatus.status = 'healthy';\n                    this.startHeartbeat();\n                    this.emit(TransportEvent.CONNECTED, { transport: this.type });\n                    this.debug('WebSocket connected');\n                    resolve();\n                };\n                this.websocket.onerror = (error) => {\n                    this.debug('WebSocket error:', error);\n                    this.emit(TransportEvent.ERROR, error);\n                    if (!this.connected) {\n                        reject(new Error('Failed to connect WebSocket'));\n                    }\n                };\n                this.websocket.onmessage = (event) => {\n                    this.handleMessage(event.data);\n                };\n                this.websocket.onclose = () => {\n                    this.connected = false;\n                    this.healthStatus.status = 'disconnected';\n                    this.stopHeartbeat();\n                    this.emit(TransportEvent.DISCONNECTED, { transport: this.type });\n                    this.debug('WebSocket disconnected');\n                };\n            });\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Reject all pending response handlers\n            const handlers = Array.from(this.responseHandlers.values());\n            for (const handler of handlers) {\n                clearTimeout(handler.timeout);\n                handler.reject(new Error('Transport disconnected'));\n            }\n            this.responseHandlers.clear();\n            // Stop heartbeat\n            this.stopHeartbeat();\n            // Close WebSocket\n            if (this.websocket) {\n                this.websocket.close();\n                this.websocket = undefined;\n            }\n            this.connected = false;\n            this.healthStatus.status = 'disconnected';\n            this.emit(TransportEvent.DISCONNECTED, { transport: this.type });\n            this.debug('WebSocket transport disconnected');\n        });\n    }\n    send(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isConnected()) {\n                throw new Error('WebSocket transport not connected');\n            }\n            // Add message ID if not present\n            if (!message.id) {\n                message.id = this.generateMessageId();\n            }\n            // Add timestamp\n            message.timestamp = Date.now();\n            return this.executeWithCircuitBreaker(() => __awaiter(this, void 0, void 0, function* () {\n                return this.sendWebSocketMessage(message);\n            }), 'websocket_send');\n        });\n    }\n    sendWebSocketMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                const timeoutHandle = setTimeout(() => {\n                    this.responseHandlers.delete(message.id);\n                    reject(new Error(`WebSocket request timeout after ${this.config.timeout}ms`));\n                }, this.config.timeout);\n                const handler = {\n                    resolve: (response) => {\n                        clearTimeout(timeoutHandle);\n                        this.responseHandlers.delete(message.id);\n                        resolve(response);\n                    },\n                    reject: (error) => {\n                        clearTimeout(timeoutHandle);\n                        this.responseHandlers.delete(message.id);\n                        reject(error);\n                    },\n                    timeout: timeoutHandle,\n                    timestamp: Date.now()\n                };\n                this.responseHandlers.set(message.id, handler);\n                try {\n                    this.websocket.send(JSON.stringify(message));\n                }\n                catch (error) {\n                    clearTimeout(timeoutHandle);\n                    this.responseHandlers.delete(message.id);\n                    reject(error);\n                }\n            });\n        });\n    }\n    handleMessage(data) {\n        try {\n            const message = JSON.parse(data);\n            if (message.type === 'pong') {\n                // Handle heartbeat pong\n                this.debug('Received heartbeat pong');\n                return;\n            }\n            if (message.type === 'response' && message.replyTo) {\n                // Handle response to pending request\n                const handler = this.responseHandlers.get(message.replyTo);\n                if (handler) {\n                    const response = {\n                        id: message.id,\n                        success: message.success !== false,\n                        payload: message.payload,\n                        error: message.error,\n                        timestamp: Date.now()\n                    };\n                    handler.resolve(response);\n                }\n            }\n            else if (message.type === 'health_pong' && message.id) {\n                // Handle health check response\n                const handler = this.responseHandlers.get(message.id);\n                if (handler) {\n                    const response = {\n                        id: message.id,\n                        success: true,\n                        payload: { status: 'healthy' },\n                        timestamp: Date.now()\n                    };\n                    handler.resolve(response);\n                }\n            }\n            else {\n                // Handle incoming message\n                this.emit(TransportEvent.MESSAGE, message);\n            }\n        }\n        catch (error) {\n            this.debug('Failed to handle WebSocket message:', error);\n            this.emit(TransportEvent.ERROR, error);\n        }\n    }\n    startHeartbeat() {\n        if (this.heartbeatInterval)\n            return;\n        this.heartbeatInterval = setInterval(() => {\n            if (this.isConnected()) {\n                try {\n                    this.websocket.send(JSON.stringify({\n                        type: 'ping',\n                        timestamp: Date.now()\n                    }));\n                }\n                catch (error) {\n                    this.debug('Failed to send heartbeat:', error);\n                }\n            }\n        }, this.wsConfig.heartbeatInterval || 30000);\n    }\n    stopHeartbeat() {\n        if (this.heartbeatInterval) {\n            clearInterval(this.heartbeatInterval);\n            this.heartbeatInterval = undefined;\n        }\n    }\n    doHealthCheck() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isConnected()) {\n                throw new Error('WebSocket not connected');\n            }\n            // Send ping and wait for pong\n            return new Promise((resolve, reject) => {\n                const timeout = setTimeout(() => {\n                    reject(new Error('Health check timeout'));\n                }, 5000);\n                const pingId = this.generateMessageId();\n                const handler = {\n                    resolve: () => {\n                        clearTimeout(timeout);\n                        resolve();\n                    },\n                    reject: (error) => {\n                        clearTimeout(timeout);\n                        reject(error);\n                    },\n                    timeout,\n                    timestamp: Date.now()\n                };\n                this.responseHandlers.set(pingId, handler);\n                try {\n                    this.websocket.send(JSON.stringify({\n                        type: 'health_ping',\n                        id: pingId,\n                        timestamp: Date.now()\n                    }));\n                }\n                catch (error) {\n                    clearTimeout(timeout);\n                    this.responseHandlers.delete(pingId);\n                    reject(error);\n                }\n            });\n        });\n    }\n    getCapabilities() {\n        return {\n            supportsRealtime: true,\n            supportsBidirectional: true,\n            supportsFileSystem: false,\n            supportsStreaming: true,\n            maxMessageSize: 1024 * 1024, // 1MB\n            averageLatency: this.healthStatus.latency,\n            maxConcurrentConnections: 1,\n            reliability: this.calculateReliability(),\n            supportedEnvironments: ['browser', 'node', 'obsidian']\n        };\n    }\n}\n//# sourceMappingURL=WebSocketTransport.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/DevPipeTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/BaseTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/utils/EnvironmentDetector.ts"],"map":"{\"version\":3,\"file\":\"WebSocketTransport.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/devpipe/transports/WebSocketTransport.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * WebSocket Transport for DevPipe communication\\n * Supports real-time bidirectional communication with automatic reconnection\\n */\\n\\nimport { \\n  DevPipeTransport,\\n  TransportType,\\n  TransportConfig,\\n  TransportCapabilities,\\n  DevPipeMessage,\\n  DevPipeResponse,\\n  TransportEvent,\\n  WebSocketTransportConfig\\n} from './DevPipeTransport';\\nimport { BaseTransport } from './BaseTransport';\\nimport { EnvironmentDetector } from '../../utils/EnvironmentDetector';\\n\\ninterface ResponseHandler {\\n  resolve: (response: DevPipeResponse) => void;\\n  reject: (error: Error) => void;\\n  timeout: any;\\n  timestamp: number;\\n}\\n\\ninterface MessageQueue {\\n  messages: DevPipeMessage[];\\n  maxSize: number;\\n  persistToDisk: boolean;\\n}\\n\\n/**\\n * Simple reconnecting WebSocket wrapper\\n */\\nclass ReconnectingWebSocket {\\n  private ws?: WebSocket;\\n  private url: string;\\n  private protocols: string[];\\n  private options: any;\\n  private reconnectAttempts: number = 0;\\n  private maxReconnectAttempts: number;\\n  private reconnectDelay: number;\\n  private shouldReconnect: boolean = true;\\n  \\n  public onopen?: (event: Event) => void;\\n  public onclose?: (event: CloseEvent) => void;\\n  public onmessage?: (event: MessageEvent) => void;\\n  public onerror?: (event: Event) => void;\\n\\n  constructor(url: string, protocols: string[] = [], options: any = {}) {\\n    this.url = url;\\n    this.protocols = protocols;\\n    this.options = options;\\n    this.maxReconnectAttempts = options.maxReconnectAttempts || 10;\\n    this.reconnectDelay = options.reconnectDelay || 1000;\\n    this.connect();\\n  }\\n\\n  private connect(): void {\\n    try {\\n      this.ws = new WebSocket(this.url, this.protocols);\\n      \\n      this.ws.onopen = (event) => {\\n        this.reconnectAttempts = 0;\\n        if (this.onopen) this.onopen(event);\\n      };\\n      \\n      this.ws.onclose = (event) => {\\n        if (this.onclose) this.onclose(event);\\n        if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\\n          setTimeout(() => this.reconnect(), this.reconnectDelay * Math.pow(2, this.reconnectAttempts));\\n        }\\n      };\\n      \\n      this.ws.onmessage = (event) => {\\n        if (this.onmessage) this.onmessage(event);\\n      };\\n      \\n      this.ws.onerror = (event) => {\\n        if (this.onerror) this.onerror(event);\\n      };\\n      \\n    } catch (error) {\\n      if (this.onerror) this.onerror(new Event('error'));\\n    }\\n  }\\n\\n  private reconnect(): void {\\n    if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\\n      this.reconnectAttempts++;\\n      this.connect();\\n    }\\n  }\\n\\n  send(data: string): void {\\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\\n      this.ws.send(data);\\n    } else {\\n      throw new Error('WebSocket not connected');\\n    }\\n  }\\n\\n  close(): void {\\n    this.shouldReconnect = false;\\n    if (this.ws) {\\n      this.ws.close();\\n    }\\n  }\\n\\n  get readyState(): number {\\n    return this.ws ? this.ws.readyState : WebSocket.CLOSED;\\n  }\\n}\\n\\n/**\\n * WebSocket Transport implementation\\n */\\nexport class WebSocketTransport extends BaseTransport {\\n  private websocket?: ReconnectingWebSocket;\\n  private messageQueue: MessageQueue;\\n  private heartbeatInterval?: any;\\n  private responseHandlers: Map<string, ResponseHandler> = new Map();\\n  private wsConfig: WebSocketTransportConfig;\\n\\n  constructor(config: TransportConfig) {\\n    super(TransportType.WEBSOCKET, config);\\n    \\n    this.wsConfig = config.websocket || {\\n      heartbeatInterval: 30000,\\n      reconnectDelay: 1000,\\n      maxReconnectAttempts: 10,\\n      persistMessages: false\\n    };\\n    \\n    this.messageQueue = {\\n      messages: [],\\n      maxSize: 1000,\\n      persistToDisk: this.wsConfig.persistMessages || false\\n    };\\n  }\\n\\n  protected async doInitialize(): Promise<void> {\\n    // Validate WebSocket support in environment\\n    const environment = EnvironmentDetector.detect();\\n    if (!environment.hasWebSocket) {\\n      throw new Error('WebSocket transport not supported in this environment');\\n    }\\n\\n    this.debug('WebSocket transport initialized');\\n  }\\n\\n  async connect(): Promise<void> {\\n    if (!this.config.serverUrl) {\\n      throw new Error('Server URL required for WebSocket transport');\\n    }\\n\\n    return new Promise((resolve, reject) => {\\n      const wsUrl = this.config.serverUrl!.replace(/^http/, 'ws') + '/api/v1/devpipe/ws';\\n      \\n      this.websocket = new ReconnectingWebSocket(wsUrl, [], {\\n        connectionTimeout: this.config.timeout,\\n        debug: this.config.debug,\\n        maxReconnectAttempts: this.wsConfig.maxReconnectAttempts,\\n        reconnectDelay: this.wsConfig.reconnectDelay\\n      });\\n      \\n      this.websocket.onopen = () => {\\n        this.connected = true;\\n        this.healthStatus.status = 'healthy';\\n        this.startHeartbeat();\\n        this.emit(TransportEvent.CONNECTED, { transport: this.type });\\n        this.debug('WebSocket connected');\\n        resolve();\\n      };\\n      \\n      this.websocket.onerror = (error) => {\\n        this.debug('WebSocket error:', error);\\n        this.emit(TransportEvent.ERROR, error);\\n        if (!this.connected) {\\n          reject(new Error('Failed to connect WebSocket'));\\n        }\\n      };\\n      \\n      this.websocket.onmessage = (event) => {\\n        this.handleMessage(event.data);\\n      };\\n      \\n      this.websocket.onclose = () => {\\n        this.connected = false;\\n        this.healthStatus.status = 'disconnected';\\n        this.stopHeartbeat();\\n        this.emit(TransportEvent.DISCONNECTED, { transport: this.type });\\n        this.debug('WebSocket disconnected');\\n      };\\n    });\\n  }\\n\\n  async disconnect(): Promise<void> {\\n    // Reject all pending response handlers\\n    const handlers = Array.from(this.responseHandlers.values());\\n    for (const handler of handlers) {\\n      clearTimeout(handler.timeout);\\n      handler.reject(new Error('Transport disconnected'));\\n    }\\n    this.responseHandlers.clear();\\n\\n    // Stop heartbeat\\n    this.stopHeartbeat();\\n\\n    // Close WebSocket\\n    if (this.websocket) {\\n      this.websocket.close();\\n      this.websocket = undefined;\\n    }\\n\\n    this.connected = false;\\n    this.healthStatus.status = 'disconnected';\\n    this.emit(TransportEvent.DISCONNECTED, { transport: this.type });\\n    \\n    this.debug('WebSocket transport disconnected');\\n  }\\n\\n  async send(message: DevPipeMessage): Promise<DevPipeResponse> {\\n    if (!this.isConnected()) {\\n      throw new Error('WebSocket transport not connected');\\n    }\\n\\n    // Add message ID if not present\\n    if (!message.id) {\\n      message.id = this.generateMessageId();\\n    }\\n\\n    // Add timestamp\\n    message.timestamp = Date.now();\\n\\n    return this.executeWithCircuitBreaker(async () => {\\n      return this.sendWebSocketMessage(message);\\n    }, 'websocket_send');\\n  }\\n\\n  private async sendWebSocketMessage(message: DevPipeMessage): Promise<DevPipeResponse> {\\n    return new Promise((resolve, reject) => {\\n      const timeoutHandle = setTimeout(() => {\\n        this.responseHandlers.delete(message.id!);\\n        reject(new Error(`WebSocket request timeout after ${this.config.timeout}ms`));\\n      }, this.config.timeout);\\n\\n      const handler: ResponseHandler = {\\n        resolve: (response) => {\\n          clearTimeout(timeoutHandle);\\n          this.responseHandlers.delete(message.id!);\\n          resolve(response);\\n        },\\n        reject: (error) => {\\n          clearTimeout(timeoutHandle);\\n          this.responseHandlers.delete(message.id!);\\n          reject(error);\\n        },\\n        timeout: timeoutHandle,\\n        timestamp: Date.now()\\n      };\\n\\n      this.responseHandlers.set(message.id!, handler);\\n\\n      try {\\n        this.websocket!.send(JSON.stringify(message));\\n      } catch (error) {\\n        clearTimeout(timeoutHandle);\\n        this.responseHandlers.delete(message.id!);\\n        reject(error);\\n      }\\n    });\\n  }\\n\\n  private handleMessage(data: string): void {\\n    try {\\n      const message = JSON.parse(data);\\n      \\n      if (message.type === 'pong') {\\n        // Handle heartbeat pong\\n        this.debug('Received heartbeat pong');\\n        return;\\n      }\\n      \\n      if (message.type === 'response' && message.replyTo) {\\n        // Handle response to pending request\\n        const handler = this.responseHandlers.get(message.replyTo);\\n        if (handler) {\\n          const response: DevPipeResponse = {\\n            id: message.id,\\n            success: message.success !== false,\\n            payload: message.payload,\\n            error: message.error,\\n            timestamp: Date.now()\\n          };\\n          handler.resolve(response);\\n        }\\n      } else if (message.type === 'health_pong' && message.id) {\\n        // Handle health check response\\n        const handler = this.responseHandlers.get(message.id);\\n        if (handler) {\\n          const response: DevPipeResponse = {\\n            id: message.id,\\n            success: true,\\n            payload: { status: 'healthy' },\\n            timestamp: Date.now()\\n          };\\n          handler.resolve(response);\\n        }\\n      } else {\\n        // Handle incoming message\\n        this.emit(TransportEvent.MESSAGE, message);\\n      }\\n      \\n    } catch (error) {\\n      this.debug('Failed to handle WebSocket message:', error);\\n      this.emit(TransportEvent.ERROR, error);\\n    }\\n  }\\n\\n  private startHeartbeat(): void {\\n    if (this.heartbeatInterval) return;\\n    \\n    this.heartbeatInterval = setInterval(() => {\\n      if (this.isConnected()) {\\n        try {\\n          this.websocket!.send(JSON.stringify({ \\n            type: 'ping', \\n            timestamp: Date.now() \\n          }));\\n        } catch (error) {\\n          this.debug('Failed to send heartbeat:', error);\\n        }\\n      }\\n    }, this.wsConfig.heartbeatInterval || 30000);\\n  }\\n\\n  private stopHeartbeat(): void {\\n    if (this.heartbeatInterval) {\\n      clearInterval(this.heartbeatInterval);\\n      this.heartbeatInterval = undefined;\\n    }\\n  }\\n\\n  protected async doHealthCheck(): Promise<void> {\\n    if (!this.isConnected()) {\\n      throw new Error('WebSocket not connected');\\n    }\\n\\n    // Send ping and wait for pong\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(new Error('Health check timeout'));\\n      }, 5000);\\n      \\n      const pingId = this.generateMessageId();\\n      const handler: ResponseHandler = {\\n        resolve: () => {\\n          clearTimeout(timeout);\\n          resolve();\\n        },\\n        reject: (error) => {\\n          clearTimeout(timeout);\\n          reject(error);\\n        },\\n        timeout,\\n        timestamp: Date.now()\\n      };\\n      \\n      this.responseHandlers.set(pingId, handler);\\n      \\n      try {\\n        this.websocket!.send(JSON.stringify({ \\n          type: 'health_ping', \\n          id: pingId,\\n          timestamp: Date.now()\\n        }));\\n      } catch (error) {\\n        clearTimeout(timeout);\\n        this.responseHandlers.delete(pingId);\\n        reject(error);\\n      }\\n    });\\n  }\\n\\n  getCapabilities(): TransportCapabilities {\\n    return {\\n      supportsRealtime: true,\\n      supportsBidirectional: true,\\n      supportsFileSystem: false,\\n      supportsStreaming: true,\\n      maxMessageSize: 1024 * 1024, // 1MB\\n      averageLatency: this.healthStatus.latency,\\n      maxConcurrentConnections: 1,\\n      reliability: this.calculateReliability(),\\n      supportedEnvironments: ['browser', 'node', 'obsidian']\\n    };\\n  }\\n}\\n\"]}"}
