{"code":"/**\n * Transport Manager - Intelligent transport selection and failover management\n */\nimport { __awaiter } from \"tslib\";\nimport { TransportType, TransportEvent } from './transports/DevPipeTransport';\nimport { HTTPTransport } from './transports/HTTPTransport';\nimport { WebSocketTransport } from './transports/WebSocketTransport';\nimport { FileSystemTransport } from './transports/FileSystemTransport';\nimport { TransportHealthMonitor } from './monitoring/TransportHealthMonitor';\nimport { EnvironmentDetector } from '../utils/EnvironmentDetector';\n/**\n * Transport selector that chooses the best transport based on criteria\n */\nexport class TransportSelector {\n    constructor(criteria) {\n        this.criteria = criteria;\n    }\n    calculateScore(transport, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const capabilities = transport.getCapabilities();\n            const healthStatus = transport.getHealthStatus();\n            // Capability score (0-1)\n            let capabilityScore = 0.5; // Base score\n            if ((context === null || context === void 0 ? void 0 : context.requiresRealtime) && capabilities.supportsRealtime) {\n                capabilityScore += 0.3;\n            }\n            if ((context === null || context === void 0 ? void 0 : context.maxLatency) && capabilities.averageLatency <= context.maxLatency) {\n                capabilityScore += 0.2;\n            }\n            // Normalize capability score\n            capabilityScore = Math.min(capabilityScore, 1.0);\n            // Latency score (0-1, lower latency = higher score)\n            const latencyScore = Math.max(0, 1.0 - (capabilities.averageLatency / 5000));\n            // Reliability score (0-1)\n            const reliabilityScore = capabilities.reliability;\n            // Cost score (simplified - could be enhanced with actual cost data)\n            let costScore = 1.0;\n            if (transport.type === TransportType.HTTP)\n                costScore = 0.8;\n            else if (transport.type === TransportType.WEBSOCKET)\n                costScore = 0.9;\n            else if (transport.type === TransportType.FILESYSTEM)\n                costScore = 1.0;\n            // Availability penalty\n            let availabilityMultiplier = 1.0;\n            if (!transport.isAvailable())\n                availabilityMultiplier = 0;\n            else if (!transport.isConnected())\n                availabilityMultiplier = 0.3;\n            else if (healthStatus.status === 'failing')\n                availabilityMultiplier = 0.1;\n            else if (healthStatus.status === 'degraded')\n                availabilityMultiplier = 0.5;\n            // Calculate weighted score\n            const weightedScore = (latencyScore * this.criteria.latencyWeight +\n                reliabilityScore * this.criteria.reliabilityWeight +\n                capabilityScore * this.criteria.capabilityWeight +\n                costScore * this.criteria.costWeight) * availabilityMultiplier;\n            return Math.max(0, Math.min(1, weightedScore));\n        });\n    }\n    selectBest(available, context) {\n        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n            if (available.length === 0) {\n                resolve(null);\n                return;\n            }\n            // Calculate scores for all available transports\n            const scoredTransports = yield Promise.all(available.map((transport) => __awaiter(this, void 0, void 0, function* () {\n                return ({\n                    transport,\n                    score: yield this.calculateScore(transport, context)\n                });\n            })));\n            // Sort by score (highest first)\n            scoredTransports.sort((a, b) => b.score - a.score);\n            // Return the best transport\n            resolve(scoredTransports[0].transport);\n        }));\n    }\n}\n/**\n * Main Transport Manager class\n */\nexport class TransportManager {\n    constructor(config) {\n        this.transports = new Map();\n        this.eventListeners = new Map();\n        this.failoverInProgress = false;\n        this.config = config;\n        this.fallbackChain = config.fallbackChain || [\n            TransportType.WEBSOCKET,\n            TransportType.HTTP,\n            TransportType.FILESYSTEM\n        ];\n        this.healthMonitor = new TransportHealthMonitor();\n        this.selector = new TransportSelector(config.selectionCriteria);\n        this.initializeTransports();\n        this.setupHealthMonitoring();\n    }\n    initializeTransports() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const environment = EnvironmentDetector.detect();\n            // Always initialize HTTP transport (most compatible)\n            const httpTransport = new HTTPTransport(this.config.transportConfigs.http);\n            yield httpTransport.initialize(this.config.transportConfigs.http);\n            this.transports.set(TransportType.HTTP, httpTransport);\n            // Initialize WebSocket transport if supported and configured\n            if (environment.hasWebSocket && this.config.transportConfigs.websocket) {\n                const wsTransport = new WebSocketTransport(this.config.transportConfigs.websocket);\n                yield wsTransport.initialize(this.config.transportConfigs.websocket);\n                this.transports.set(TransportType.WEBSOCKET, wsTransport);\n            }\n            // Initialize FileSystem transport if supported and configured\n            if (environment.hasFileSystem && this.config.transportConfigs.filesystem) {\n                const fsTransport = new FileSystemTransport(this.config.transportConfigs.filesystem);\n                yield fsTransport.initialize(this.config.transportConfigs.filesystem);\n                this.transports.set(TransportType.FILESYSTEM, fsTransport);\n            }\n            // Setup event handlers for each transport\n            const transports = Array.from(this.transports.values());\n            for (const transport of transports) {\n                this.setupTransportEventHandlers(transport);\n            }\n            this.debug(`Initialized ${this.transports.size} transports`);\n        });\n    }\n    setupTransportEventHandlers(transport) {\n        transport.on(TransportEvent.CONNECTED, () => {\n            this.debug(`Transport ${transport.type} connected`);\n            this.emit('transport_connected', { transport: transport.type });\n        });\n        transport.on(TransportEvent.DISCONNECTED, () => {\n            this.debug(`Transport ${transport.type} disconnected`);\n            this.emit('transport_disconnected', { transport: transport.type });\n            // Trigger failover if this was the active transport\n            if (this.activeTransport === transport && this.config.autoFailover !== false) {\n                this.handleTransportFailure(transport);\n            }\n        });\n        transport.on(TransportEvent.ERROR, (error) => {\n            this.debug(`Transport ${transport.type} error:`, error);\n            this.emit('transport_error', { transport: transport.type, error });\n        });\n        transport.on(TransportEvent.MESSAGE, (message) => {\n            this.emit('message', message);\n        });\n    }\n    setupHealthMonitoring() {\n        const transports = Array.from(this.transports.values());\n        for (const transport of transports) {\n            this.healthMonitor.startMonitoring(transport, this.config.healthCheckInterval || 30000);\n        }\n        this.healthMonitor.on('health-updated', (assessment) => {\n            var _a;\n            this.emit('health_updated', assessment);\n            // Consider transport switching if current transport is degrading\n            if (((_a = this.activeTransport) === null || _a === void 0 ? void 0 : _a.type) === assessment.transport &&\n                assessment.recommendation === 'avoid' &&\n                !this.failoverInProgress) {\n                this.selectOptimalTransport();\n            }\n        });\n    }\n    selectOptimalTransport(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const availableTransports = Array.from(this.transports.values())\n                .filter(transport => transport.isAvailable());\n            if (availableTransports.length === 0) {\n                throw new Error('No available transports');\n            }\n            const selectedTransport = yield this.selector.selectBest(availableTransports, context);\n            if (!selectedTransport) {\n                throw new Error('No suitable transport found');\n            }\n            if (this.activeTransport !== selectedTransport) {\n                yield this.switchTransport(selectedTransport, 'optimization');\n            }\n            return selectedTransport;\n        });\n    }\n    switchTransport(newTransport, reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const oldTransport = this.activeTransport;\n            try {\n                this.debug(`Switching transport from ${(oldTransport === null || oldTransport === void 0 ? void 0 : oldTransport.type) || 'none'} to ${newTransport.type} (${reason})`);\n                // Connect new transport if not already connected\n                if (!newTransport.isConnected()) {\n                    yield newTransport.connect();\n                }\n                // Switch active transport\n                this.activeTransport = newTransport;\n                // Disconnect old transport if different (but don't await to avoid delays)\n                if (oldTransport && oldTransport !== newTransport) {\n                    oldTransport.disconnect().catch(error => {\n                        this.debug(`Error disconnecting old transport ${oldTransport.type}:`, error);\n                    });\n                }\n                this.emit('transport_switched', {\n                    from: oldTransport === null || oldTransport === void 0 ? void 0 : oldTransport.type,\n                    to: newTransport.type,\n                    reason\n                });\n            }\n            catch (error) {\n                // Rollback if switch failed\n                if (oldTransport && oldTransport.isConnected()) {\n                    this.activeTransport = oldTransport;\n                }\n                throw error;\n            }\n        });\n    }\n    handleTransportFailure(failedTransport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.failoverInProgress)\n                return;\n            this.failoverInProgress = true;\n            try {\n                this.debug(`Handling failure of transport ${failedTransport.type}`);\n                this.emit('transport_failed', {\n                    transport: failedTransport.type,\n                    timestamp: Date.now()\n                });\n                // Try fallback chain\n                for (const transportType of this.fallbackChain) {\n                    if (transportType === failedTransport.type)\n                        continue;\n                    const fallbackTransport = this.transports.get(transportType);\n                    if (fallbackTransport && fallbackTransport.isAvailable()) {\n                        try {\n                            yield this.switchTransport(fallbackTransport, 'failover');\n                            this.debug(`Successfully failed over to ${transportType}`);\n                            return;\n                        }\n                        catch (error) {\n                            this.debug(`Failover to ${transportType} failed:`, error);\n                            continue;\n                        }\n                    }\n                }\n                throw new Error('All transports failed');\n            }\n            finally {\n                this.failoverInProgress = false;\n            }\n        });\n    }\n    send(message, context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Ensure we have an active transport\n            if (!this.activeTransport) {\n                yield this.selectOptimalTransport(context);\n            }\n            if (!this.activeTransport) {\n                throw new Error('No active transport available');\n            }\n            try {\n                return yield this.activeTransport.send(message);\n            }\n            catch (error) {\n                // Handle transport failure and retry\n                this.debug(`Send failed on ${this.activeTransport.type}, attempting failover`);\n                yield this.handleTransportFailure(this.activeTransport);\n                if (this.activeTransport) {\n                    return yield this.activeTransport.send(message);\n                }\n                else {\n                    throw error;\n                }\n            }\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.selectOptimalTransport();\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const disconnectPromises = Array.from(this.transports.values())\n                .map(transport => transport.disconnect().catch(error => {\n                this.debug(`Error disconnecting transport ${transport.type}:`, error);\n            }));\n            yield Promise.all(disconnectPromises);\n            this.activeTransport = undefined;\n        });\n    }\n    getActiveTransport() {\n        return this.activeTransport;\n    }\n    getAvailableTransports() {\n        return Array.from(this.transports.values())\n            .filter(transport => transport.isAvailable());\n    }\n    getTransportHealth() {\n        const assessments = new Map();\n        const transports = Array.from(this.transports.values());\n        for (const transport of transports) {\n            assessments.set(transport.type, this.healthMonitor.assessTransportHealth(transport));\n        }\n        return assessments;\n    }\n    // Event system\n    on(event, listener) {\n        if (!this.eventListeners.has(event)) {\n            this.eventListeners.set(event, []);\n        }\n        this.eventListeners.get(event).push(listener);\n    }\n    off(event, listener) {\n        const listeners = this.eventListeners.get(event);\n        if (listeners) {\n            const index = listeners.indexOf(listener);\n            if (index > -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    emit(event, data) {\n        const listeners = this.eventListeners.get(event);\n        if (listeners) {\n            listeners.forEach(listener => {\n                try {\n                    listener(data);\n                }\n                catch (error) {\n                    this.debug(`Error in transport manager event listener for ${event}:`, error);\n                }\n            });\n        }\n    }\n    debug(message, ...args) {\n        if (this.config.debug) {\n            console.log(`[TransportManager] ${message}`, ...args);\n        }\n    }\n}\n//# sourceMappingURL=TransportManager.js.map","references":["/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/DevPipeTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/HTTPTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/WebSocketTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/transports/FileSystemTransport.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/devpipe/monitoring/TransportHealthMonitor.ts","/Users/malachiledbetter/Documents/GitHub/VaultPilot/vaultpilot/src/utils/EnvironmentDetector.ts"],"map":"{\"version\":3,\"file\":\"TransportManager.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/devpipe/TransportManager.ts\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * Transport Manager - Intelligent transport selection and failover management\\n */\\n\\nimport { \\n  DevPipeTransport,\\n  TransportType,\\n  TransportConfig,\\n  DevPipeMessage,\\n  DevPipeResponse,\\n  TransportEvent\\n} from './transports/DevPipeTransport';\\nimport { HTTPTransport } from './transports/HTTPTransport';\\nimport { WebSocketTransport } from './transports/WebSocketTransport';\\nimport { FileSystemTransport } from './transports/FileSystemTransport';\\nimport { TransportHealthMonitor, HealthAssessment } from './monitoring/TransportHealthMonitor';\\nimport { EnvironmentDetector } from '../utils/EnvironmentDetector';\\n\\nexport interface TransportSelectionCriteria {\\n  latencyWeight: number;      // 0-1\\n  reliabilityWeight: number;  // 0-1\\n  capabilityWeight: number;   // 0-1\\n  costWeight: number;         // 0-1\\n}\\n\\nexport interface TransportManagerConfig {\\n  selectionCriteria: TransportSelectionCriteria;\\n  fallbackChain: TransportType[];\\n  transportConfigs: {\\n    http: TransportConfig;\\n    websocket?: TransportConfig;\\n    filesystem?: TransportConfig;\\n  };\\n  healthCheckInterval?: number;\\n  autoFailover?: boolean;\\n  debug?: boolean;\\n}\\n\\nexport interface SelectionContext {\\n  messageType?: string;\\n  priority?: 'low' | 'normal' | 'high' | 'critical';\\n  requiresRealtime?: boolean;\\n  maxLatency?: number;\\n  retryAttempt?: number;\\n}\\n\\n/**\\n * Transport selector that chooses the best transport based on criteria\\n */\\nexport class TransportSelector {\\n  private criteria: TransportSelectionCriteria;\\n\\n  constructor(criteria: TransportSelectionCriteria) {\\n    this.criteria = criteria;\\n  }\\n\\n  async calculateScore(transport: DevPipeTransport, context?: SelectionContext): Promise<number> {\\n    const capabilities = transport.getCapabilities();\\n    const healthStatus = transport.getHealthStatus();\\n    \\n    // Capability score (0-1)\\n    let capabilityScore = 0.5; // Base score\\n    \\n    if (context?.requiresRealtime && capabilities.supportsRealtime) {\\n      capabilityScore += 0.3;\\n    }\\n    \\n    if (context?.maxLatency && capabilities.averageLatency <= context.maxLatency) {\\n      capabilityScore += 0.2;\\n    }\\n    \\n    // Normalize capability score\\n    capabilityScore = Math.min(capabilityScore, 1.0);\\n    \\n    // Latency score (0-1, lower latency = higher score)\\n    const latencyScore = Math.max(0, 1.0 - (capabilities.averageLatency / 5000));\\n    \\n    // Reliability score (0-1)\\n    const reliabilityScore = capabilities.reliability;\\n    \\n    // Cost score (simplified - could be enhanced with actual cost data)\\n    let costScore = 1.0;\\n    if (transport.type === TransportType.HTTP) costScore = 0.8;\\n    else if (transport.type === TransportType.WEBSOCKET) costScore = 0.9;\\n    else if (transport.type === TransportType.FILESYSTEM) costScore = 1.0;\\n    \\n    // Availability penalty\\n    let availabilityMultiplier = 1.0;\\n    if (!transport.isAvailable()) availabilityMultiplier = 0;\\n    else if (!transport.isConnected()) availabilityMultiplier = 0.3;\\n    else if (healthStatus.status === 'failing') availabilityMultiplier = 0.1;\\n    else if (healthStatus.status === 'degraded') availabilityMultiplier = 0.5;\\n    \\n    // Calculate weighted score\\n    const weightedScore = (\\n      latencyScore * this.criteria.latencyWeight +\\n      reliabilityScore * this.criteria.reliabilityWeight +\\n      capabilityScore * this.criteria.capabilityWeight +\\n      costScore * this.criteria.costWeight\\n    ) * availabilityMultiplier;\\n    \\n    return Math.max(0, Math.min(1, weightedScore));\\n  }\\n\\n  selectBest(\\n    available: DevPipeTransport[], \\n    context?: SelectionContext\\n  ): Promise<DevPipeTransport | null> {\\n    return new Promise(async (resolve) => {\\n      if (available.length === 0) {\\n        resolve(null);\\n        return;\\n      }\\n      \\n      // Calculate scores for all available transports\\n      const scoredTransports = await Promise.all(\\n        available.map(async (transport) => ({\\n          transport,\\n          score: await this.calculateScore(transport, context)\\n        }))\\n      );\\n      \\n      // Sort by score (highest first)\\n      scoredTransports.sort((a, b) => b.score - a.score);\\n      \\n      // Return the best transport\\n      resolve(scoredTransports[0].transport);\\n    });\\n  }\\n}\\n\\n/**\\n * Main Transport Manager class\\n */\\nexport class TransportManager {\\n  private transports: Map<TransportType, DevPipeTransport> = new Map();\\n  private activeTransport?: DevPipeTransport;\\n  private fallbackChain: TransportType[];\\n  private healthMonitor: TransportHealthMonitor;\\n  private selector: TransportSelector;\\n  private config: TransportManagerConfig;\\n  private eventListeners: Map<string, Function[]> = new Map();\\n  private failoverInProgress: boolean = false;\\n\\n  constructor(config: TransportManagerConfig) {\\n    this.config = config;\\n    this.fallbackChain = config.fallbackChain || [\\n      TransportType.WEBSOCKET,\\n      TransportType.HTTP,\\n      TransportType.FILESYSTEM\\n    ];\\n    \\n    this.healthMonitor = new TransportHealthMonitor();\\n    this.selector = new TransportSelector(config.selectionCriteria);\\n    \\n    this.initializeTransports();\\n    this.setupHealthMonitoring();\\n  }\\n\\n  private async initializeTransports(): Promise<void> {\\n    const environment = EnvironmentDetector.detect();\\n    \\n    // Always initialize HTTP transport (most compatible)\\n    const httpTransport = new HTTPTransport(this.config.transportConfigs.http);\\n    await httpTransport.initialize(this.config.transportConfigs.http);\\n    this.transports.set(TransportType.HTTP, httpTransport);\\n    \\n    // Initialize WebSocket transport if supported and configured\\n    if (environment.hasWebSocket && this.config.transportConfigs.websocket) {\\n      const wsTransport = new WebSocketTransport(this.config.transportConfigs.websocket);\\n      await wsTransport.initialize(this.config.transportConfigs.websocket);\\n      this.transports.set(TransportType.WEBSOCKET, wsTransport);\\n    }\\n    \\n    // Initialize FileSystem transport if supported and configured\\n    if (environment.hasFileSystem && this.config.transportConfigs.filesystem) {\\n      const fsTransport = new FileSystemTransport(this.config.transportConfigs.filesystem);\\n      await fsTransport.initialize(this.config.transportConfigs.filesystem);\\n      this.transports.set(TransportType.FILESYSTEM, fsTransport);\\n    }\\n    \\n    // Setup event handlers for each transport\\n    const transports = Array.from(this.transports.values());\\n    for (const transport of transports) {\\n      this.setupTransportEventHandlers(transport);\\n    }\\n    \\n    this.debug(`Initialized ${this.transports.size} transports`);\\n  }\\n\\n  private setupTransportEventHandlers(transport: DevPipeTransport): void {\\n    transport.on(TransportEvent.CONNECTED, () => {\\n      this.debug(`Transport ${transport.type} connected`);\\n      this.emit('transport_connected', { transport: transport.type });\\n    });\\n    \\n    transport.on(TransportEvent.DISCONNECTED, () => {\\n      this.debug(`Transport ${transport.type} disconnected`);\\n      this.emit('transport_disconnected', { transport: transport.type });\\n      \\n      // Trigger failover if this was the active transport\\n      if (this.activeTransport === transport && this.config.autoFailover !== false) {\\n        this.handleTransportFailure(transport);\\n      }\\n    });\\n    \\n    transport.on(TransportEvent.ERROR, (error) => {\\n      this.debug(`Transport ${transport.type} error:`, error);\\n      this.emit('transport_error', { transport: transport.type, error });\\n    });\\n    \\n    transport.on(TransportEvent.MESSAGE, (message) => {\\n      this.emit('message', message);\\n    });\\n  }\\n\\n  private setupHealthMonitoring(): void {\\n    const transports = Array.from(this.transports.values());\\n    for (const transport of transports) {\\n      this.healthMonitor.startMonitoring(\\n        transport, \\n        this.config.healthCheckInterval || 30000\\n      );\\n    }\\n    \\n    this.healthMonitor.on('health-updated', (assessment: HealthAssessment) => {\\n      this.emit('health_updated', assessment);\\n      \\n      // Consider transport switching if current transport is degrading\\n      if (this.activeTransport?.type === assessment.transport && \\n          assessment.recommendation === 'avoid' &&\\n          !this.failoverInProgress) {\\n        this.selectOptimalTransport();\\n      }\\n    });\\n  }\\n\\n  async selectOptimalTransport(context?: SelectionContext): Promise<DevPipeTransport> {\\n    const availableTransports = Array.from(this.transports.values())\\n      .filter(transport => transport.isAvailable());\\n    \\n    if (availableTransports.length === 0) {\\n      throw new Error('No available transports');\\n    }\\n    \\n    const selectedTransport = await this.selector.selectBest(availableTransports, context);\\n    if (!selectedTransport) {\\n      throw new Error('No suitable transport found');\\n    }\\n    \\n    if (this.activeTransport !== selectedTransport) {\\n      await this.switchTransport(selectedTransport, 'optimization');\\n    }\\n    \\n    return selectedTransport;\\n  }\\n\\n  private async switchTransport(\\n    newTransport: DevPipeTransport, \\n    reason: 'optimization' | 'failover' | 'manual'\\n  ): Promise<void> {\\n    const oldTransport = this.activeTransport;\\n    \\n    try {\\n      this.debug(`Switching transport from ${oldTransport?.type || 'none'} to ${newTransport.type} (${reason})`);\\n      \\n      // Connect new transport if not already connected\\n      if (!newTransport.isConnected()) {\\n        await newTransport.connect();\\n      }\\n      \\n      // Switch active transport\\n      this.activeTransport = newTransport;\\n      \\n      // Disconnect old transport if different (but don't await to avoid delays)\\n      if (oldTransport && oldTransport !== newTransport) {\\n        oldTransport.disconnect().catch(error => {\\n          this.debug(`Error disconnecting old transport ${oldTransport.type}:`, error);\\n        });\\n      }\\n      \\n      this.emit('transport_switched', {\\n        from: oldTransport?.type,\\n        to: newTransport.type,\\n        reason\\n      });\\n      \\n    } catch (error) {\\n      // Rollback if switch failed\\n      if (oldTransport && oldTransport.isConnected()) {\\n        this.activeTransport = oldTransport;\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  async handleTransportFailure(failedTransport: DevPipeTransport): Promise<void> {\\n    if (this.failoverInProgress) return;\\n    this.failoverInProgress = true;\\n    \\n    try {\\n      this.debug(`Handling failure of transport ${failedTransport.type}`);\\n      this.emit('transport_failed', {\\n        transport: failedTransport.type,\\n        timestamp: Date.now()\\n      });\\n      \\n      // Try fallback chain\\n      for (const transportType of this.fallbackChain) {\\n        if (transportType === failedTransport.type) continue;\\n        \\n        const fallbackTransport = this.transports.get(transportType);\\n        if (fallbackTransport && fallbackTransport.isAvailable()) {\\n          try {\\n            await this.switchTransport(fallbackTransport, 'failover');\\n            this.debug(`Successfully failed over to ${transportType}`);\\n            return;\\n          } catch (error) {\\n            this.debug(`Failover to ${transportType} failed:`, error);\\n            continue;\\n          }\\n        }\\n      }\\n      \\n      throw new Error('All transports failed');\\n      \\n    } finally {\\n      this.failoverInProgress = false;\\n    }\\n  }\\n\\n  async send(message: DevPipeMessage, context?: SelectionContext): Promise<DevPipeResponse> {\\n    // Ensure we have an active transport\\n    if (!this.activeTransport) {\\n      await this.selectOptimalTransport(context);\\n    }\\n    \\n    if (!this.activeTransport) {\\n      throw new Error('No active transport available');\\n    }\\n    \\n    try {\\n      return await this.activeTransport.send(message);\\n    } catch (error) {\\n      // Handle transport failure and retry\\n      this.debug(`Send failed on ${this.activeTransport.type}, attempting failover`);\\n      await this.handleTransportFailure(this.activeTransport);\\n      \\n      if (this.activeTransport) {\\n        return await this.activeTransport.send(message);\\n      } else {\\n        throw error;\\n      }\\n    }\\n  }\\n\\n  async connect(): Promise<void> {\\n    await this.selectOptimalTransport();\\n  }\\n\\n  async disconnect(): Promise<void> {\\n    const disconnectPromises = Array.from(this.transports.values())\\n      .map(transport => transport.disconnect().catch(error => {\\n        this.debug(`Error disconnecting transport ${transport.type}:`, error);\\n      }));\\n    \\n    await Promise.all(disconnectPromises);\\n    this.activeTransport = undefined;\\n  }\\n\\n  getActiveTransport(): DevPipeTransport | undefined {\\n    return this.activeTransport;\\n  }\\n\\n  getAvailableTransports(): DevPipeTransport[] {\\n    return Array.from(this.transports.values())\\n      .filter(transport => transport.isAvailable());\\n  }\\n\\n  getTransportHealth(): Map<TransportType, HealthAssessment> {\\n    const assessments = new Map<TransportType, HealthAssessment>();\\n    \\n    const transports = Array.from(this.transports.values());\\n    for (const transport of transports) {\\n      assessments.set(transport.type, this.healthMonitor.assessTransportHealth(transport));\\n    }\\n    \\n    return assessments;\\n  }\\n\\n  // Event system\\n  on(event: string, listener: Function): void {\\n    if (!this.eventListeners.has(event)) {\\n      this.eventListeners.set(event, []);\\n    }\\n    this.eventListeners.get(event)!.push(listener);\\n  }\\n\\n  off(event: string, listener: Function): void {\\n    const listeners = this.eventListeners.get(event);\\n    if (listeners) {\\n      const index = listeners.indexOf(listener);\\n      if (index > -1) {\\n        listeners.splice(index, 1);\\n      }\\n    }\\n  }\\n\\n  private emit(event: string, data: any): void {\\n    const listeners = this.eventListeners.get(event);\\n    if (listeners) {\\n      listeners.forEach(listener => {\\n        try {\\n          listener(data);\\n        } catch (error) {\\n          this.debug(`Error in transport manager event listener for ${event}:`, error);\\n        }\\n      });\\n    }\\n  }\\n\\n  private debug(message: string, ...args: any[]): void {\\n    if (this.config.debug) {\\n      console.log(`[TransportManager] ${message}`, ...args);\\n    }\\n  }\\n}\\n\"]}"}
